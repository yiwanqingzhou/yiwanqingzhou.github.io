---
title: 长度最小的子数组
date: 2022-09-17
tags:
- coding
- algorithm
- c++
categories:
- algorithm
hidden: true
---



# 209. 长度最小的子数组



## 题目说明

[Leetcode题目链接](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)



给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。



**示例 1：**

```
输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```



**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`



**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(nlogn)` 时间复杂度的解法。



## 解题思路

### 暴力枚举

- 时间复杂度: O(n^2)


### 双指针：滑动窗口

通过不断地调节子数组的起始位置和终止位置，（`>= target` 时起始位置向前，`< target` 时终止位置向前，）从而遍历所有满足需求的子数组，比较长度得出结果。

- 时间复杂度: O(n)

```C++
int minSubArrayLen(int target, std::vector<int> &nums) {
  int result = nums.size() + 1;

  int left = 0;
  int sum = 0;
  int length = 0;

  for (int right = 0; right < nums.size(); right++) {
    sum += nums[right];
    length++;
    while (sum >= target) {
      result = std::min(result, length);

      sum = sum - nums[left++];
      length--;
    }
  }

  return result > nums.size() ? 0 : result;
}
```

### 二分

- 时间复杂度: O(nlogn)
