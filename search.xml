<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 使用boost::program_options解析命令行选项</title>
    <url>/boost-options-description.html</url>
    <content><![CDATA[<p>Boost.ProgramOptions是Boost中一个专门用来解析命令行的库，其目标是轻松的解析命令行选项。</p>
<a id="more"></a>



<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/program_options.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_notifier</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"On notifier: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> po = boost::program_options;</span><br><span class="line">    po::<span class="function">options_description <span class="title">desc</span><span class="params">(<span class="string">"Options"</span>)</span></span>;</span><br><span class="line">    desc.add_options()</span><br><span class="line">        (<span class="string">"enable_something,e"</span>, <span class="string">"Enable Something"</span>)</span><br><span class="line">        (<span class="string">"test_string,s"</span>, po::value&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(), <span class="string">"Test String"</span>)</span><br><span class="line">        (<span class="string">"test_int,p"</span>, po::value&lt;<span class="keyword">int</span>&gt;(), <span class="string">"Test Int"</span>)</span><br><span class="line">        (<span class="string">"test_default_value,d"</span>,po::value&lt;<span class="keyword">int</span>&gt;()-&gt;default_value(<span class="number">1</span>), <span class="string">"Test Default Value"</span>)</span><br><span class="line">        (<span class="string">"test_notifier"</span>, value&lt;<span class="keyword">int</span>&gt;()-&gt;notifier(on_notifier), <span class="string">"Test Notifier"</span>);</span><br><span class="line">    po::variables_map vm;</span><br><span class="line">  	po::store(po::parse_command_line(argc, argv, desc), vm);</span><br><span class="line">  	po::notify(vm);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// no options set</span></span><br><span class="line">    <span class="comment">// print all options</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span> || !vm.count(<span class="string">"sensor_id"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; desc &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> enable_something = vm.count(<span class="string">"enable_something"</span>);</span><br><span class="line">    <span class="keyword">int</span> value = vm[<span class="string">"test_default_value"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_string"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ss = vm[<span class="string">"test_string"</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_string was set to: "</span>  &lt;&lt; ss &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_int"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dd = vm[<span class="string">"test_int"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_int was set to: "</span>  &lt;&lt; dd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CMake里引入依赖"><a href="#CMake里引入依赖" class="headerlink" title="CMake里引入依赖"></a>CMake里引入依赖</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost COMPONENTS program_options REQUIRED)</span><br><span class="line"><span class="keyword">target_include_directories</span>(myTarget PRIVATE <span class="variable">$&#123;Boost_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myTarget <span class="variable">$&#123;Boost_LIBRARIES&#125;</span> )</span><br></pre></td></tr></table></figure>

<p><a href="https://www.boost.org/doc/libs/1_63_0/doc/html/program_options/tutorial.html#idp523371328" target="_blank" rel="noopener">官方Tutorial参考</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake设置编译选项</title>
    <url>/cmake-set-flag.html</url>
    <content><![CDATA[<h4 id="CMake中设置编译选项"><a href="#CMake中设置编译选项" class="headerlink" title="CMake中设置编译选项"></a>CMake中设置编译选项</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_VISUALIZATIONS <span class="string">"Build visualization, default OFF"</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"BUILD_VISUALIZATIONS is $&#123;BUILD_VISUALIZATIONS&#125;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以跟build type关联</span></span><br><span class="line"><span class="comment"># if(CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES DEBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_VISUALIZATIONS)</span><br><span class="line"><span class="keyword">add_definitions</span>(-DBUILD_VISUALIZATIONS)</span><br><span class="line"><span class="comment"># target_compile_definitions($&#123;project_name&#125; PRIVATE BUILD_VISUALIZATIONS)</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="代码中作为宏"><a href="#代码中作为宏" class="headerlink" title="代码中作为宏"></a>代码中作为宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BUILD_VISUALIZATIONS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(<span class="keyword">const</span> <span class="keyword">cloud_ptr_t</span>&amp; cloud_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"visualizations on"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// visualize cloud</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(Args...)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pass visualizations"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="编译时传入参数"><a href="#编译时传入参数" class="headerlink" title="编译时传入参数"></a>编译时传入参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--cmake-args -DBUILD_VISUALIZATIONS=ON</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 使用clang格式化代码</title>
    <url>/clang_format.html</url>
    <content><![CDATA[<p>.clang-format文件存档</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Language:        Cpp</span><br><span class="line"># BasedOnStyle:  LLVM</span><br><span class="line">AccessModifierOffset: -2</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveAssignments: false</span><br><span class="line">AlignConsecutiveDeclarations: false</span><br><span class="line">AlignEscapedNewlinesLeft: false</span><br><span class="line">AlignOperands:   true</span><br><span class="line">AlignTrailingComments: true</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: true</span><br><span class="line">AllowShortBlocksOnASingleLine: false</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: false</span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: false</span><br><span class="line">AllowShortLoopsOnASingleLine: false</span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: false</span><br><span class="line">BinPackArguments: true</span><br><span class="line">BinPackParameters: false</span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterClass:      false</span><br><span class="line">  AfterControlStatement: false</span><br><span class="line">  AfterEnum:       false</span><br><span class="line">  AfterFunction:   true</span><br><span class="line">  AfterNamespace:  false</span><br><span class="line">  AfterObjCDeclaration: false</span><br><span class="line">  AfterStruct:     true</span><br><span class="line">  AfterUnion:      true</span><br><span class="line">  BeforeCatch:     true</span><br><span class="line">  BeforeElse:      true</span><br><span class="line">  IndentBraces:    false</span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeBraces: Allman</span><br><span class="line">BreakBeforeTernaryOperators: false</span><br><span class="line">BreakConstructorInitializersBeforeComma: false</span><br><span class="line">ColumnLimit:     0</span><br><span class="line">CommentPragmas:  &apos;^ IWYU pragma:&apos;</span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: false</span><br><span class="line">ConstructorInitializerIndentWidth: 4</span><br><span class="line">ContinuationIndentWidth: 4</span><br><span class="line">Cpp11BracedListStyle: true</span><br><span class="line">DerivePointerAlignment: false</span><br><span class="line">DisableFormat:   false</span><br><span class="line">ExperimentalAutoDetectBinPacking: false</span><br><span class="line">ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]</span><br><span class="line">IncludeCategories: </span><br><span class="line">  - Regex:           &apos;^&quot;(llvm|llvm-c|clang|clang-c)/&apos;</span><br><span class="line">    Priority:        2</span><br><span class="line">  - Regex:           &apos;^(&lt;|&quot;(gtest|isl|json)/)&apos;</span><br><span class="line">    Priority:        3</span><br><span class="line">  - Regex:           &apos;.*&apos;</span><br><span class="line">    Priority:        1</span><br><span class="line">IndentCaseLabels: false</span><br><span class="line">IndentWidth:     2</span><br><span class="line">IndentWrappedFunctionNames: false</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: true</span><br><span class="line">MacroBlockBegin: &apos;&apos;</span><br><span class="line">MacroBlockEnd:   &apos;&apos;</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: All</span><br><span class="line">ObjCBlockIndentWidth: 2</span><br><span class="line">ObjCSpaceAfterProperty: false</span><br><span class="line">ObjCSpaceBeforeProtocolList: true</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 19</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 60</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">ReflowComments:  true</span><br><span class="line">SortIncludes:    true</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">SpacesBeforeTrailingComments: 1</span><br><span class="line">SpacesInAngles:  false</span><br><span class="line">SpacesInContainerLiterals: true</span><br><span class="line">SpacesInCStyleCastParentheses: false</span><br><span class="line">SpacesInParentheses: false</span><br><span class="line">SpacesInSquareBrackets: false</span><br><span class="line">Standard:        Cpp11</span><br><span class="line">TabWidth:        8</span><br><span class="line">UseTab:          Never</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian添加最小化按钮</title>
    <url>/debian_minimize_botton.html</url>
    <content><![CDATA[<p>安装tweak和dconf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br><span class="line">sudo apt install dconf-editor </span><br><span class="line">dconf-editor</span><br></pre></td></tr></table></figure><p>进入路径: <code>org/gnome/desktop/wm/preferences/button-layout</code></p><img src="/debian_minimize_botton/test.png" title="debian_minimize_botton"><p>取消选项 Use default value</p><a id="more"></a>








<p>在 Custom value 填入 <code>appmemu:close,minimize,maximize,close</code></p>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：条件变量std::condition_variable的使用</title>
    <url>/condition-variable.html</url>
    <content><![CDATA[<p><code>std::condition_variable</code> 是 C++11 多线程编程中的条件变量。</p>
<p>一般用法: 线程 A <strong>等待</strong>某个条件并挂起，直到线程 B 设置了这个条件，并<strong>通知</strong>条件变量，然后线程 A 被唤醒。</p>
<a id="more"></a>



<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>仅支持默认构造函数，拷贝、赋值和移动(move)均是被禁用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br></pre></td></tr></table></figure>

<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><h5 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h5><p>阻塞当前线程直到被其他线程通知唤醒。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h5><p>只有当 <code>pred</code> 条件为 <code>false</code> 时才会阻塞当前线程，并且在收到其他线程的通知后只有当 <code>pred</code> 为 <code>true</code> 时才会被解除阻塞。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span> (<span class="title">unique_lock</span>&lt;mutex&gt;&amp; <span class="title">lck</span>, <span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pred())</span><br><span class="line">&#123;</span><br><span class="line">	wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>通知线程可以使用 <code>notify_one()</code> 通知一个线程，或一次使用 <code>notify_all()</code> 通知所有线程。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; ready;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" start.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">  cv.wait(lck, [] &#123; <span class="keyword">return</span> ready.load(); &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" done.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ready</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set_ready(): "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  ready.store(<span class="literal">true</span>);</span><br><span class="line">  cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ready.store(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> t_1 = <span class="built_in">std</span>::thread(wait, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> t_2 = <span class="built_in">std</span>::thread(wait, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"join...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  t_1.join();</span><br><span class="line">  t_2.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"all done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread: 139827702187776 id: 1 start.</span><br><span class="line">thread: 139827693795072 id: 2 start.</span><br><span class="line">set_ready(): 1</span><br><span class="line">thread: 139827702187776 id: 1 done.</span><br><span class="line">set_ready(): 1</span><br><span class="line">join....</span><br><span class="line">thread: 139827693795072 id: 2 done.</span><br><span class="line">all done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 解压缩rar包</title>
    <url>/extract_from_rar.html</url>
    <content><![CDATA[<h4 id="下载rar软件安装包"><a href="#下载rar软件安装包" class="headerlink" title="下载rar软件安装包"></a>下载rar软件安装包</h4><ol>
<li><p>直接从 <a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">rarlab</a> 下载安装包</p>
</li>
<li><p>通过命令行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.rarlab.com/rar/rarlinux-x64-6.0.1.tar.gz  <span class="comment"># 64位</span></span><br><span class="line">wget https://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz	   <span class="comment"># 32位</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf rarlinux-x64-6.0.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> rar</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h4 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar x xxx.rar  <span class="comment"># Extract files with full path</span></span><br><span class="line">rar e xxx.rar  <span class="comment"># Extract files without archived paths</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>



<h4 id="将xxx目录压缩为xxx-rar"><a href="#将xxx目录压缩为xxx-rar" class="headerlink" title="将xxx目录压缩为xxx.rar"></a>将xxx目录压缩为xxx.rar</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar a xxx.rar xxx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uncompress</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 搭建FTP服务器</title>
    <url>/ftp_server.html</url>
    <content><![CDATA[<h4 id="安装ftp和vsftpd"><a href="#安装ftp和vsftpd" class="headerlink" title="安装ftp和vsftpd"></a>安装ftp和vsftpd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ftp</span><br><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用vsftpd软件，主要包括如下几个命令：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动ftp</span></span><br><span class="line">service vsftpd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止ftp</span></span><br><span class="line">service vsftpd stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启ftp</span></span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure><a id="more"></a>



<h4 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h4><p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># vi /etc/vsftpd/vsftpd.conf</span></span><br></pre></td></tr></table></figure>

<p>按照需求修改为以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"></span><br><span class="line"># local root</span><br><span class="line">local_root=/home/bot/dev/moma_app/scanner_images</span><br></pre></td></tr></table></figure>

<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>

<h4 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录本地ftp</span></span><br><span class="line">ftp 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名和密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前路径是否设置的local root</span></span><br><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>使用clang和black 对C++、Python代码自动格式化</title>
    <url>/format_code.html</url>
    <content><![CDATA[<h4 id="使用clang对C-进行格式化"><a href="#使用clang对C-进行格式化" class="headerlink" title="使用clang对C++进行格式化"></a>使用<code>clang</code>对C++进行格式化</h4><ul>
<li><p>安装<code>clang-format-7</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y clang-format-7</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写脚本 <code>clang_format.bash</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -regextype egrep -regex <span class="string">".*\.(c|cc|h|hh)$"</span> -not -path <span class="string">'*/install/*'</span> \</span><br><span class="line">  -not -path <span class="string">'*/build/*'</span> -not -path <span class="string">'*/log/*'</span> -not -path <span class="string">'*/deps/*'</span>| xargs clang-format-7 -i</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./clang_format.bash</span><br></pre></td></tr></table></figure>





</li>
</ul><a id="more"></a>
<h4 id="使用black对python进行格式化"><a href="#使用black对python进行格式化" class="headerlink" title="使用black对python进行格式化"></a>使用<code>black</code>对python进行格式化</h4><ul>
<li><p>安装<code>black</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install black==20.8b1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">black .</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>clang</tag>
        <tag>linux</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>pcl类型转换</title>
    <url>/pcl_type_transform.html</url>
    <content><![CDATA[<h4 id="PCL相关类型-对象与指针互换"><a href="#PCL相关类型-对象与指针互换" class="headerlink" title="PCL相关类型 对象与指针互换"></a>PCL相关类型 对象与指针互换</h4><ol>
<li>pcl::PointIndices -&gt; pcl::PointIndices::Ptr</li>
</ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::<span class="function">Ptr <span class="title">inliers_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices(inliers))</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a>


<ol start="2">
<li>pcl::PointIndices::Ptr -&gt; pcl::PointIndices</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::Ptr inliers_ptr;</span><br><span class="line">inliers=*inliers_ptr;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>std::vector<int> -&gt; pcl::IndicesPtr</int></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_indices;</span><br><span class="line">pcl::IndicesPtr indices_ptr = boost::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(vec_indices);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>pcl::PointCloud<pointt> -&gt; pcl::PointCloud<pointt>::Ptr</pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud=*cloud_ptr;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>pcl::PointCloud<pointt>::Ptr -&gt; pcl::PointCloud<pointt></pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud_ptr=cloud.makeShared();</span><br></pre></td></tr></table></figure>

<h4 id="不同数据类型的点云转换"><a href="#不同数据类型的点云转换" class="headerlink" title="不同数据类型的点云转换"></a>不同数据类型的点云转换</h4><ol>
<li>pcl::PointCloud<a href="pcl::PointXYZRGB" target="_blank" rel="noopener">pcl::PointXYZRGB</a> -&gt; pcl::PointCloud<a href="pcl::PointXYZ" target="_blank" rel="noopener">pcl::PointXYZ</a>::Ptr</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="function">Ptr <span class="title">cloud_ori</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::copyPointCloud(*cloud_ori, *cloud);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pcl</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>pcl</tag>
      </tags>
  </entry>
  <entry>
    <title>push_back vs emplace_back</title>
    <url>/push_back-emplace_back.html</url>
    <content><![CDATA[<p><code>push_back()</code>向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中(如果是拷贝的话，事后会自行销毁先前创建的这个元素)。</p><p>而 <code>emplace_back()</code> 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestClass(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;b) : a_(a), b_(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  TestClass(<span class="keyword">const</span> TestClass &amp;other) : a_(other.a_), b_(other.b_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TestClass(TestClass &amp;&amp;other) : a_(other.a_), b_(<span class="built_in">std</span>::move(other.b_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TestClass&gt; vec;</span><br><span class="line">  vec.reserve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">TestClass <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="string">"1"</span>)</span></span>;</span><br><span class="line">  <span class="function">TestClass <span class="title">t2</span><span class="params">(<span class="number">2</span>, <span class="string">"2"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n-----------------0---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(t1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(t1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------1---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t1));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t2));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------2----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------3----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------4----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">constructor</span><br><span class="line">constructor</span><br><span class="line"></span><br><span class="line">-----------------0---------------</span><br><span class="line">copy constructor</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line">-----------------1---------------</span><br><span class="line">move</span><br><span class="line"></span><br><span class="line">move</span><br><span class="line">----------------2----------------</span><br><span class="line">constructor</span><br><span class="line">move</span><br><span class="line"></span><br><span class="line">constructor</span><br><span class="line">move</span><br><span class="line">----------------3----------------</span><br><span class="line">constructor</span><br><span class="line">move</span><br><span class="line"></span><br><span class="line">constructor</span><br><span class="line">----------------4----------------</span><br></pre></td></tr></table></figure>

<p>从结果来看，只有直接调用构造有区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下， <code>emplace_back()</code> 效率更高。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 使用SCP远程拷贝文件</title>
    <url>/scp.html</url>
    <content><![CDATA[<p> 使用scp(secure copy)命令可以实现本地服务器和远程服务器之间的文件传输复制</p>
<a id="more"></a>



<h4 id="从本地复制到远程"><a href="#从本地复制到远程" class="headerlink" title="从本地复制到远程"></a>从本地复制到远程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder/test.txt</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder/test.txt</span><br></pre></td></tr></table></figure>

<h4 id="从远程复制到本地"><a href="#从远程复制到本地" class="headerlink" title="从远程复制到本地"></a>从远程复制到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp bot@10.0.9.211:/home/bot/test_folder text.txt</span><br><span class="line">scp bot@10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br></pre></td></tr></table></figure>

<h4 id="传输整个目录"><a href="#传输整个目录" class="headerlink" title="传输整个目录"></a>传输整个目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /test_folder bot@10.0.9.211:/home/bot/test_folder</span><br></pre></td></tr></table></figure>

<h4 id="其他参数用法"><a href="#其他参数用法" class="headerlink" title="其他参数用法"></a>其他参数用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：std::future的使用</title>
    <url>/std-future.html</url>
    <content><![CDATA[<p><code>std::future</code> 是C++11 的一个模板类，<strong>提供了一种用于访问异步操作结果的机制</strong>。可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。</p>
<p>设想这样的情况，你希望一个线程进行工作A，同时你在做一些其他的工作，你希望在某个特定的时间获取那个工作A的结果。在c++11，这个可以轻松被 <code>std::future</code> 实现。而由于它是一个模板类，可以返回任何类型的结果。</p>
<a id="more"></a>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;Result&gt; fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 进行别的工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取A的结果 </span></span><br><span class="line">Result result = fut.get();</span><br></pre></td></tr></table></figure>

<h4 id="用法说明"><a href="#用法说明" class="headerlink" title="用法说明"></a>用法说明</h4><p><code>std::future</code> 对象通常由某个 <code>Provider</code> 创建，你可以把 <code>Provider</code> 想象成一个异步任务的提供者，<code>Provider</code> 在某个线程中设置共享状态的值，与该共享状态相关联的 <code>std::future</code> 对象（通常在另外一个线程中）调用 <code>std::future::get()</code> 获取该值。如果共享状态的标志不为 <code>std::future_status::ready</code>，则调用 <code>get()</code> 会<strong>阻塞</strong>当前的调用者，直到 <code>Provider</code> 设置了共享状态的值，<code>get()</code> 返回异步任务的返回值或发生的异常。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>std::future</code> 的拷贝构造函数和普通赋值操作是被禁用的，只提供了默认的构造函数和 <code>move</code> 构造函数。默认构造函数构造的对象没有共享状态，因此它是无效的，但是可以通过移动赋值的方式将一个有效的<code>future</code> 值赋值给它。</p>
<p>一个有效的 <code>std::future</code> 对象通常由以下三种 <code>Provider</code> 创建，并和某个共享状态相关联。</p>
<ul>
<li><code>std::async()</code> 函数</li>
<li><code>std::promise::get_future()</code>，为 <code>promise</code> 类的成员函数</li>
<li><code>std::packaged_task::get_future()</code>，为 <code>packaged_task</code> 的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut;           <span class="comment">// 默认构造函数</span></span><br><span class="line">fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::async(test, <span class="number">1</span>));   <span class="comment">// move-赋值操作。</span></span><br></pre></td></tr></table></figure>

<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><p><code>bool valid()</code></p>
<p>检查共享状态的有效性，返回当前的 <code>future</code> 对象是否与共享状态关联。一旦调用了 <code>std::future::get()</code> 函数，再调用此函数将返回 <code>false</code> 。</p>
</li>
<li><p><code>void wait()</code></p>
<ul>
<li>等待共享状态就绪</li>
<li>如果共享状态尚未就绪(即未返回或发生异常)，则该函数将阻塞调用的线程直到就绪</li>
<li>当共享状态就绪后，则该函数将取消阻塞并void返回</li>
</ul>
</li>
<li><p><code>std::future_status wait_for(std::chrono::duration span)</code></p>
<ul>
<li>在指定的时间内等待共享状态就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到设置的时间</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="keyword">auto</span> future_status = fut.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; elapsed_seconds = end - start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waited for : "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result = fut.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waited for : 1.00856s</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>std::future_status wait_until(std::chrono::time_point point)</code></p>
<ul>
<li>在指定的时间点前等待共享状态准备就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到指定的时间点</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
</li>
<li><p><code>_Res get()</code></p>
<ul>
<li>当共享状态就绪时，返回存储在共享状态中的值(或抛出异常)</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪，相当于 <code>wait()</code> 再 <code>get()</code></li>
<li>当共享状态就绪后，则该函数将取消阻塞并返回释放其共享状态，这使得 <code>future</code> 对象不再有效，因此对于每一个 <code>future</code> 共享状态，<code>get()</code>函数最多应被调用一次</li>
<li><code>std::future&lt;void&gt;::get()</code> 不返回任何值，但仍等待共享状态就绪并释放它</li>
</ul>
</li>
<li><p><code>std::shared_future&lt;_Res&gt; share()</code></p>
<ul>
<li>返回一个 <code>std::shared_future</code> 对象，该对象获取 <code>future</code> 对象的共享状态。<code>future</code> 对象将不再有效。</li>
</ul>
</li>
</ul>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test()\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 sec later..\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting..\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -1-</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = <span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::future_status future_status = fut.wait_for(timeout);</span><br><span class="line">  <span class="keyword">if</span> (future_status != <span class="built_in">std</span>::future_status::ready)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 sec timeout!\n"</span>;</span><br><span class="line">    <span class="comment">// return -1;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -2-</span></span><br><span class="line">  fut.wait();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> result = fut.get();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nresult : "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="std-shared-future"><a href="#std-shared-future" class="headerlink" title="std::shared_future"></a><code>std::shared_future</code></h4><p><code>shared_future</code> 与 <code>future</code> 类似，但是允许多个线程等待同一个共享状态。 <code>shared_future</code> 既支持移动操作也支持拷贝操作，而且多个 <code>shared_future</code> 对象可以引用相同的共享状态，还允许多次检索共享状态下的值（多次调用 <code>get()</code> ）。</p>
<p><code>shared_future</code> 可以通过某个 <code>future</code> 对象隐式转换，或者通过 <code>std::future::share()</code> 显示转换，无论哪种转换，被转换的那个 <code>std::future</code> 对象都会变为 <code>not-valid</code>.</p>
<h4 id="std-launch"><a href="#std-launch" class="headerlink" title="std::launch"></a><strong>std::launch</strong></h4><p>该枚举类型主要是在调用<code>std::async</code> 设置异步任务的启动策略的。</p>
<p><code>std::async</code>的原型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async | <span class="built_in">std</span>::launch::deferred, f, args...)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>std::launch::async</code></p>
<p> 表示在调用<code>async</code>函数的时候就开始创建新线程。</p>
</li>
<li><p><code>std::launch::deferred</code></p>
<p>表示延迟调用，在调用 <code>future</code> 中的 <code>wait()</code> 或者 <code>get()</code> 函数时，才执行入口函数。（实际上，并没有创建新线程，只是在主线程中调用的入口函数）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async([]() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// deferred</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::vector的内存分配机制</title>
    <url>/std-vector_memory.html</url>
    <content><![CDATA[<blockquote>
<p><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector;</code></p>
</blockquote><h3 id="std-vector-简介"><a href="#std-vector-简介" class="headerlink" title="std::vector 简介"></a>std::vector 简介</h3><p><code>std::vector</code> 是C++标准库里封装好的<strong>动态大小数组</strong>的顺序容器，能够存放各种类型的对象。</p><p>与数组 <code>array</code> 一样， <code>vector</code> 的<strong>内存空间的地址是连续的</strong>。这意味着可以通过下标索引的方式获取到对应的元素，所以访问其元素的效率非常高，从其末端添加或删除元素的效率也相对较高。而对于涉及在非结束位置插入或删除元素的操作，它们的性能比其他操作差，效率较低。</p><a id="more"></a>


<p>但与<code>array</code>不同的是，它们的大小可以动态变化，它们的存储由容器自动处理。在插入新元素时，若当前容量不能够容纳新的元素，将自动重新申请一块更大的内存空间，将原有数据拷贝到新的内存空间，且释放原来的空间。这一过程非常耗时，为了避免频繁的内容分配， <code>vector</code> 不会在每次添加元素时都重新分配空间，而是分配一些额外的存储空间来容纳可能的增长。因此， <code>vector</code> 的实际容量 (<strong>capacity</strong>) 永远大于等于它容纳的元素大小 (<strong>size</strong>)。</p>
<h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><h4 id="自动增长策略"><a href="#自动增长策略" class="headerlink" title="自动增长策略"></a>自动增长策略</h4><p>假设元素是连续存储的，并且容器的大小是可变的，如果此时向 vector 中添加新的元素，容器不可能简单地将它添加到内存的其它位置，因为元素必须是连续存储的。</p>
<p>容器必须分配新的空间，来保存已有元素和新的元素，将已有的元素从旧位置移动到新空间。然后添加新元素，释放旧的存储空间。如果每添加一个元素，容器就执行一次内存分配和释放，性能会变得超级慢。</p>
<p>为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配的策略。当不得不获取新的空间的时候，<code>vector</code> 的实现，通常会分配比需求空间更大的内存空间。这种分配策略，比每次添加新元素后都重新分配容器内存空间的策略要高效的多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 0  size: 0</span><br><span class="line">2 vec capacity: 1  size: 1</span><br><span class="line">3 vec capacity: 2  size: 2</span><br><span class="line">4 vec capacity: 4  size: 3</span><br><span class="line">5 vec capacity: 4  size: 4</span><br><span class="line">6 vec capacity: 8  size: 5</span><br></pre></td></tr></table></figure>

<p>可以看出，每当 <code>size</code> 和 <code>capacity</code> 相等时，也就是无法容纳新的元素时，<code>vector</code> 自动申请了新的 (成倍增长的) 容量。</p>
<h4 id="手动分配内存-reserve-和-resize"><a href="#手动分配内存-reserve-和-resize" class="headerlink" title="手动分配内存: reserve 和 resize"></a>手动分配内存: reserve 和 resize</h4><p><code>std::vector</code> 有自动分配内存的机制，但我们也可以通过<code>reserve()</code> 和 <code>resize()</code> 来手动分配内存，使其效率更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ele</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ele: "</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : vec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 0</span><br><span class="line">2 vec capacity: 4  size: 4</span><br><span class="line">3 vec capacity: 4  size: 4</span><br><span class="line">ele: 1 2 3 4 </span><br><span class="line">4 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 4 0 </span><br><span class="line">5 vec capacity: 8  size: 3</span><br><span class="line">ele: 1 2 3 </span><br><span class="line">6 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 0 0</span><br></pre></td></tr></table></figure>

<p>可以看出：</p>
<ol>
<li><code>reserve()</code> 只增加不减少数组的 <code>capacity</code>，不对 <code>size()</code> 造成任何改变</li>
<li><code>resize()</code> 只增加不减少数组的 <code>capacity</code>，但可以增加和减少 <code>size</code>。减少时会直接移除多余的元素，增加时会填入默认值 (0)。</li>
</ol>
<h4 id="手动回收内存"><a href="#手动回收内存" class="headerlink" title="手动回收内存"></a>手动回收内存</h4><h5 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h5><p><code>erase()</code> 可以从 <code>vector</code> 中移除单个或一段元素 [begin, end)，实际上是以后面的元素移动并覆盖前面的位置，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin() + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin(), vec.begin() + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 5  size: 5</span><br><span class="line">2 vec capacity: 5  size: 4</span><br><span class="line">ele: 1 3 4 5 </span><br><span class="line">3 vec capacity: 5  size: 2</span><br><span class="line">ele: 4 5</span><br></pre></td></tr></table></figure>

<h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><p><code>clear()</code> 可以移除 <code>vector</code>所有元素，使容器<code>size</code> 为0，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 4</span><br><span class="line">2 vec capacity: 4  size: 0</span><br></pre></td></tr></table></figure>

<h5 id="shrink-to-fit-c-11"><a href="#shrink-to-fit-c-11" class="headerlink" title="shrink_to_fit (c++11)"></a>shrink_to_fit (c++11)</h5><p><code>shrink_to_fit()</code> 可以请求将内存减少到等于当前元素实际所使用的大小，也就是使 <code>capacity = size</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 10  size: 10</span><br><span class="line">2 vec capacity: 10  size: 1</span><br><span class="line">3 vec capacity: 1  size: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 强制类型转换</title>
    <url>/type-cast.html</url>
    <content><![CDATA[<p>相比于C风格的强制类型转换，C++新增了关键字 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code> ，用于强制类型转换。</p><p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>用于非多态类型转换 (静态转换)，任何标准转换都可以用它，但是不能用于两个不相关的类型转换。</p><a id="more"></a>


<p>常用于：</p>
<ul>
<li>基本数据类型之间的转换，如<code>int -&gt; char</code>，这种转换的安全也要开发人员来保证</li>
<li>任何类型的表达式转换成 <code>void</code> 类型</li>
<li>不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">65</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int a: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char a: "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> c = a / b;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: 65</span><br><span class="line">char a: A</span><br><span class="line">c: 6</span><br><span class="line">d: 6.5</span><br></pre></td></tr></table></figure>

<p><strong>没有运行时类型检查来保证转换的安全性</strong></p>
<ul>
<li>上行转型 (子类对象指针–&gt;父类对象指针/引用)： 安全</li>
<li>下行转型(父类对象指针–&gt;子类对象指针/引用)：没有动态类型检查，所以是不安全的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeinfo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">class_name</span><span class="params">()</span> final </span>&#123; <span class="keyword">return</span> <span class="keyword">typeid</span>(*<span class="keyword">this</span>).name(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt_1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt_2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt_3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1A 32686</span><br><span class="line">1B 3</span><br><span class="line">1C 5</span><br></pre></td></tr></table></figure>

<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>动态转换，常用于将一个父类对象的指针转换为子类对象的指针或引用。其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。</p>
<ul>
<li><p>使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过</p>
</li>
<li><p>在进行下行转换时，会进行类型检查 (这个信息存储在类的虚函数表)，比 <code>static_cast</code> 安全</p>
</li>
<li><p>转换后必须是类的指针、引用或 <code>void*</code></p>
</li>
<li><p>对于指针，转换失败会返回<code>nullptr</code>；对于引用，转换失败会 (在运行时) 抛出异常</p>
</li>
</ul>
<p><strong>返回指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b3)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b3 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b1 null</span><br><span class="line">1B 3</span><br><span class="line">b3 null</span><br></pre></td></tr></table></figure>

<p><strong>返回引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  C c;</span><br><span class="line">  A &amp;a1 = b;</span><br><span class="line">  A &amp;a2 = c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a2);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B</span><br><span class="line">terminate called after throwing an instance of <span class="string">'std::bad_cast'</span></span><br><span class="line">  what():  std::bad_cast</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>

<h2 id="std-dynamic-pointer-cast"><a href="#std-dynamic-pointer-cast" class="headerlink" title="std::dynamic_pointer_cast"></a>std::dynamic_pointer_cast</h2><p>使用 <code>std::dynamic_pointer_cast</code> 可以返回 <code>std::shared_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt1 = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt2 = <span class="built_in">std</span>::make_shared&lt;C&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B 3</span><br><span class="line">b2 null</span><br></pre></td></tr></table></figure>

<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。</p>
<p><code>reinterpret_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li><p><code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。</p>
</li>
<li><p>在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p><code>const</code> 限定符通常被用来限定变量，用于表示该变量的值不能被修改。而 <code>const_cast</code> 则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</p>
<p><code>const_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li>该运算符用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性，<code>type_id</code>和 <code>expression</code> 的类型是一样的</li>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
