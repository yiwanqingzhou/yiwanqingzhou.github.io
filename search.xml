<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vscode 使用clang格式化代码</title>
    <url>/clang_format.html</url>
    <content><![CDATA[<p>.clang-format文件存档</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Language:        Cpp</span><br><span class="line"># BasedOnStyle:  LLVM</span><br><span class="line">AccessModifierOffset: -2</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveAssignments: false</span><br><span class="line">AlignConsecutiveDeclarations: false</span><br><span class="line">AlignEscapedNewlinesLeft: false</span><br><span class="line">AlignOperands:   true</span><br><span class="line">AlignTrailingComments: true</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: true</span><br><span class="line">AllowShortBlocksOnASingleLine: false</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: false</span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: false</span><br><span class="line">AllowShortLoopsOnASingleLine: false</span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: false</span><br><span class="line">BinPackArguments: true</span><br><span class="line">BinPackParameters: false</span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterClass:      false</span><br><span class="line">  AfterControlStatement: false</span><br><span class="line">  AfterEnum:       false</span><br><span class="line">  AfterFunction:   true</span><br><span class="line">  AfterNamespace:  false</span><br><span class="line">  AfterObjCDeclaration: false</span><br><span class="line">  AfterStruct:     true</span><br><span class="line">  AfterUnion:      true</span><br><span class="line">  BeforeCatch:     true</span><br><span class="line">  BeforeElse:      true</span><br><span class="line">  IndentBraces:    false</span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeBraces: Allman</span><br><span class="line">BreakBeforeTernaryOperators: false</span><br><span class="line">BreakConstructorInitializersBeforeComma: false</span><br><span class="line">ColumnLimit:     0</span><br><span class="line">CommentPragmas:  &apos;^ IWYU pragma:&apos;</span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: false</span><br><span class="line">ConstructorInitializerIndentWidth: 4</span><br><span class="line">ContinuationIndentWidth: 4</span><br><span class="line">Cpp11BracedListStyle: true</span><br><span class="line">DerivePointerAlignment: false</span><br><span class="line">DisableFormat:   false</span><br><span class="line">ExperimentalAutoDetectBinPacking: false</span><br><span class="line">ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]</span><br><span class="line">IncludeCategories: </span><br><span class="line">  - Regex:           &apos;^&quot;(llvm|llvm-c|clang|clang-c)/&apos;</span><br><span class="line">    Priority:        2</span><br><span class="line">  - Regex:           &apos;^(&lt;|&quot;(gtest|isl|json)/)&apos;</span><br><span class="line">    Priority:        3</span><br><span class="line">  - Regex:           &apos;.*&apos;</span><br><span class="line">    Priority:        1</span><br><span class="line">IndentCaseLabels: false</span><br><span class="line">IndentWidth:     2</span><br><span class="line">IndentWrappedFunctionNames: false</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: true</span><br><span class="line">MacroBlockBegin: &apos;&apos;</span><br><span class="line">MacroBlockEnd:   &apos;&apos;</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: All</span><br><span class="line">ObjCBlockIndentWidth: 2</span><br><span class="line">ObjCSpaceAfterProperty: false</span><br><span class="line">ObjCSpaceBeforeProtocolList: true</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 19</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 60</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">ReflowComments:  true</span><br><span class="line">SortIncludes:    true</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">SpacesBeforeTrailingComments: 1</span><br><span class="line">SpacesInAngles:  false</span><br><span class="line">SpacesInContainerLiterals: true</span><br><span class="line">SpacesInCStyleCastParentheses: false</span><br><span class="line">SpacesInParentheses: false</span><br><span class="line">SpacesInSquareBrackets: false</span><br><span class="line">Standard:        Cpp11</span><br><span class="line">TabWidth:        8</span><br><span class="line">UseTab:          Never</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 使用boost::program_options解析命令行选项</title>
    <url>/boost-options-description.html</url>
    <content><![CDATA[<p>Boost.ProgramOptions是Boost中一个专门用来解析命令行的库，其目标是轻松的解析命令行选项。</p>
<a id="more"></a>



<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/program_options.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_notifier</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"On notifier: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> po = boost::program_options;</span><br><span class="line">    po::<span class="function">options_description <span class="title">desc</span><span class="params">(<span class="string">"Options"</span>)</span></span>;</span><br><span class="line">    desc.add_options()</span><br><span class="line">        (<span class="string">"enable_something,e"</span>, <span class="string">"Enable Something"</span>)</span><br><span class="line">        (<span class="string">"test_string,s"</span>, po::value&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(), <span class="string">"Test String"</span>)</span><br><span class="line">        (<span class="string">"test_int,p"</span>, po::value&lt;<span class="keyword">int</span>&gt;(), <span class="string">"Test Int"</span>)</span><br><span class="line">        (<span class="string">"test_default_value,d"</span>,po::value&lt;<span class="keyword">int</span>&gt;()-&gt;default_value(<span class="number">1</span>), <span class="string">"Test Default Value"</span>)</span><br><span class="line">        (<span class="string">"test_notifier"</span>, value&lt;<span class="keyword">int</span>&gt;()-&gt;notifier(on_notifier), <span class="string">"Test Notifier"</span>);</span><br><span class="line">    po::variables_map vm;</span><br><span class="line">  	po::store(po::parse_command_line(argc, argv, desc), vm);</span><br><span class="line">  	po::notify(vm);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// no options set</span></span><br><span class="line">    <span class="comment">// print all options</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span> || !vm.count(<span class="string">"sensor_id"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; desc &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> enable_something = vm.count(<span class="string">"enable_something"</span>);</span><br><span class="line">    <span class="keyword">int</span> value = vm[<span class="string">"test_default_value"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_string"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ss = vm[<span class="string">"test_string"</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_string was set to: "</span>  &lt;&lt; ss &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_int"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dd = vm[<span class="string">"test_int"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_int was set to: "</span>  &lt;&lt; dd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CMake里引入依赖"><a href="#CMake里引入依赖" class="headerlink" title="CMake里引入依赖"></a>CMake里引入依赖</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost COMPONENTS program_options REQUIRED)</span><br><span class="line"><span class="keyword">target_include_directories</span>(myTarget PRIVATE <span class="variable">$&#123;Boost_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myTarget <span class="variable">$&#123;Boost_LIBRARIES&#125;</span> )</span><br></pre></td></tr></table></figure>

<p><a href="https://www.boost.org/doc/libs/1_63_0/doc/html/program_options/tutorial.html#idp523371328" target="_blank" rel="noopener">官方Tutorial参考</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake设置编译选项</title>
    <url>/cmake-set-flag.html</url>
    <content><![CDATA[<h4 id="CMake中设置编译选项"><a href="#CMake中设置编译选项" class="headerlink" title="CMake中设置编译选项"></a>CMake中设置编译选项</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_VISUALIZATIONS <span class="string">"Build visualization, default OFF"</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"BUILD_VISUALIZATIONS is $&#123;BUILD_VISUALIZATIONS&#125;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以跟build type关联</span></span><br><span class="line"><span class="comment"># if(CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES DEBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_VISUALIZATIONS)</span><br><span class="line"><span class="keyword">add_definitions</span>(-DBUILD_VISUALIZATIONS)</span><br><span class="line"><span class="comment"># target_compile_definitions($&#123;project_name&#125; PRIVATE BUILD_VISUALIZATIONS)</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="代码中作为宏"><a href="#代码中作为宏" class="headerlink" title="代码中作为宏"></a>代码中作为宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BUILD_VISUALIZATIONS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(<span class="keyword">const</span> <span class="keyword">cloud_ptr_t</span>&amp; cloud_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"visualizations on"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// visualize cloud</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(Args...)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pass visualizations"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="编译时传入参数"><a href="#编译时传入参数" class="headerlink" title="编译时传入参数"></a>编译时传入参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--cmake-args -DBUILD_VISUALIZATIONS=ON</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：条件变量std::condition_variable的使用</title>
    <url>/condition-variable.html</url>
    <content><![CDATA[<p><code>std::condition_variable</code> 是 C++11 多线程编程中的条件变量。</p>
<p>一般用法: 线程 A <strong>等待</strong>某个条件并挂起，直到线程 B 设置了这个条件，并<strong>通知</strong>条件变量，然后线程 A 被唤醒。</p>
<a id="more"></a>



<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>仅支持默认构造函数，拷贝、赋值和移动(move)均是被禁用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br></pre></td></tr></table></figure>

<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><h5 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h5><p>阻塞当前线程直到被其他线程通知唤醒。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h5><p>只有当 <code>pred</code> 条件为 <code>false</code> 时才会阻塞当前线程，并且在收到其他线程的通知后只有当 <code>pred</code> 为 <code>true</code> 时才会被解除阻塞。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span> (<span class="title">unique_lock</span>&lt;mutex&gt;&amp; <span class="title">lck</span>, <span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pred())</span><br><span class="line">&#123;</span><br><span class="line">	wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>通知线程可以使用 <code>notify_one()</code> 通知一个线程，或一次使用 <code>notify_all()</code> 通知所有线程。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; ready;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" start.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">  cv.wait(lck, [] &#123; <span class="keyword">return</span> ready.load(); &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" done.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ready</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set_ready(): "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  ready.store(<span class="literal">true</span>);</span><br><span class="line">  cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ready.store(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> t_1 = <span class="built_in">std</span>::thread(wait, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> t_2 = <span class="built_in">std</span>::thread(wait, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"join...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  t_1.join();</span><br><span class="line">  t_2.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"all done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread: 139827702187776 id: 1 start.</span><br><span class="line">thread: 139827693795072 id: 2 start.</span><br><span class="line">set_ready(): 1</span><br><span class="line">thread: 139827702187776 id: 1 done.</span><br><span class="line">set_ready(): 1</span><br><span class="line">join....</span><br><span class="line">thread: 139827693795072 id: 2 done.</span><br><span class="line">all done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian添加最小化按钮</title>
    <url>/debian_minimize_botton.html</url>
    <content><![CDATA[<p>安装tweak和dconf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br><span class="line">sudo apt install dconf-editor </span><br><span class="line">dconf-editor</span><br></pre></td></tr></table></figure><p>进入路径: <code>org/gnome/desktop/wm/preferences/button-layout</code></p><img src="/debian_minimize_botton/test.png" title="debian_minimize_botton"><p>取消选项 Use default value</p><a id="more"></a>








<p>在 Custom value 填入 <code>appmemu:close,minimize,maximize,close</code></p>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 解压缩rar包</title>
    <url>/extract_from_rar.html</url>
    <content><![CDATA[<h4 id="下载rar软件安装包"><a href="#下载rar软件安装包" class="headerlink" title="下载rar软件安装包"></a>下载rar软件安装包</h4><ol>
<li><p>直接从 <a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">rarlab</a> 下载安装包</p>
</li>
<li><p>通过命令行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.rarlab.com/rar/rarlinux-x64-6.0.1.tar.gz  <span class="comment"># 64位</span></span><br><span class="line">wget https://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz	   <span class="comment"># 32位</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf rarlinux-x64-6.0.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> rar</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h4 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar x xxx.rar  <span class="comment"># Extract files with full path</span></span><br><span class="line">rar e xxx.rar  <span class="comment"># Extract files without archived paths</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>



<h4 id="将xxx目录压缩为xxx-rar"><a href="#将xxx目录压缩为xxx-rar" class="headerlink" title="将xxx目录压缩为xxx.rar"></a>将xxx目录压缩为xxx.rar</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar a xxx.rar xxx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uncompress</tag>
        <tag>rar</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV Mat像素的遍历方法</title>
    <url>/mat-traverse.html</url>
    <content><![CDATA[<h2 id="OpenCV像素遍历常用的几种方法"><a href="#OpenCV像素遍历常用的几种方法" class="headerlink" title="OpenCV像素遍历常用的几种方法"></a>OpenCV像素遍历常用的几种方法</h2><p>以从 organized 的点云提取 RGB 信息为例</p><h3 id="动态地址at"><a href="#动态地址at" class="headerlink" title="动态地址at"></a>动态地址at</h3><p>基于Mat对象的随机像素访问 API 实现，通过行列索引方式遍历每个像素值。这种方法速度较慢，不太适合用于像素遍历。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract_1</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt;::Ptr cloud, cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_height = cloud-&gt;height;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_width = cloud-&gt;width;</span><br><span class="line"></span><br><span class="line">  image = cv::Mat(cv::Size(cloud_width, cloud_height), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> row = <span class="number">0</span>; row &lt; cloud_height; row++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> col = <span class="number">0</span>; col &lt; cloud_width; col++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> index = row * cloud_width + col;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pt = cloud-&gt;points[index];</span><br><span class="line"></span><br><span class="line">      image.at&lt;cv::Vec3b&gt;(row, col)[<span class="number">0</span>] = pt.b;</span><br><span class="line">      image.at&lt;cv::Vec3b&gt;(row, col)[<span class="number">1</span>] = pt.g;</span><br><span class="line">      image.at&lt;cv::Vec3b&gt;(row, col)[<span class="number">2</span>] = pt.r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h3 id="行指针"><a href="#行指针" class="headerlink" title="行指针"></a>行指针</h3><p>基于Mat对象的行随机访问指针方式实现对每个像素的遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract_2</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt;::Ptr cloud, cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_height = cloud-&gt;height;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_width = cloud-&gt;width;</span><br><span class="line"></span><br><span class="line">  image = cv::Mat(cv::Size(cloud_width, cloud_height), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> row = <span class="number">0</span>; row &lt; cloud_height; row++)</span><br><span class="line">  &#123;</span><br><span class="line">    cv::Vec3b *ptr = image.ptr&lt;cv::Vec3b&gt;(row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> col = <span class="number">0</span>; col &lt; cloud_width; col++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> index = row * cloud_width + col;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pt = cloud-&gt;points[index];</span><br><span class="line"></span><br><span class="line">      cv::Vec3b &amp;pixel = ptr[col];</span><br><span class="line">      pixel[<span class="number">0</span>] = pt.b;</span><br><span class="line">      pixel[<span class="number">1</span>] = pt.g;</span><br><span class="line">      pixel[<span class="number">2</span>] = pt.r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uchar-行指针"><a href="#uchar-行指针" class="headerlink" title="uchar 行指针"></a>uchar 行指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract_3</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt;::Ptr cloud, cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_height = cloud-&gt;height;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_width = cloud-&gt;width;</span><br><span class="line"></span><br><span class="line">  image = cv::Mat(cv::Size(cloud_width, cloud_height), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> row = <span class="number">0</span>; row &lt; cloud_height; row++)</span><br><span class="line">  &#123;</span><br><span class="line">    uchar *uc_pixel = image.ptr(row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> col = <span class="number">0</span>; col &lt; cloud_width; col++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> index = row * cloud_width + col;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pt = cloud-&gt;points[index];</span><br><span class="line"></span><br><span class="line">      uc_pixel[<span class="number">0</span>] = pt.b;</span><br><span class="line">      uc_pixel[<span class="number">1</span>] = pt.g;</span><br><span class="line">      uc_pixel[<span class="number">2</span>] = pt.r;</span><br><span class="line">      uc_pixel += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将图像完全展开"><a href="#将图像完全展开" class="headerlink" title="将图像完全展开"></a>将图像完全展开</h3><p>一般图像行与行之间往往存储是不连续的，但是有些图像可以是连续的，Mat提供了一个检测图像是否连续的函数<code>isContinuous()</code>。当图像连通时，我们就可以把图像完全展开，看成是一行进行处理。</p>
<h3 id="速度比较"><a href="#速度比较" class="headerlink" title="速度比较"></a>速度比较</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> cloud_path = <span class="string">"test.pcd"</span></span><br><span class="line">  pcl::PointCloud&lt;PointT&gt;::Ptr cloud(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;);</span><br><span class="line">  pcl_utils::load_pcd(cloud_path, *cloud);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *cloud &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  cv::Mat img_1;</span><br><span class="line">  extract_1(cloud, img_1);</span><br><span class="line">  <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  <span class="keyword">auto</span> elapsed_seconds = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(end - start);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line"></span><br><span class="line">  start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  cv::Mat img_2;</span><br><span class="line">  extract_2(cloud, img_2);</span><br><span class="line">  end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  elapsed_seconds = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(end - start);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line"></span><br><span class="line">  start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  cv::Mat img_3;</span><br><span class="line">  extract_3(cloud, img_3);</span><br><span class="line">  end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  elapsed_seconds = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(end - start);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Load pcd file with 1228800 data points.</span><br><span class="line">header: seq: 0 stamp: 0 frame_id: </span><br><span class="line"></span><br><span class="line">points[]: 1228800</span><br><span class="line">width: 1280</span><br><span class="line">height: 960</span><br><span class="line">is_dense: 0</span><br><span class="line">sensor origin (xyz): [0, 0, 0] / orientation (xyzw): [0, 0, 0, 1]</span><br><span class="line"></span><br><span class="line">1 elapsed time: 0.0199077s</span><br><span class="line">2 elapsed time: 0.012727s</span><br><span class="line">3 elapsed time: 0.00880297s</span><br><span class="line">4 elapsed time: 0.00900436s</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>使用clang和black 对C++、Python代码自动格式化</title>
    <url>/format_code.html</url>
    <content><![CDATA[<h4 id="使用clang对C-进行格式化"><a href="#使用clang对C-进行格式化" class="headerlink" title="使用clang对C++进行格式化"></a>使用<code>clang</code>对C++进行格式化</h4><ul>
<li><p>安装<code>clang-format-7</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y clang-format-7</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写脚本 <code>clang_format.bash</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -regextype egrep -regex <span class="string">".*\.(c|cc|h|hh)$"</span> -not -path <span class="string">'*/install/*'</span> \</span><br><span class="line">  -not -path <span class="string">'*/build/*'</span> -not -path <span class="string">'*/log/*'</span> -not -path <span class="string">'*/deps/*'</span>| xargs clang-format-7 -i</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./clang_format.bash</span><br></pre></td></tr></table></figure>





</li>
</ul><a id="more"></a>
<h4 id="使用black对python进行格式化"><a href="#使用black对python进行格式化" class="headerlink" title="使用black对python进行格式化"></a>使用<code>black</code>对python进行格式化</h4><ul>
<li><p>安装<code>black</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install black==20.8b1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">black .</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>clang</tag>
        <tag>linux</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 使用SCP远程拷贝文件</title>
    <url>/scp.html</url>
    <content><![CDATA[<p> 使用scp(secure copy)命令可以实现本地服务器和远程服务器之间的文件传输复制</p>
<a id="more"></a>



<h4 id="从本地复制到远程"><a href="#从本地复制到远程" class="headerlink" title="从本地复制到远程"></a>从本地复制到远程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder/test.txt</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder/test.txt</span><br></pre></td></tr></table></figure>

<h4 id="从远程复制到本地"><a href="#从远程复制到本地" class="headerlink" title="从远程复制到本地"></a>从远程复制到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp bot@10.0.9.211:/home/bot/test_folder text.txt</span><br><span class="line">scp bot@10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br></pre></td></tr></table></figure>

<h4 id="传输整个目录"><a href="#传输整个目录" class="headerlink" title="传输整个目录"></a>传输整个目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /test_folder bot@10.0.9.211:/home/bot/test_folder</span><br></pre></td></tr></table></figure>

<h4 id="其他参数用法"><a href="#其他参数用法" class="headerlink" title="其他参数用法"></a>其他参数用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 搭建FTP服务器</title>
    <url>/ftp_server.html</url>
    <content><![CDATA[<h4 id="安装ftp和vsftpd"><a href="#安装ftp和vsftpd" class="headerlink" title="安装ftp和vsftpd"></a>安装ftp和vsftpd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ftp</span><br><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用vsftpd软件，主要包括如下几个命令：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动ftp</span></span><br><span class="line">service vsftpd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止ftp</span></span><br><span class="line">service vsftpd stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启ftp</span></span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure><a id="more"></a>



<h4 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h4><p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># vi /etc/vsftpd/vsftpd.conf</span></span><br></pre></td></tr></table></figure>

<p>按照需求修改为以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"></span><br><span class="line"># local root</span><br><span class="line">local_root=/home/bot/dev/moma_app/scanner_images</span><br></pre></td></tr></table></figure>

<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>

<h4 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录本地ftp</span></span><br><span class="line">ftp 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名和密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前路径是否设置的local root</span></span><br><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ push_back和emplace_back的区别</title>
    <url>/push_back-emplace_back.html</url>
    <content><![CDATA[<p><code>push_back()</code>向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中(如果是拷贝的话，事后会自行销毁先前创建的这个元素)。</p><p>而 <code>emplace_back()</code> 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p>事实上，大多数情况下二者没有区别，少数情况下 <code>emplace_back()</code> 效率更高，直接看下代码：</p><a id="more"></a>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestClass(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;b) : a_(a), b_(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  TestClass(<span class="keyword">const</span> TestClass &amp;other) : a_(other.a_), b_(other.b_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TestClass(TestClass &amp;&amp;other) : a_(other.a_), b_(<span class="built_in">std</span>::move(other.b_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TestClass&gt; vec;</span><br><span class="line">  vec.reserve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">TestClass <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="string">"1"</span>)</span></span>;</span><br><span class="line">  <span class="function">TestClass <span class="title">t2</span><span class="params">(<span class="number">2</span>, <span class="string">"2"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n-----------------0---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(t1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(t1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------1---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t1));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t2));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------2----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------3----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------4----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">default constructor</span><br><span class="line"></span><br><span class="line">-----------------0---------------</span><br><span class="line">copy constructor</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line">-----------------1---------------</span><br><span class="line">move constructor</span><br><span class="line"></span><br><span class="line">move constructor</span><br><span class="line">----------------2----------------</span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line">----------------3----------------</span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">----------------4----------------</span><br></pre></td></tr></table></figure>

<p>从结果来看，只有直接调用构造有区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>push_back()</code> 会调用默认构造和移动构造，而 <code>emplace_back()</code> 只调用一次默认构造， 效率更高。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 强制类型转换</title>
    <url>/type-cast.html</url>
    <content><![CDATA[<p>相比于C风格的强制类型转换，C++新增了关键字 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code> ，用于强制类型转换。</p><p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。</p><h2 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. static_cast</h2><p>用于非多态类型转换 (静态转换)，任何标准转换都可以用它，但是不能用于两个不相关的类型转换。</p><a id="more"></a>


<p>常用于：</p>
<ul>
<li>基本数据类型之间的转换，如<code>int -&gt; char</code>，这种转换的安全也要开发人员来保证</li>
<li>任何类型的表达式转换成 <code>void</code> 类型</li>
<li>不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">65</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int a: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char a: "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> c = a / b;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: 65</span><br><span class="line">char a: A</span><br><span class="line">c: 6</span><br><span class="line">d: 6.5</span><br></pre></td></tr></table></figure>

<p><strong>没有运行时类型检查来保证转换的安全性</strong></p>
<ul>
<li>上行转型 (子类对象指针–&gt;父类对象指针/引用)： 安全</li>
<li>下行转型(父类对象指针–&gt;子类对象指针/引用)：没有动态类型检查，所以是不安全的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeinfo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">class_name</span><span class="params">()</span> final </span>&#123; <span class="keyword">return</span> <span class="keyword">typeid</span>(*<span class="keyword">this</span>).name(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt_1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt_2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt_3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1A 32686</span><br><span class="line">1B 3</span><br><span class="line">1C 5</span><br></pre></td></tr></table></figure>

<h2 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. dynamic_cast</h2><p>动态转换，常用于将一个父类对象的指针转换为子类对象的指针或引用。其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。</p>
<ul>
<li><p>使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过</p>
</li>
<li><p>在进行下行转换时，会进行类型检查 (这个信息存储在类的虚函数表)，比 <code>static_cast</code> 安全</p>
</li>
<li><p>转换后必须是类的指针、引用或 <code>void*</code></p>
</li>
<li><p>对于指针，转换失败会返回<code>nullptr</code>；对于引用，转换失败会 (在运行时) 抛出异常</p>
</li>
</ul>
<p><strong>返回指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b3)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b3 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b1 null</span><br><span class="line">1B 3</span><br><span class="line">b3 null</span><br></pre></td></tr></table></figure>

<p><strong>返回引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  C c;</span><br><span class="line">  A &amp;a1 = b;</span><br><span class="line">  A &amp;a2 = c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a2);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B</span><br><span class="line">terminate called after throwing an instance of <span class="string">'std::bad_cast'</span></span><br><span class="line">  what():  std::bad_cast</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>

<h2 id="std-dynamic-pointer-cast"><a href="#std-dynamic-pointer-cast" class="headerlink" title="std::dynamic_pointer_cast"></a>std::dynamic_pointer_cast</h2><p>使用 <code>std::dynamic_pointer_cast</code> 可以返回 <code>std::shared_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt1 = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt2 = <span class="built_in">std</span>::make_shared&lt;C&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B 3</span><br><span class="line">b2 null</span><br></pre></td></tr></table></figure>

<h2 id="3-reinterpret-cast"><a href="#3-reinterpret-cast" class="headerlink" title="3. reinterpret_cast"></a>3. reinterpret_cast</h2><p>主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。</p>
<p><code>reinterpret_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li><p><code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。</p>
</li>
<li><p>在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<h2 id="4-const-cast"><a href="#4-const-cast" class="headerlink" title="4. const_cast"></a>4. const_cast</h2><p><code>const</code> 限定符通常被用来限定变量，用于表示该变量的值不能被修改。而 <code>const_cast</code> 则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</p>
<p><code>const_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li>该运算符用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性，<code>type_id</code>和 <code>expression</code> 的类型是一样的</li>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::vector的内存分配机制</title>
    <url>/std-vector_memory.html</url>
    <content><![CDATA[<blockquote>
<p><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector;</code></p>
</blockquote><h3 id="std-vector-简介"><a href="#std-vector-简介" class="headerlink" title="std::vector 简介"></a>std::vector 简介</h3><p><code>std::vector</code> 是C++标准库里封装好的<strong>动态大小数组</strong>的顺序容器，能够存放各种类型的对象。</p><p>与数组 <code>array</code> 一样， <code>vector</code> 的<strong>内存空间的地址是连续的</strong>。这意味着可以通过下标索引的方式获取到对应的元素，所以访问其元素的效率非常高，从其末端添加或删除元素的效率也相对较高。而对于涉及在非结束位置插入或删除元素的操作，它们的性能比其他操作差，效率较低。</p><a id="more"></a>


<p>但与<code>array</code>不同的是，它们的大小可以动态变化，它们的存储由容器自动处理。在插入新元素时，若当前容量不能够容纳新的元素，将自动重新申请一块更大的内存空间，将原有数据拷贝到新的内存空间，且释放原来的空间。这一过程非常耗时，为了避免频繁的内容分配， <code>vector</code> 不会在每次添加元素时都重新分配空间，而是分配一些额外的存储空间来容纳可能的增长。因此， <code>vector</code> 的实际容量 (<strong>capacity</strong>) 永远大于等于它容纳的元素大小 (<strong>size</strong>)。</p>
<h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><h4 id="1-自动增长策略"><a href="#1-自动增长策略" class="headerlink" title="1. 自动增长策略"></a>1. 自动增长策略</h4><p>假设元素是连续存储的，并且容器的大小是可变的，如果此时向 vector 中添加新的元素，容器不可能简单地将它添加到内存的其它位置，因为元素必须是连续存储的。</p>
<p>容器必须分配新的空间，来保存已有元素和新的元素，将已有的元素从旧位置移动到新空间。然后添加新元素，释放旧的存储空间。如果每添加一个元素，容器就执行一次内存分配和释放，性能会变得超级慢。</p>
<p>为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配的策略。当不得不获取新的空间的时候，<code>vector</code> 的实现，通常会分配比需求空间更大的内存空间。这种分配策略，比每次添加新元素后都重新分配容器内存空间的策略要高效的多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 0  size: 0</span><br><span class="line">2 vec capacity: 1  size: 1</span><br><span class="line">3 vec capacity: 2  size: 2</span><br><span class="line">4 vec capacity: 4  size: 3</span><br><span class="line">5 vec capacity: 4  size: 4</span><br><span class="line">6 vec capacity: 8  size: 5</span><br></pre></td></tr></table></figure>

<p>可以看出，每当 <code>size</code> 和 <code>capacity</code> 相等时，也就是无法容纳新的元素时，<code>vector</code> 自动申请了新的 (成倍增长的) 容量。</p>
<h4 id="2-手动分配内存-reserve-和-resize"><a href="#2-手动分配内存-reserve-和-resize" class="headerlink" title="2. 手动分配内存: reserve 和 resize"></a>2. 手动分配内存: reserve 和 resize</h4><p><code>std::vector</code> 有自动分配内存的机制，但我们也可以通过<code>reserve()</code> 和 <code>resize()</code> 来手动分配内存，使其效率更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ele</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ele: "</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : vec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 0</span><br><span class="line">2 vec capacity: 4  size: 4</span><br><span class="line">3 vec capacity: 4  size: 4</span><br><span class="line">ele: 1 2 3 4 </span><br><span class="line">4 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 4 0 </span><br><span class="line">5 vec capacity: 8  size: 3</span><br><span class="line">ele: 1 2 3 </span><br><span class="line">6 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 0 0</span><br></pre></td></tr></table></figure>

<p>可以看出：</p>
<ol>
<li><code>reserve()</code> 只增加不减少数组的 <code>capacity</code>，不对 <code>size()</code> 造成任何改变</li>
<li><code>resize()</code> 只增加不减少数组的 <code>capacity</code>，但可以增加和减少 <code>size</code>。减少时会直接移除多余的元素，增加时会填入默认值 (0)。</li>
</ol>
<h4 id="3-手动回收内存"><a href="#3-手动回收内存" class="headerlink" title="3. 手动回收内存"></a>3. 手动回收内存</h4><h5 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h5><p><code>erase()</code> 可以从 <code>vector</code> 中移除单个或一段元素 [begin, end)，实际上是以后面的元素移动并覆盖前面的位置，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin() + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin(), vec.begin() + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 5  size: 5</span><br><span class="line">2 vec capacity: 5  size: 4</span><br><span class="line">ele: 1 3 4 5 </span><br><span class="line">3 vec capacity: 5  size: 2</span><br><span class="line">ele: 4 5</span><br></pre></td></tr></table></figure>

<h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><p><code>clear()</code> 可以移除 <code>vector</code>所有元素，使容器<code>size</code> 为0，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 4</span><br><span class="line">2 vec capacity: 4  size: 0</span><br></pre></td></tr></table></figure>

<h5 id="shrink-to-fit-c-11"><a href="#shrink-to-fit-c-11" class="headerlink" title="shrink_to_fit (c++11)"></a>shrink_to_fit (c++11)</h5><p><code>shrink_to_fit()</code> 可以请求将内存减少到等于当前元素实际所使用的大小，也就是使 <code>capacity = size</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 10  size: 10</span><br><span class="line">2 vec capacity: 10  size: 1</span><br><span class="line">3 vec capacity: 1  size: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>pcl类型转换</title>
    <url>/pcl_type_transform.html</url>
    <content><![CDATA[<h4 id="PCL相关类型-对象与指针互换"><a href="#PCL相关类型-对象与指针互换" class="headerlink" title="PCL相关类型 对象与指针互换"></a>PCL相关类型 对象与指针互换</h4><ol>
<li>pcl::PointIndices -&gt; pcl::PointIndices::Ptr</li>
</ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::<span class="function">Ptr <span class="title">inliers_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices(inliers))</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a>


<ol start="2">
<li>pcl::PointIndices::Ptr -&gt; pcl::PointIndices</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::Ptr inliers_ptr;</span><br><span class="line">inliers=*inliers_ptr;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>std::vector<int> -&gt; pcl::IndicesPtr</int></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_indices;</span><br><span class="line">pcl::IndicesPtr indices_ptr = boost::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(vec_indices);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>pcl::PointCloud<pointt> -&gt; pcl::PointCloud<pointt>::Ptr</pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud=*cloud_ptr;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>pcl::PointCloud<pointt>::Ptr -&gt; pcl::PointCloud<pointt></pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud_ptr=cloud.makeShared();</span><br></pre></td></tr></table></figure>

<h4 id="不同数据类型的点云转换"><a href="#不同数据类型的点云转换" class="headerlink" title="不同数据类型的点云转换"></a>不同数据类型的点云转换</h4><ol>
<li>pcl::PointCloud<a href="pcl::PointXYZRGB" target="_blank" rel="noopener">pcl::PointXYZRGB</a> -&gt; pcl::PointCloud<a href="pcl::PointXYZ" target="_blank" rel="noopener">pcl::PointXYZ</a>::Ptr</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="function">Ptr <span class="title">cloud_ori</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::copyPointCloud(*cloud_ori, *cloud);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pcl</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>pcl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：std::future的使用</title>
    <url>/std-future.html</url>
    <content><![CDATA[<p><code>std::future</code> 是C++11 的一个模板类，<strong>提供了一种用于访问异步操作结果的机制</strong>。可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。</p>
<p>设想这样的情况，你希望一个线程进行工作A，同时你在做一些其他的工作，你希望在某个特定的时间获取那个工作A的结果。在c++11，这个可以轻松被 <code>std::future</code> 实现。而由于它是一个模板类，可以返回任何类型的结果。</p>
<a id="more"></a>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;Result&gt; fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 进行别的工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取A的结果 </span></span><br><span class="line">Result result = fut.get();</span><br></pre></td></tr></table></figure>

<h4 id="用法说明"><a href="#用法说明" class="headerlink" title="用法说明"></a>用法说明</h4><p><code>std::future</code> 对象通常由某个 <code>Provider</code> 创建，你可以把 <code>Provider</code> 想象成一个异步任务的提供者，<code>Provider</code> 在某个线程中设置共享状态的值，与该共享状态相关联的 <code>std::future</code> 对象（通常在另外一个线程中）调用 <code>std::future::get()</code> 获取该值。如果共享状态的标志不为 <code>std::future_status::ready</code>，则调用 <code>get()</code> 会<strong>阻塞</strong>当前的调用者，直到 <code>Provider</code> 设置了共享状态的值，<code>get()</code> 返回异步任务的返回值或发生的异常。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>std::future</code> 的拷贝构造函数和普通赋值操作是被禁用的，只提供了默认的构造函数和 <code>move</code> 构造函数。默认构造函数构造的对象没有共享状态，因此它是无效的，但是可以通过移动赋值的方式将一个有效的<code>future</code> 值赋值给它。</p>
<p>一个有效的 <code>std::future</code> 对象通常由以下三种 <code>Provider</code> 创建，并和某个共享状态相关联。</p>
<ul>
<li><code>std::async()</code> 函数</li>
<li><code>std::promise::get_future()</code>，为 <code>promise</code> 类的成员函数</li>
<li><code>std::packaged_task::get_future()</code>，为 <code>packaged_task</code> 的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut;           <span class="comment">// 默认构造函数</span></span><br><span class="line">fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::async(test, <span class="number">1</span>));   <span class="comment">// move-赋值操作。</span></span><br></pre></td></tr></table></figure>

<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><p><code>bool valid()</code></p>
<p>检查共享状态的有效性，返回当前的 <code>future</code> 对象是否与共享状态关联。一旦调用了 <code>std::future::get()</code> 函数，再调用此函数将返回 <code>false</code> 。</p>
</li>
<li><p><code>void wait()</code></p>
<ul>
<li>等待共享状态就绪</li>
<li>如果共享状态尚未就绪(即未返回或发生异常)，则该函数将阻塞调用的线程直到就绪</li>
<li>当共享状态就绪后，则该函数将取消阻塞并void返回</li>
</ul>
</li>
<li><p><code>std::future_status wait_for(std::chrono::duration span)</code></p>
<ul>
<li>在指定的时间内等待共享状态就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到设置的时间</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="keyword">auto</span> future_status = fut.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; elapsed_seconds = end - start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waited for : "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result = fut.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waited for : 1.00856s</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>std::future_status wait_until(std::chrono::time_point point)</code></p>
<ul>
<li>在指定的时间点前等待共享状态准备就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到指定的时间点</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
</li>
<li><p><code>_Res get()</code></p>
<ul>
<li>当共享状态就绪时，返回存储在共享状态中的值(或抛出异常)</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪，相当于 <code>wait()</code> 再 <code>get()</code></li>
<li>当共享状态就绪后，则该函数将取消阻塞并返回释放其共享状态，这使得 <code>future</code> 对象不再有效，因此对于每一个 <code>future</code> 共享状态，<code>get()</code>函数最多应被调用一次</li>
<li><code>std::future&lt;void&gt;::get()</code> 不返回任何值，但仍等待共享状态就绪并释放它</li>
</ul>
</li>
<li><p><code>std::shared_future&lt;_Res&gt; share()</code></p>
<ul>
<li>返回一个 <code>std::shared_future</code> 对象，该对象获取 <code>future</code> 对象的共享状态。<code>future</code> 对象将不再有效。</li>
</ul>
</li>
</ul>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test()\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 sec later..\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting..\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -1-</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = <span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::future_status future_status = fut.wait_for(timeout);</span><br><span class="line">  <span class="keyword">if</span> (future_status != <span class="built_in">std</span>::future_status::ready)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 sec timeout!\n"</span>;</span><br><span class="line">    <span class="comment">// return -1;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -2-</span></span><br><span class="line">  fut.wait();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> result = fut.get();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nresult : "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="std-shared-future"><a href="#std-shared-future" class="headerlink" title="std::shared_future"></a><code>std::shared_future</code></h4><p><code>shared_future</code> 与 <code>future</code> 类似，但是允许多个线程等待同一个共享状态。 <code>shared_future</code> 既支持移动操作也支持拷贝操作，而且多个 <code>shared_future</code> 对象可以引用相同的共享状态，还允许多次检索共享状态下的值（多次调用 <code>get()</code> ）。</p>
<p><code>shared_future</code> 可以通过某个 <code>future</code> 对象隐式转换，或者通过 <code>std::future::share()</code> 显示转换，无论哪种转换，被转换的那个 <code>std::future</code> 对象都会变为 <code>not-valid</code>.</p>
<h4 id="std-launch"><a href="#std-launch" class="headerlink" title="std::launch"></a><strong>std::launch</strong></h4><p>该枚举类型主要是在调用<code>std::async</code> 设置异步任务的启动策略的。</p>
<p><code>std::async</code>的原型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async | <span class="built_in">std</span>::launch::deferred, f, args...)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>std::launch::async</code></p>
<p> 表示在调用<code>async</code>函数的时候就开始创建新线程。</p>
</li>
<li><p><code>std::launch::deferred</code></p>
<p>表示延迟调用，在调用 <code>future</code> 中的 <code>wait()</code> 或者 <code>get()</code> 函数时，才执行入口函数。（实际上，并没有创建新线程，只是在主线程中调用的入口函数）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async([]() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// deferred</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类构造函数</title>
    <url>/constructor.html</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，用于创建类的新对象和初始化自定义类成员。</p><ul>
<li>构造函数具有与类相同的名称，没有返回值，也不返回 <code>void</code>。</li>
<li>可以根据需要定义多个重载构造函数，以各种方式自定义初始化。</li>
<li>构造函数可用于为某些成员变量设置初始值。</li>
<li>通常构造函数具有<strong>公共</strong>可访问性，因此外部代码可以调用其创建类的对象，但也可以将构造函数声明为 <strong>protected</strong> 或 <strong>private</strong> 。</li>
<li>构造函数可以声明为 <strong><code>inline</code>, <code>explicit</code>, <code>friend</code> 或 <code>constexpr</code></strong></li>
<li>构造函数可以初始化已声明为 <code>const</code>, <code>volatile</code> 或者<code>const volatile</code> 的对象，该对象在构造完成后变为 <code>const</code></li>
<li>如果没有自己声明，编译器将为一个类声明 (编译器版本的) <strong>默认构造函数、复制构造函数、复制赋值操作符和析构函数</strong>。所有这些函数都是 <code>public</code> 且 <code>inline</code> 的。</li>
</ul><a id="more"></a>

<h2 id="成员初始化列表-Member-Initializer-List"><a href="#成员初始化列表-Member-Initializer-List" class="headerlink" title="成员初始化列表 Member Initializer List"></a>成员初始化列表 Member Initializer List</h2><p>构造函数可以有一个成员初始化列表，用于在执行构造函数体之前初始化类成员。</p>
<p>使用成员初始化列表比在构造函数体中赋值的效率更高，因为它直接初始化成员变量，而不需要调用赋值构造。</p>
<p><strong>对基类构造函数的调用应在初始化器列表中进行，以确保基类在执行派生构造函数之前已完全初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base(<span class="keyword">int</span> b) : b_(b) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived(<span class="keyword">int</span> b, <span class="keyword">int</span> d) : Base(b), d_(d) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以指定无物 (nothing) 作为初始化实参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived() : Base(), d_(<span class="number">0</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="默认构造-Default-Constructor"><a href="#默认构造-Default-Constructor" class="headerlink" title="默认构造 Default Constructor"></a>默认构造 Default Constructor</h2><p>默认构造函数通常没有参数，但它们可以具有具有默认值的参数。调用默认构造函数时，不应使用括号 (会被视为函数声明) :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 没有参数</span></span><br><span class="line">    Box() &#123; <span class="comment">/*perform any required default initialization steps*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有参数都具有默认值</span></span><br><span class="line">    Box (<span class="keyword">int</span> w = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> h = <span class="number">1</span>): m_width(w), m_height(h), m_length(l)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box1;</span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">box3</span><span class="params">()</span></span>; <span class="comment">// warning C4930: prototyped function not called (was a variable definition intended?)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认构造函数是 <strong>特殊成员函数</strong> 之一，如果未在类中声明任何构造函数，编译器将提供隐式默认的 <strong>inline</strong> 构造函数。如果依赖于隐式默认构造函数，需要确保初始化所有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Volume</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_width * m_height * m_length;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width&#123;<span class="number">0</span>&#125;; <span class="comment">// 初始化成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_height&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_length&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box box1; <span class="comment">// 调用编译器自动生成的默认构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"box1.Volume: "</span> &lt;&lt; box1.Volume() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Outputs 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果声明了任何非默认构造函数，则编译器不提供默认构造函数。没有默认构造函数时，该类的对象数组不能只使用方括号语法构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> width, <span class="keyword">int</span> length, <span class="keyword">int</span> height)</span><br><span class="line">        : m_width(width), m_length(length), m_height(height)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Box box; <span class="comment">// C2512: no appropriate default constructor available</span></span><br><span class="line">    Box boxes[<span class="number">3</span>]; <span class="comment">// C2512: no appropriate default constructor available</span></span><br><span class="line">    Box boxes1[<span class="number">3</span>]&#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制构造-Copy-Constructor"><a href="#复制构造-Copy-Constructor" class="headerlink" title="复制构造 Copy Constructor"></a>复制构造 Copy Constructor</h2><p>复制构造函数通过从相同类型的对象中复制成员值来初始化对象。</p>
<p>如果类成员都是标准简单类型，编译器自动生成的复制构造函数就足够了。但如果成员变量存在指针等复杂类型，那么需要自定义复制构造函数，用于分配新的内存等操作。</p>
<p><strong>Pass-by-value 将自动调用复制构造函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box(Box&amp; other); <span class="comment">// Avoid if possible--allows modification of other.</span></span><br><span class="line">Box(<span class="keyword">const</span> Box&amp; other);</span><br><span class="line">Box(<span class="keyword">volatile</span> Box&amp; other);</span><br><span class="line">Box(<span class="keyword">volatile</span> <span class="keyword">const</span> Box&amp; other);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Additional parameters OK if they have default values</span></span><br><span class="line">Box(Box&amp; other, <span class="keyword">int</span> i = <span class="number">42</span>, <span class="built_in">string</span> label = <span class="string">"Box"</span>);</span><br></pre></td></tr></table></figure>

<p>通过将复制构造函数定义为已删除，可以防止对象被复制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box (<span class="keyword">const</span> Box&amp; other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果定义了复制构造函数，还应定义复制赋值运算符 (=)。</strong></p>
<h2 id="赋值运算符-Copy-Assignment"><a href="#赋值运算符-Copy-Assignment" class="headerlink" title="赋值运算符 Copy Assignment"></a>赋值运算符 Copy Assignment</h2><p>赋值运算符 (<strong>=</strong>) 严格地说是二元运算符，但比较特殊：</p>
<ul>
<li>必须是<strong>非静态</strong> <strong>成员函数</strong>。 </li>
<li>不会被派生类继承。</li>
<li>如果不手动定义，编译器会自动生成一个默认的赋值运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Right side of copy assignment is the argument.</span></span><br><span class="line">    Box&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Box&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define copy assignment operator.</span></span><br><span class="line">Box&amp; Box::<span class="keyword">operator</span>=(<span class="keyword">const</span> Box&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_width = other.m_width;</span><br><span class="line">        m_length = other.m_length;</span><br><span class="line">        m_height = other.m_height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment operator returns left side of assignment.</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复制构造函数和赋值运算符的区别</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box box1;</span><br><span class="line">Box box2 = box1; <span class="comment">// Copy constructor is called</span></span><br><span class="line"><span class="function">Box <span class="title">box3</span><span class="params">(box1)</span></span>; <span class="comment">// Copy constructor call.</span></span><br></pre></td></tr></table></figure>

<h2 id="移动构造-Move-Constructor"><a href="#移动构造-Move-Constructor" class="headerlink" title="移动构造 Move Constructor"></a>移动构造 Move Constructor</h2><p>移动构造函数是一种特殊成员函数，它无需复制原始数据即可将现有对象数据的所有权移动到新对象。它采用左值引用作为第一个参数，任何其他参数都必须具有默认值。移动构造函数可以在传递大型对象时显著提高程序的效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box(Box&amp;&amp; other);</span><br></pre></td></tr></table></figure>

<p>如果对象由即将销毁且不再需要其资源的另一个相同类型的对象初始化，编译器会选择使用移动构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestClass(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;b) : a_(a), b_(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  TestClass(<span class="keyword">const</span> TestClass &amp;other) : a_(other.a_), b_(other.b_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TestClass(TestClass &amp;&amp;other) : a_(other.a_), b_(<span class="built_in">std</span>::move(other.b_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TestClass&gt; vec;</span><br><span class="line">  vec.reserve(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(TestClass(<span class="number">1</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">move</span><br></pre></td></tr></table></figure>

<p>如果<strong>没有定义移动构造函数</strong>，则输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果没有定义移动构造函数，且没有用户声明的复制构造函数、复制赋值运算符、移动赋值运算符或析构函数，编译器将生成隐式构造函数。</p>
</li>
<li><p>如果未定义显式或隐式移动构造函数，则使用移动构造函数的操作将被改为使用复制构造函数。</p>
</li>
<li><p>如果定义了移动构造函数或移动赋值运算符，则隐式声明的复制构造函数将被定义为 <code>deleted</code>。</p>
</li>
<li><p>如果作为类类型的任何成员缺少析构函数或编译器无法确定要用于移动操作哪个构造函数，则隐式声明移动构造函数定义为 <code>deleted</code>。</p>
</li>
</ul>
<h2 id="委托构造函数-Delegating-Constructor"><a href="#委托构造函数-Delegating-Constructor" class="headerlink" title="委托构造函数 Delegating Constructor"></a>委托构造函数 Delegating Constructor</h2><p>委托构造函数调用同一类中的不同构造函数来执行某些初始化工作。</p>
<p>可以在一个构造函数中编写主逻辑，并从其他构造函数调用它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> i) :  Box(i, i, i) &#123;&#125;  <span class="comment">// 委托构造</span></span><br><span class="line">    Box(<span class="keyword">int</span> width, <span class="keyword">int</span> length, <span class="keyword">int</span> height)</span><br><span class="line">        : m_width(width), m_length(length), m_height(height) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="explicit-显式构造"><a href="#explicit-显式构造" class="headerlink" title="explicit 显式构造"></a>explicit 显式构造</h2><p>将构造函数声明为 <code>explicit</code> 可以防止隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    explicit Test(int i) : num(i) &#123; cout &lt;&lt; "Test(int)" &lt;&lt; endl; &#125;</span><br><span class="line">    explicit Test(char c) : letter(c) &#123; cout &lt;&lt; "Test(char)" &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> letter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="string">'2'</span>)</span></span>;</span><br><span class="line">    Test t = <span class="number">3</span>; <span class="comment">// 编译器错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显式默认和删除"><a href="#显式默认和删除" class="headerlink" title="显式默认和删除"></a>显式默认和删除</h2><ul>
<li>可以显式默认复制构造函数、默认构造函数、move构造函数、复制赋值操作符、move赋值操作符和析构函数。</li>
<li>可以显式地删除所有特殊成员函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">    Noncopyable(<span class="keyword">const</span> Noncopyable&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Noncopyable&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable(Noncopyable&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable&amp; <span class="keyword">operator</span>=(Noncopyable&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleOnly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DoubleOnly(<span class="keyword">float</span>) = <span class="keyword">delete</span>;</span><br><span class="line">  DoubleOnly(<span class="keyword">double</span> d) : d_(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些规则：</p>
<ul>
<li>如果显式声明了任何构造函数，则不会自动生成默认构造函数。</li>
<li>如果显式声明了虚拟析构函数，则不会自动生成默认析构函数。</li>
<li>如果显式声明了移动构造函数或移动赋值运算符，则：<ul>
<li>不自动生成复制构造函数。</li>
<li>不自动生成复制赋值运算符。</li>
</ul>
</li>
<li>如果显式声明了复制构造函数、复制赋值运算符、移动构造函数、移动赋值运算符或析构函数，则：<ul>
<li>不自动生成移动构造函数。</li>
<li>不自动生成移动赋值运算符。</li>
</ul>
</li>
</ul>
<h2 id="构造顺序"><a href="#构造顺序" class="headerlink" title="构造顺序"></a>构造顺序</h2><p>构造函数按此顺序执行工作：</p>
<ul>
<li><p>按声明顺序调用基类和成员构造函数。</p>
</li>
<li><p>如果类继承自一个虚拟基类，将对象的虚拟基指针初始化。</p>
</li>
<li><p>如果类具有或继承了虚函数，将对象的虚函数指针初始化。虚函数指针指向类中的虚函数表，确保虚函数正确地调用绑定代码。</p>
</li>
<li><p>执行构造函数体中的代码。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained1 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained2() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained2 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained3() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained3 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseContainer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BaseContainer() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"BaseContainer ctor\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Contained1 c1;</span><br><span class="line">  Contained2 c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedContainer</span> :</span> <span class="keyword">public</span> BaseContainer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DerivedContainer() : BaseContainer() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DerivedContainer ctor\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Contained3 c3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DerivedContainer dc;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Contained1 ctor</span><br><span class="line">Contained2 ctor</span><br><span class="line">BaseContainer ctor</span><br><span class="line">Contained3 ctor</span><br><span class="line">DerivedContainer ctor</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Udacity自动驾驶 笔记</title>
    <url>/udacity-self-driving-apollo.html</url>
    <content><![CDATA[<h1 id="无人驾驶第一课：从-Apollo-起步"><a href="#无人驾驶第一课：从-Apollo-起步" class="headerlink" title="无人驾驶第一课：从 Apollo 起步"></a>无人驾驶第一课：从 Apollo 起步</h1><p><a href="https://www.udacity.com/course/self-driving-car-fundamentals-featuring-apollo--ud0419" target="_blank" rel="noopener">udacity课程链接</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><ul>
<li>线控驾驶车辆：可通过电子控制的基础车辆，而不仅仅用过实体方向盘、油门踏板、刹车踏板来控制。</li>
<li>控制器区域网络 (CAN) : 车辆的内部通信网络。计算机系统通过CAN卡连接汽车内部网络，发送加速、制动和转向信号。</li>
<li>全球定位系统 (GPS) : 通过绕地卫星接收信号，帮助我们确定所处位置信息。</li>
<li>惯性测量装置 (IMU, Inertial Measurement Unit) : 通过跟踪位置、速度、加速度和其他因素，测量车辆的运动和位置。</li>
<li>激光雷达 (LiDAR) : 由一组脉冲激光器组成，可360度扫描车辆周围，这些激光束的反射形成了可用于了解环境的点云。可用于检测障碍物和检测其他车辆的速度，分辨率低，但成本低且不受天气和照明条件影响。</li>
<li>摄像头捕获图像数据，可使用计算机视觉来了解周围环境，例如检测交通灯。</li>
</ul><a id="more"></a>

<p><img src="./udacity-self-driving-apollo/introduction-devices.png" alt="image-intro-devices"></p>
<h4 id="开源软件栈"><a href="#开源软件栈" class="headerlink" title="开源软件栈"></a>开源软件栈</h4><ul>
<li>实时操作系统 (RTOS) : 可确保在给定时间内完成特定任务，Ubuntu + Apollo</li>
<li>运行时框架 : ROS的定制版，改进了共享内存的功能和性能、去中心化和数据兼容性 (protobuf)</li>
<li>应用程序模块 : 包括MAP引擎、定位、感知、规划、控制、端到端驾驶以及人机接口 (HMI) </li>
</ul>
<h4 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h4><ul>
<li>Apollo 云服务包含高精度地图、仿真环境、数据平台、信息安全、空中软件升级 (OTA)、智能语音系统 (DuerOS) 等</li>
</ul>
<h2 id="高精度地图-HD-Map"><a href="#高精度地图-HD-Map" class="headerlink" title="高精度地图 HD Map"></a>高精度地图 HD Map</h2><ul>
<li><p>高精度地图包含大量的驾驶辅助信息。最重要的信息是道路网的精确三维表征，例如交叉路口布局和路标位置。还包含很多语义信息，比如交通管制信息 (交通灯、道路限速等)，和城市的三维模型 (道路、建筑物、隧道等)</p>
</li>
<li><p>能到达<strong>厘米级</strong>的精度</p>
</li>
<li><p>高精地图用于定位（寻找地标）：</p>
<p>从各类传感器收集的数据查找地标，与地图上的已知地标进行比较。这一过程需要经过预处理 (消除不准确或质量差的数据)、坐标变换 (将来自不同视角的数据转换为统一的坐标系)、数据融合 (将来自各种车辆和传感器的数据合并)。</p>
</li>
<li><p>高精地图用于感知：</p>
<ul>
<li>传感器受到距离和环境的限制</li>
<li>传感器的视野容易被障碍物遮挡，高精地图可以补充信息</li>
<li>可以帮助传感器缩小检测范围 (ROI)，提高检测精度和速度</li>
</ul>
</li>
<li><p>高精地图用于规划：</p>
<ul>
<li>可帮助车辆找到合适的行车空间</li>
<li>帮助规划器确定不同的路线选择，以便选择最佳方案</li>
<li>帮助预测器预测道路上其他车辆在将来的位置</li>
<li>预知道路限速和障碍物等，使车辆提前减速或变道</li>
</ul>
</li>
<li><p>使用OpenDRIVE格式</p>
</li>
<li><p>高精度地图的构建由5个过程组成：数据采集、数据处理、对象检测、手动验证、地图发布</p>
<p><img src="./udacity-self-driving-apollo/hdmap-process.png" alt="image-hdmap-process"></p>
</li>
</ul>
<h2 id="定位-Localization"><a href="#定位-Localization" class="headerlink" title="定位 Localization"></a>定位 Localization</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>车辆将其传感器识别的地标与高精度地图上存在的地标进行比对</li>
<li>在这过程中，需要在它自身坐标系和地图坐标系之间转换数据</li>
<li>目标：在地图上以10cm的精度确定车辆的精确位置</li>
<li>常见的定位方法：GNSS RTK、惯性导航、LiDAR定位、视觉定位</li>
</ul>
<h4 id="GNSS-RTK"><a href="#GNSS-RTK" class="headerlink" title="GNSS RTK"></a>GNSS RTK</h4><ul>
<li><p>GNSS : 全球导航卫星系统</p>
</li>
<li><p>GPS是使用最广泛的GNSS系统</p>
</li>
<li><p>GPS共3个部分</p>
<ul>
<li>卫星：配备了高精确度的原子钟。在任何特定时间，大约有30颗GPS卫星在外层空间运行</li>
<li>世界各地的控制站：用于监视和控制卫星，使系统保持运行且验证GPS广播信号的精确度</li>
<li>GPS接收器：存在于手机等设备中，正常情况下每次应该至少检测到4颗GPS卫星。 通过测量信号的飞行时间来计算距离卫星的距离。3颗卫星可以定位，再加1颗可以确定海拔。</li>
</ul>
</li>
<li><p>实时运动定位 (RTK) : 在地面上建立几个基站，每个基站都知道自己精确的 ”地面实况“ 位置，每个基站也通过GPS来测量自己的位置，两者之间的偏差则为GPS测量结果中的误差。将这个误差发送到GPS接收器，以供其调整自身的位置计算。</p>
</li>
<li><p>使用 RTK 可以使 GPS <strong>精度达到10cm</strong>，但高障碍物或天气等仍然可能阻挡GPS信号。</p>
</li>
<li><p><strong>GPS更新频率为10Hz</strong>，也就是每0.1s更新一次。在0.1s的间隔内，速度为60km/h的车大概会行驶1.67m，差不多是一个车位的距离，这个更新频率对于自动驾驶来说太低了。</p>
</li>
</ul>
<h4 id="惯性导航"><a href="#惯性导航" class="headerlink" title="惯性导航"></a>惯性导航</h4><ul>
<li><p>使用加速度、初始速度和初始位置来计算汽车在任何时间点的车速和位置</p>
</li>
<li><p>惯性测量单元 (IMU) 是测量物体三轴姿态角以及加速度的装置</p>
</li>
<li><p>IMU的主要组件</p>
<ul>
<li>三轴加速度计：精确测量加速度</li>
<li>三轴陀螺仪：三个外部平衡环一直在旋转，但spin axis始终固定在世界坐标系中，通过测量旋转轴和三个外部平衡环的相对位置，可以计算出车辆在坐标系中的位置</li>
</ul>
</li>
<li><p>IMU的优点是<strong>更新频率高</strong>，可达1kHz，可提供接近实时的位置信息。缺点是误差会随时间的推进而增加，<strong>只能用于很短时间范围内的定位</strong>。</p>
</li>
<li><p>可以与GPS配合一起使用，称为组合惯导。一方面，IMU弥补了GPS更新频率较低的缺陷；另一方面，GPS纠正了IMU的运动误差。但山间/城市峡谷/地下隧道中行驶，有可能长时间获取不到GPS的更新，也会导致整个定位面临失败风险。</p>
</li>
</ul>
<h4 id="LiDAR定位"><a href="#LiDAR定位" class="headerlink" title="LiDAR定位"></a>LiDAR定位</h4><ul>
<li>利用<strong>激光雷达</strong>，我们可以通过<strong>点云匹配</strong>来对汽车进行定位。该方法将来自激光雷达传感器的检测数据与预先存在的高精度地图连续匹配，从而获知汽车在高精地图上的全球位置和行驶方向。</li>
<li>点云定位方法<ul>
<li>迭代最近点 (ICP) : 对于一个点云中的每个点，我们需要找到另一点云中最接近的匹配点，最终收集到许多匹配点对，然后计算出这些点对的平均距离误差，通过点云的平移和旋转来最大限度地降低这一平均距离误差，从而完成传感器扫描和地图之间的匹配。最后将通过传感器扫描到的车辆位置转换为全球地图上的位置，并计算出在地图上的精确位置。</li>
<li>滤波算法：消除冗余信息，并在地图上找到最可能的车辆位置。</li>
<li>Apollo使用了直方图滤波算法，也叫做误差平方和算法 (SSD)。将通过传感器扫描的点云滑过地图上的每个位置，在每个点上计算扫描的点与高精度地图上的对应点之间的误差或距离，对其平方求和。平方和越小，则扫描结果与地图之间的匹配越准确。</li>
<li>卡尔曼滤波：用于根据我们在过去的状态和新的传感器测量结果来预测当前的状态。具体来说是使用了预测更新周期，首先根据之前的状态以及对移动距离和方向的估计，来估计或预测新的位置，然后使用传感器测量新的位置并加以纠正，利用概率规则将不完美的传感器测量结果和现有的位置预测结合起来，永远遵循这个预测更新周期。</li>
</ul>
</li>
<li>LiDAR定位的优点在于<strong>稳健性</strong>，缺点在于<strong>难以构建高精地图并使其保持更新</strong> (包含很多瞬态元素)。</li>
</ul>
<h4 id="视觉定位"><a href="#视觉定位" class="headerlink" title="视觉定位"></a>视觉定位</h4><ul>
<li>通过观察结果、概率和地图来确定车辆最可能的位置</li>
<li>因为使用粒子或点来估计最可能的位置，所以称为<strong>粒子滤波</strong>。</li>
<li>比如对车道线进行拍摄，然后将道路摄像头图像与地图进行比较，通过匹配度来计算车辆在不同位置的概率，以连续的概率计算来确定车辆在道路中的位置。</li>
<li>视觉定位的优点在于图像数据很容易获得，而<strong>缺点在于缺乏三维信息和对三维地图的依赖</strong>。</li>
</ul>
<h4 id="Apollo定位"><a href="#Apollo定位" class="headerlink" title="Apollo定位"></a>Apollo定位</h4><ul>
<li>Apollo使用基于GPS、IMU和激光雷达的<strong>多传感器融合定位系统</strong>。</li>
<li>GNSS定位输出位置和速度信息，LiDAR定位输出位置和行进方向信息，融合框架通过卡尔曼滤波将这些输出结合在一起。卡尔曼滤波建立在两步预测测量周期之上，惯性导航解决方案用于卡尔曼滤波的预测步骤，GNSS和LiDAR定位用于卡尔曼滤波的测量结果更新步骤。</li>
</ul>
<p><img src="/Users/shiuchung/repos/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%AC%94%E8%AE%B0/localization-kalman-filter.png" alt="image-20220410121939839"></p>
<h2 id="感知-Perception"><a href="#感知-Perception" class="headerlink" title="感知 Perception"></a>感知 Perception</h2><h4 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h4><ul>
<li><p>无人驾驶车有4个感知世界的核心任务</p>
<ul>
<li>检测：找出物体在环境中的位置</li>
<li>分类：明确对象是什么</li>
<li>追踪：随时间的推移观察移动物体</li>
<li>分割：将图像中的每个像素与语义类别进行匹配</li>
</ul>
</li>
<li><p>计算机视觉pipeline例子</p>
<ul>
<li>输入图像</li>
<li>预处理 (对图像进行标准化 / 旋转 / 色彩空间转换等预处理，帮助模型更快地学习和处理图像)</li>
<li>特征提取</li>
<li>分类模型</li>
</ul>
<p><img src="./udacity-self-driving-apollo/classification_pipeline.png" alt="image-classification-pipeline"></p>
</li>
</ul>
<h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul>
<li>对于计算机而言，图片只是一个二维网格 / 矩阵，矩阵中的每个单元格都包含一个值。</li>
<li>数字图像由像素组成，其中包含非常小的颜色或强度单位，图像中的每个像素都是一个数值，这些值构成了整个图像矩阵。</li>
<li>图像处理实际上就是在对这些值进行处理，大多数的颜色和形状转换都是通过对图像进行数学运算以及逐一像素进行更改来完成的。</li>
</ul>
<h4 id="LiDAR图像-点云"><a href="#LiDAR图像-点云" class="headerlink" title="LiDAR图像 (点云)"></a>LiDAR图像 (点云)</h4><ul>
<li>激光雷达传感器可以创建环境的点云表征。</li>
<li>激光雷达发射<strong>激光脉冲</strong>，通过测量该激光反射回传感器的时间，来计算环境中反射该光线的物体的距离。</li>
<li>它收集的数据形成<strong>点云</strong>，点云中的每个点代表反射回传感器的激光束。</li>
<li>点云能表现物体的形状和表面纹理。</li>
<li>通过对点云进行聚类和分析，可以获得足够的信息对对象进行检测、跟踪或分类。</li>
</ul>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><ul>
<li>机器学习是使用特殊算法来训练计算机从数据中学习的计算机科学领域。一般来说，学习结果会存放在一种被称为 “模型” 的数据结构中。</li>
<li>模型是一种可用于理解和预测世界的数据结构。</li>
<li>监督学习 : 使用数据和相关的真值标记来训练模型</li>
<li>非监督学习 : 不提供真值标记，而是通过分析输入的数据，计算机凭借自行学习找到区别</li>
<li>半监督学习 : 使用少量的标记数据和大量的未标记数据来训练模型</li>
<li>强化学习 : 允许模型通过尝试许多不同的方法来解决问题，然后衡量哪种方法最为成功</li>
</ul>
<h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><ul>
<li><p>人工神经网络由大量的人工神经元组成。人工神经元负责传递和处理信息，这些神经元也可以被训练。</p>
</li>
<li><p>神经网络会对图像提取多种特征 (可能是人类无法描述或无法理解的特征)，计算机将调整这些特征的权重，以完成最终任务。</p>
</li>
<li><p>训练由三步循环组成</p>
<ul>
<li>前馈 : 首先随机分配初始权重 (也就是每个神经元的值)，然后给神经网络提供图像，使其产生输出值</li>
<li>误差测定 : 计算真值标记与前馈过程所产生的输出值之间的偏差</li>
<li>反向传播 : 通过神经网络反向发送误差，每个人工神经元都对其值进行微调，从而生成更准确的网络</li>
</ul>
</li>
</ul>
<h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><ul>
<li><p>卷积神经网络 (CNN) 接受多维输入，包括二维和三维的大多数传感器数据。</p>
</li>
<li><p>相对于标准神经网络，CNN可以维持输入像素之间的空间关系。</p>
</li>
<li><p>CNN 通过将滤波连续划过图像来收集信息，每次收集信息时，只对整个图像的一小部分区域进行分析，这被称为 “卷积”。</p>
<p><img src="./udacity-self-driving-apollo/percetion-convolution.png" alt="image-20220409222316478"></p>
</li>
<li><p>当我们用滤波对整个输入图像进行 “卷积” 时，我们将该信息与下一个卷积层相关联。例如，第一个卷积层可能会识别出图像中的基本边缘和颜色信息；然后在第一层的基础上连接一个新的滤波，使用图像的边缘和颜色信息来检测更复杂的结构，比如轮子/车窗等；而另一个卷积可以使用这些轮子/车门来识别整个车辆；最终CNN可以使用这一高阶信息对车辆进行分类。</p>
<p><img src="./udacity-self-driving-apollo/percetion-cnn.png" alt="image-20220409223621043"></p>
</li>
</ul>
<h4 id="检测和分类"><a href="#检测和分类" class="headerlink" title="检测和分类"></a>检测和分类</h4><ul>
<li><p>障碍物</p>
<ul>
<li>静态障碍物：墙壁、树木、杆子、建筑物等</li>
<li>动态障碍物：行人、车辆等</li>
</ul>
</li>
<li><p>计算机需要知道障碍物的位置，然后对其进行分类。</p>
</li>
<li><p>可以使用单一CNN体系结构对对象进行检测和分类，通过在单个网络体系结构的末端附加几个不同的“头”，可以执行不同的任务。</p>
<p><img src="./udacity-self-driving-apollo/percetion-detection-and-classification.png" alt="image-20220410000129529"></p>
</li>
<li><p>一种经典的体系结构为RCNN，以及其变体 Fast RCNN 和 Faster RCNN。</p>
</li>
<li><p>YOLO 和 SSD 是具有类似形式的不同体系结构。</p>
</li>
</ul>
<h4 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h4><ul>
<li>追踪的好处<ul>
<li>解决遮挡问题（预测之前检测到但在当前帧中被遮挡的物体的位置）</li>
<li>保留物体的身份信息</li>
</ul>
</li>
<li>追踪的第一步为<strong>确认身份</strong>：通过查找特征相似度最高的对象，可以将在前帧中检测到的所有对象与在当前帧中检测到的对象进行匹配；物体的位置和速度信息也有助于快速匹配对象。</li>
<li>确认身份后，使用对象的位置结合<strong>预测算法</strong>，可以预估在下一个时间段中物体的速度和位置，这个预测结果又可以帮助识别下一帧中的相应对象。</li>
</ul>
<h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><ul>
<li><p>语义分割实际上是对图像的每个像素进行分类。</p>
</li>
<li><p>分割可帮助我们尽可能详细地了解环境和确定车辆可驾驶区域。</p>
</li>
<li><p>图像分割依赖于一种特殊类型的CNN——全卷积网络 (FCN)。</p>
</li>
<li><p>FCN 使用卷积层来替代传统CNN体系结构末端的连接层，则整个网络中的每一层都为卷积层。</p>
</li>
<li><p>FCN 可在原始输入图像之上提供逐像素的输出（通过对中间输出进行上采样的方式，使输出尺寸与原始输入图像的尺寸相等）。</p>
<p><img src="./udacity-self-driving-apollo/percetion-fcn.png" alt="image-20220409231158846"></p>
</li>
<li><p>网络的前半部分对输入图像的特征进行了提取和编码，通常称为编码器；后半部分对提取到的特征进行解码，并将其应用于输出，通常称为解码器。</p>
</li>
</ul>
<h4 id="Apollo-感知"><a href="#Apollo-感知" class="headerlink" title="Apollo 感知"></a>Apollo 感知</h4><ul>
<li>Apollo感知模块可以检测障碍物、交通信号灯和车道。</li>
<li>对于<strong>三维物体检测</strong>，Apollo在高精度地图上使用ROI来重点关注相关对象，将ROI应用于图像和点云数据，以缩小搜索范围并加快感知。然后将过滤后的数据输入到检测网络，产生用于构建围绕对象的三维边界框输出。最后使用 Detection to Track Association 算法来跨时间识别单个对象。</li>
<li>Detection to Track Association : 先保留在每个时间步要追踪的对象列表，然后在下一个时间步中找到每个对象的最佳匹配。</li>
<li>对于<strong>交通灯分类</strong>，Apollo先使用高精地图来确定前方是否存在交通信号灯；如果前方存在交通灯，高精地图会返回灯的位置，这可以缩小摄像头的搜索范围；在摄像头捕获到交通信号灯的图像后，Apollo使用检测网络对图像中的灯进行定位；将裁剪后的交通灯图像提供给分类网络，以确定交通灯的颜色。</li>
<li>对于<strong>车道线和动态物体的检测</strong>，Apollo使用YOLO网络完成。在经过YOLO网络检测后，在线检测模块会并入来自其他传感器的数据，对车道线预测或是动态物体的检测结果进行调整，最终传递到规划和控制模块。</li>
</ul>
<h4 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h4><p><img src="./udacity-self-driving-apollo/percetion-sensors.png" alt="image-20220409233936508"></p>
<ul>
<li><strong>摄像头</strong>的优势在于图像分类，主要用于交通信号灯分类和车道检测。</li>
<li><strong>激光雷达</strong> (激光探测与测量) 的优势在于障碍物检测，且不受环境光影响，可在夜间使用，分辨率较高。缺点是不能直接测量对象的速度，必须使用两次或多次扫描之间的位置差来确定；受天气和传感器清洁程度影响很大，需要保持清洁；块头比其他传感器更大，难以安装，目前一般安装在车顶。</li>
<li><strong>雷达</strong> (无线电探测与测量) 的优势在于探测范围和应对恶劣天气。雷达通过多普勒效应来直接测量速度，可以把速度作为独立的测量参数，从而提升了融合算法的收敛速度。因为雷达波在坚硬表面会回弹，它可以直接测量对象距离，无需在视线范围内也可以，可以发现可能会被阻挡的建筑物和对象。缺点在于分辨率较低 (尤其是在垂直方向)，对金属敏感，来自静态物体的反射可能产生问题。</li>
<li>Apollo使用激光雷达和雷达来检测障碍物，用于融合输出的主要算法为卡尔曼滤波。<ul>
<li>第一步为预测</li>
<li>第二步为更新测量结果<ul>
<li>同步更新：同时更新来自不同传感器的测量结果</li>
<li>异步更新：逐个更新所收到的传感器测量结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="预测-Predition"><a href="#预测-Predition" class="headerlink" title="预测 Predition"></a>预测 Predition</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>预测模块对感知模块检测到的障碍物进行行为研究和预测。预测模块接收障碍物的数据和基本的感知信息 (包括位置、朝向、速度、加速度) ，根据这些信息生成障碍物的预测轨迹。</p>
<ul>
<li><p>预测需要</p>
<ul>
<li>实时性</li>
<li>准确性</li>
<li>具备学习能力：车辆越多情况会越复杂，不可能开发出每种场景的静态模型；需要使用多源的数据对其进行训练，使算法能随着时间的推移而提升预测能力。</li>
</ul>
</li>
<li><p>两种预测方法</p>
<ul>
<li><strong>基于模型预测</strong>：为障碍物生成不同行为的模型，通过观察障碍物的行为来更新不同模型的概率，从而预测障碍物的行为路径。优点在于直观，且结合了物理知识、交通法规、人类行为等多方面的知识，比如可以结合物理知识 (摩擦力等) 来准确地确定车辆何时会在潮湿的路面上滑行。</li>
<li><strong>数据驱动预测</strong>：使用机器学习算法，通过观察结果来训练模型；一旦模型训练好，就可以在现实世界中使用此模型去做出预测。优点在于，使用的数据越多，预测效果就会越好</li>
</ul>
</li>
<li><p>除了障碍物的位置、朝向、速度、加速度外，预测模块还会考虑车道段内障碍物的位置 (比如从物体到车道线段边界的纵向和横向距离)，以及之前时间间隔里障碍物的状态信息，以提高预测的准确度。</p>
</li>
</ul>
<h4 id="车道序列"><a href="#车道序列" class="headerlink" title="车道序列"></a>车道序列</h4><ul>
<li><p>用车道序列描述障碍物行为：将道路分成多个部分，每个部分都覆盖了一个易于描述车辆运动的区域，将车辆的行为划分为一组有限的模式组合，并将这些模式组合描述成车道序列。</p>
</li>
<li><p>使用车道序列框架的目标是为道路上的物体生成轨迹。</p>
</li>
<li><p>预测车道线段之间的过渡：假设在车道段0中检测到一辆车，我们会预测在接下来的几个时间段中它将如何行驶。很明显有两个选择：0 -&gt; 4 -&gt; 5 或者 0 -&gt; 1 -&gt; 3 -&gt; 7。通过这样的分析，可以将预测问题简化为选择问题，那么只需要选择车辆最有可能采取的车道顺序 (通过计算每个车道序列的概率)。</p>
<img src="./udacity-self-driving-apollo/predition_choose_road.png" alt="image-predition-road-sequence" style="zoom:60%;">
</li>
<li><p>计算概率：我们需要一个模型，将车辆状态和车道段作为输入，而输出车辆可能采用每个车道序列的概率。</p>
</li>
<li><p>使用观测数据对模型进行经验性训练：将真实的车辆行为提供给模型，不仅包括车道段和对象的状态，还包括对象最终选择哪条车道序列。每个记录将由观察对象跟随的车道段序列和对象的相关状态组成；在每个时间点，对象占用一个车道段并具有特定的状态；整个记录由一系列车道段和对象的相关状态组成。</p>
</li>
</ul>
<h4 id="递归神经网络（RNN）"><a href="#递归神经网络（RNN）" class="headerlink" title="递归神经网络（RNN）"></a>递归神经网络（RNN）</h4><ul>
<li><p>RNN 是一种利用时间序列数据特征的预测方法</p>
</li>
<li><p>神经网络是可训练的多层模型，从输入提取高级特征，并利用这些特征来计算得到输出。</p>
</li>
<li><p>神经网络有很多种结构。一个基本的神经网络首先得到输入，然后将数据通过隐藏层，经过处理，最后得到输出。这种结构也被称作<strong>多层感知网络</strong> (MLP)。</p>
</li>
<li><p>每一个输入数据由原始的数据和对应的标签组成。</p>
</li>
<li><p>神经网络通过<strong>反向传播 (back propagation)</strong> 学习数据。首先，神经网络得到输入并产生输出，然后比较输出和真值 (ground truth) 之间的误差，误差通过反向传回整个网络，中间的隐藏层根据观察到的误差调整权重，以提高神经网络的准确率。</p>
<p><img src="./udacity-self-driving-apollo/predition-back_propagation.png" alt="image-predition-bp"></p>
</li>
<li><p>我们可以建立这样的多重结构的递归神经网络，称为<strong>MLP单元</strong>，从数据序列中提取出高级特征。每个MLP单元将序列的一个元素作为输入，并预测序列的下一个元素作为输出；为了对元素之间的顺序关系建立模型，在每个单元之间建立一个额外的连接；于是<strong>每个单元根据原始输入和前一个单元的输出进行预测</strong>。这就是RNN的基本结构。</p>
<p><img src="./udacity-self-driving-apollo/predition-rnn.png" alt="image-predition-rnn"></p>
</li>
</ul>
<h4 id="Apollo-RNN预测"><a href="#Apollo-RNN预测" class="headerlink" title="Apollo RNN预测"></a>Apollo RNN预测</h4><ul>
<li><p>Apollo 使用RNN建立一个模型来预测车辆的目标车道：为车道序列提供一个RNN模型，为相关对象状态提供另一个RNN模型，连接这两个RNN模型的输出并将它们输出到另一个神经网络，来估计每个车道序列的概率，具有最高概率的车道序列就是目标车辆的预测车道序列。</p>
</li>
<li><p>训练数据：每条记录都包含一个车道序列、相关的对象状态和一个标签，标签指示了对象是否遵循此特定车道序列。</p>
</li>
<li><p>通过网络输出和标签真值的误差，使用反向传播来训练网络。</p>
<img src="./udacity-self-driving-apollo/predition-apollo-network.png" alt="image-predition-apollo" style="zoom: 60%;">



</li>
</ul>
<h4 id="生成轨迹"><a href="#生成轨迹" class="headerlink" title="生成轨迹"></a>生成轨迹</h4><ul>
<li><p>生成轨迹是预测的最后一步。</p>
</li>
<li><p>一旦我们预测到物体的车道序列，我们就可以预测物体的轨迹。</p>
</li>
<li><p>在任意两点A和B之间，物体的行进轨迹有无限的可能。我们可以先通过设置约束条件，来去除大部分候选轨迹。</p>
<ul>
<li>假设车辆将与目标车道的中心对齐</li>
<li>去除车辆无法实际执行的轨迹</li>
<li>考虑车辆当前的速度和加速度</li>
</ul>
<p><img src="./udacity-self-driving-apollo/predition-trajetory1.png" alt="image-prediction-trajectory1"></p>
<p><img src="./udacity-self-driving-apollo/prediction-trajectory2.png" alt="image-prediction-trajectory2"></p>
</li>
<li><p>实际上并不会列出所有可能的轨迹再逐一去除它们，而是在数学理论上来应用这一想法。首先获得车辆在两点的位置和方向，这两点的姿态代表着运动模型的起始状态和最终状态，使用这两个条件来拟合一个<strong>多项式模型</strong>。大多数情况下，这种多项式足以进行轨迹预测。</p>
</li>
</ul>
<h2 id="规划-Planning-未完成"><a href="#规划-Planning-未完成" class="headerlink" title="规划 Planning [未完成]"></a>规划 Planning [未完成]</h2><h2 id="控制-Control-未完成"><a href="#控制-Control-未完成" class="headerlink" title="控制 Control [未完成]"></a>控制 Control [未完成]</h2><h4 id="PID-控制"><a href="#PID-控制" class="headerlink" title="PID 控制"></a>PID 控制</h4><ul>
<li>PID控制：<ul>
<li>P：比例控制</li>
<li>D：微分，致力于使运动处于稳定状态</li>
<li>I：积分</li>
</ul>
</li>
<li>优点：简单，只需要知道车辆与目标轨迹有多大的偏离</li>
<li>缺点：是一种线性算法，需要应用不同的PID控制器来控制转向和加速，很难将横向和纵向控制结合起来；依赖于实时误差测量，受到测量延迟限制时可能会失效。</li>
</ul>
<h4 id="线性二次调节器"><a href="#线性二次调节器" class="headerlink" title="线性二次调节器"></a>线性二次调节器</h4><ul>
<li>线性二次调节器 (LQR) : 是基于模型的控制权，通过使用车辆的状态来使误差最小化，可用于横向控制。</li>
<li>横向控制包含4个组件<ul>
<li>横向误差</li>
<li>横向误差的变化率</li>
<li>朝向误差</li>
<li>朝向误差的变化率</li>
</ul>
</li>
<li>车辆的3个控制输入 : 转向、加速、制动</li>
<li>状态空间方程 : </li>
</ul>
<p>$$<br>\dot{x} = Ax + Bu<br>$$</p>
<p><img src="./udacity-self-driving-apollo/control-LQR.png" alt="image-20220410144646315"></p>
<p><img src="./udacity-self-driving-apollo/control-LQR2.png" alt="image-20220410145023779"></p>
<h4 id="模型预测控制"><a href="#模型预测控制" class="headerlink" title="模型预测控制"></a>模型预测控制</h4><ul>
<li><p>模型预测控制 (MPC) 是一种更复杂的控制器，非常依赖于数学优化</p>
</li>
<li><p>基本上可以归结为3个步骤：</p>
<ul>
<li>建立车辆模型</li>
<li>使用优化引擎计算有限时间范围内的控制输入</li>
<li>执行第一组控制输入</li>
</ul>
</li>
<li><p>只执行第一组控制输入，可以在每个时间步里不断地重新评估控制输入的最有序列，使实际产生的车辆状态与模型更接近。</p>
</li>
<li><p>第一步中建立的车辆模型近似于汽车的物理特性，它可以估计将一组控制输入应用到车辆时具体会发生什么。</p>
</li>
<li><p>优化引擎的工作原理是通过搜索密集数学空间来寻求最佳解决方案，车辆模型的约束条件 (比如车辆能实际实现的转向范围等) 可以缩小搜索范围。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>self-driving</category>
      </categories>
      <tags>
        <tag>self-driving</tag>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
</search>
