<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode刷题记录</title>
    <url>/algorithm-notes.html</url>
    <content><![CDATA[<ul>
<li><p><a href="./algorithm-notes/content/时间复杂度.html">时间复杂度</a></p>
</li>
<li><p><a href="./algorithm-notes/content/二分法.html">二分算法</a></p>
</li>
<li><p><a href="./algorithm-notes/content/双指针算法.html">双指针算法</a></p>
</li>
<li><p><a href="./algorithm-notes/content/排序.html">排序算法</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 使用boost::program_options解析命令行选项</title>
    <url>/boost-options-description.html</url>
    <content><![CDATA[<p>Boost.ProgramOptions是Boost中一个专门用来解析命令行的库，其目标是轻松的解析命令行选项。</p>
<a id="more"></a>



<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/program_options.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_notifier</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"On notifier: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> po = boost::program_options;</span><br><span class="line">    po::<span class="function">options_description <span class="title">desc</span><span class="params">(<span class="string">"Options"</span>)</span></span>;</span><br><span class="line">    desc.add_options()</span><br><span class="line">        (<span class="string">"enable_something,e"</span>, <span class="string">"Enable Something"</span>)</span><br><span class="line">        (<span class="string">"test_string,s"</span>, po::value&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(), <span class="string">"Test String"</span>)</span><br><span class="line">        (<span class="string">"test_int,p"</span>, po::value&lt;<span class="keyword">int</span>&gt;(), <span class="string">"Test Int"</span>)</span><br><span class="line">        (<span class="string">"test_default_value,d"</span>,po::value&lt;<span class="keyword">int</span>&gt;()-&gt;default_value(<span class="number">1</span>), <span class="string">"Test Default Value"</span>)</span><br><span class="line">        (<span class="string">"test_notifier"</span>, value&lt;<span class="keyword">int</span>&gt;()-&gt;notifier(on_notifier), <span class="string">"Test Notifier"</span>);</span><br><span class="line">    po::variables_map vm;</span><br><span class="line">  	po::store(po::parse_command_line(argc, argv, desc), vm);</span><br><span class="line">  	po::notify(vm);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// no options set</span></span><br><span class="line">    <span class="comment">// print all options</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span> || !vm.count(<span class="string">"sensor_id"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; desc &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> enable_something = vm.count(<span class="string">"enable_something"</span>);</span><br><span class="line">    <span class="keyword">int</span> value = vm[<span class="string">"test_default_value"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_string"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ss = vm[<span class="string">"test_string"</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_string was set to: "</span>  &lt;&lt; ss &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_int"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dd = vm[<span class="string">"test_int"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_int was set to: "</span>  &lt;&lt; dd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CMake里引入依赖"><a href="#CMake里引入依赖" class="headerlink" title="CMake里引入依赖"></a>CMake里引入依赖</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost COMPONENTS program_options REQUIRED)</span><br><span class="line"><span class="keyword">target_include_directories</span>(myTarget PRIVATE <span class="variable">$&#123;Boost_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myTarget <span class="variable">$&#123;Boost_LIBRARIES&#125;</span> )</span><br></pre></td></tr></table></figure>

<p><a href="https://www.boost.org/doc/libs/1_63_0/doc/html/program_options/tutorial.html#idp523371328" target="_blank" rel="noopener">官方Tutorial参考</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 使用clang格式化代码</title>
    <url>/clang_format.html</url>
    <content><![CDATA[<p>.clang-format文件存档</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Language:        Cpp</span><br><span class="line"># BasedOnStyle:  LLVM</span><br><span class="line">AccessModifierOffset: -2</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveAssignments: false</span><br><span class="line">AlignConsecutiveDeclarations: false</span><br><span class="line">AlignEscapedNewlinesLeft: false</span><br><span class="line">AlignOperands:   true</span><br><span class="line">AlignTrailingComments: true</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: true</span><br><span class="line">AllowShortBlocksOnASingleLine: false</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: false</span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: false</span><br><span class="line">AllowShortLoopsOnASingleLine: false</span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: false</span><br><span class="line">BinPackArguments: true</span><br><span class="line">BinPackParameters: false</span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterClass:      false</span><br><span class="line">  AfterControlStatement: false</span><br><span class="line">  AfterEnum:       false</span><br><span class="line">  AfterFunction:   true</span><br><span class="line">  AfterNamespace:  false</span><br><span class="line">  AfterObjCDeclaration: false</span><br><span class="line">  AfterStruct:     true</span><br><span class="line">  AfterUnion:      true</span><br><span class="line">  BeforeCatch:     true</span><br><span class="line">  BeforeElse:      true</span><br><span class="line">  IndentBraces:    false</span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeBraces: Allman</span><br><span class="line">BreakBeforeTernaryOperators: false</span><br><span class="line">BreakConstructorInitializersBeforeComma: false</span><br><span class="line">ColumnLimit:     0</span><br><span class="line">CommentPragmas:  &apos;^ IWYU pragma:&apos;</span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: false</span><br><span class="line">ConstructorInitializerIndentWidth: 4</span><br><span class="line">ContinuationIndentWidth: 4</span><br><span class="line">Cpp11BracedListStyle: true</span><br><span class="line">DerivePointerAlignment: false</span><br><span class="line">DisableFormat:   false</span><br><span class="line">ExperimentalAutoDetectBinPacking: false</span><br><span class="line">ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]</span><br><span class="line">IncludeCategories: </span><br><span class="line">  - Regex:           &apos;^&quot;(llvm|llvm-c|clang|clang-c)/&apos;</span><br><span class="line">    Priority:        2</span><br><span class="line">  - Regex:           &apos;^(&lt;|&quot;(gtest|isl|json)/)&apos;</span><br><span class="line">    Priority:        3</span><br><span class="line">  - Regex:           &apos;.*&apos;</span><br><span class="line">    Priority:        1</span><br><span class="line">IndentCaseLabels: false</span><br><span class="line">IndentWidth:     2</span><br><span class="line">IndentWrappedFunctionNames: false</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: true</span><br><span class="line">MacroBlockBegin: &apos;&apos;</span><br><span class="line">MacroBlockEnd:   &apos;&apos;</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: All</span><br><span class="line">ObjCBlockIndentWidth: 2</span><br><span class="line">ObjCSpaceAfterProperty: false</span><br><span class="line">ObjCSpaceBeforeProtocolList: true</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 19</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 60</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">ReflowComments:  true</span><br><span class="line">SortIncludes:    true</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">SpacesBeforeTrailingComments: 1</span><br><span class="line">SpacesInAngles:  false</span><br><span class="line">SpacesInContainerLiterals: true</span><br><span class="line">SpacesInCStyleCastParentheses: false</span><br><span class="line">SpacesInParentheses: false</span><br><span class="line">SpacesInSquareBrackets: false</span><br><span class="line">Standard:        Cpp11</span><br><span class="line">TabWidth:        8</span><br><span class="line">UseTab:          Never</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake设置编译选项</title>
    <url>/cmake-set-flag.html</url>
    <content><![CDATA[<h4 id="CMake中设置编译选项"><a href="#CMake中设置编译选项" class="headerlink" title="CMake中设置编译选项"></a>CMake中设置编译选项</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_VISUALIZATIONS <span class="string">"Build visualization, default OFF"</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"BUILD_VISUALIZATIONS is $&#123;BUILD_VISUALIZATIONS&#125;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以跟build type关联</span></span><br><span class="line"><span class="comment"># if(CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES DEBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_VISUALIZATIONS)</span><br><span class="line"><span class="keyword">add_definitions</span>(-DBUILD_VISUALIZATIONS)</span><br><span class="line"><span class="comment"># target_compile_definitions($&#123;project_name&#125; PRIVATE BUILD_VISUALIZATIONS)</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="代码中作为宏"><a href="#代码中作为宏" class="headerlink" title="代码中作为宏"></a>代码中作为宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BUILD_VISUALIZATIONS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(<span class="keyword">const</span> <span class="keyword">cloud_ptr_t</span>&amp; cloud_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"visualizations on"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// visualize cloud</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(Args...)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pass visualizations"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="编译时传入参数"><a href="#编译时传入参数" class="headerlink" title="编译时传入参数"></a>编译时传入参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--cmake-args -DBUILD_VISUALIZATIONS=ON</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：条件变量std::condition_variable的使用</title>
    <url>/condition-variable.html</url>
    <content><![CDATA[<p><code>std::condition_variable</code> 是 C++11 多线程编程中的条件变量。</p>
<p>一般用法: 线程 A <strong>等待</strong>某个条件并挂起，直到线程 B 设置了这个条件，并<strong>通知</strong>条件变量，然后线程 A 被唤醒。</p>
<a id="more"></a>



<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>仅支持默认构造函数，拷贝、赋值和移动(move)均是被禁用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br></pre></td></tr></table></figure>

<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><h5 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h5><p>阻塞当前线程直到被其他线程通知唤醒。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h5><p>只有当 <code>pred</code> 条件为 <code>false</code> 时才会阻塞当前线程，并且在收到其他线程的通知后只有当 <code>pred</code> 为 <code>true</code> 时才会被解除阻塞。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span> (<span class="title">unique_lock</span>&lt;mutex&gt;&amp; <span class="title">lck</span>, <span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pred())</span><br><span class="line">&#123;</span><br><span class="line">	wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>通知线程可以使用 <code>notify_one()</code> 通知一个线程，或一次使用 <code>notify_all()</code> 通知所有线程。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; ready;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" start.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">  cv.wait(lck, [] &#123; <span class="keyword">return</span> ready.load(); &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" done.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ready</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set_ready(): "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  ready.store(<span class="literal">true</span>);</span><br><span class="line">  cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ready.store(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> t_1 = <span class="built_in">std</span>::thread(wait, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> t_2 = <span class="built_in">std</span>::thread(wait, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"join...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  t_1.join();</span><br><span class="line">  t_2.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"all done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread: 139827702187776 id: 1 start.</span><br><span class="line">thread: 139827693795072 id: 2 start.</span><br><span class="line">set_ready(): 1</span><br><span class="line">thread: 139827702187776 id: 1 done.</span><br><span class="line">set_ready(): 1</span><br><span class="line">join....</span><br><span class="line">thread: 139827693795072 id: 2 done.</span><br><span class="line">all done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian添加最小化按钮</title>
    <url>/debian_minimize_botton.html</url>
    <content><![CDATA[<p>安装tweak和dconf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br><span class="line">sudo apt install dconf-editor </span><br><span class="line">dconf-editor</span><br></pre></td></tr></table></figure><p>进入路径: <code>org/gnome/desktop/wm/preferences/button-layout</code></p><img src="/debian_minimize_botton/test.png" title="debian_minimize_botton"><p>取消选项 Use default value</p><a id="more"></a>








<p>在 Custom value 填入 <code>appmemu:close,minimize,maximize,close</code></p>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类构造函数</title>
    <url>/constructor.html</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，用于创建类的新对象和初始化自定义类成员。</p><ul>
<li>构造函数具有与类相同的名称，没有返回值，也不返回 <code>void</code>。</li>
<li>可以根据需要定义多个重载构造函数，以各种方式自定义初始化。</li>
<li>构造函数可用于为某些成员变量设置初始值。</li>
<li>通常构造函数具有<strong>公共</strong>可访问性，因此外部代码可以调用其创建类的对象，但也可以将构造函数声明为 <strong>protected</strong> 或 <strong>private</strong> 。</li>
<li>构造函数可以声明为 <strong><code>inline</code>, <code>explicit</code>, <code>friend</code> 或 <code>constexpr</code></strong></li>
<li>构造函数可以初始化已声明为 <code>const</code>, <code>volatile</code> 或者<code>const volatile</code> 的对象，该对象在构造完成后变为 <code>const</code></li>
<li>如果没有自己声明，编译器将为一个类声明 (编译器版本的) <strong>默认构造函数、复制构造函数、复制赋值操作符和析构函数</strong>。所有这些函数都是 <code>public</code> 且 <code>inline</code> 的。</li>
</ul><a id="more"></a>

<h2 id="成员初始化列表-Member-Initializer-List"><a href="#成员初始化列表-Member-Initializer-List" class="headerlink" title="成员初始化列表 Member Initializer List"></a>成员初始化列表 Member Initializer List</h2><p>构造函数可以有一个成员初始化列表，用于在执行构造函数体之前初始化类成员。</p>
<p>使用成员初始化列表比在构造函数体中赋值的效率更高，因为它直接初始化成员变量，而不需要调用赋值构造。</p>
<p><strong>对基类构造函数的调用应在初始化器列表中进行，以确保基类在执行派生构造函数之前已完全初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base(<span class="keyword">int</span> b) : b_(b) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived(<span class="keyword">int</span> b, <span class="keyword">int</span> d) : Base(b), d_(d) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以指定无物 (nothing) 作为初始化实参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived() : Base(), d_(<span class="number">0</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="默认构造-Default-Constructor"><a href="#默认构造-Default-Constructor" class="headerlink" title="默认构造 Default Constructor"></a>默认构造 Default Constructor</h2><p>默认构造函数通常没有参数，但它们可以具有具有默认值的参数。调用默认构造函数时，不应使用括号 (会被视为函数声明) :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 没有参数</span></span><br><span class="line">    Box() &#123; <span class="comment">/*perform any required default initialization steps*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有参数都具有默认值</span></span><br><span class="line">    Box (<span class="keyword">int</span> w = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> h = <span class="number">1</span>): m_width(w), m_height(h), m_length(l)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box1;</span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">box3</span><span class="params">()</span></span>; <span class="comment">// warning C4930: prototyped function not called (was a variable definition intended?)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认构造函数是 <strong>特殊成员函数</strong> 之一，如果未在类中声明任何构造函数，编译器将提供隐式默认的 <strong>inline</strong> 构造函数。如果依赖于隐式默认构造函数，需要确保初始化所有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Volume</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_width * m_height * m_length;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width&#123;<span class="number">0</span>&#125;; <span class="comment">// 初始化成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_height&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_length&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box box1; <span class="comment">// 调用编译器自动生成的默认构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"box1.Volume: "</span> &lt;&lt; box1.Volume() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Outputs 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果声明了任何非默认构造函数，则编译器不提供默认构造函数。没有默认构造函数时，该类的对象数组不能只使用方括号语法构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> width, <span class="keyword">int</span> length, <span class="keyword">int</span> height)</span><br><span class="line">        : m_width(width), m_length(length), m_height(height)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Box box; <span class="comment">// C2512: no appropriate default constructor available</span></span><br><span class="line">    Box boxes[<span class="number">3</span>]; <span class="comment">// C2512: no appropriate default constructor available</span></span><br><span class="line">    Box boxes1[<span class="number">3</span>]&#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制构造-Copy-Constructor"><a href="#复制构造-Copy-Constructor" class="headerlink" title="复制构造 Copy Constructor"></a>复制构造 Copy Constructor</h2><p>复制构造函数通过从相同类型的对象中复制成员值来初始化对象。</p>
<p>如果类成员都是标准简单类型，编译器自动生成的复制构造函数就足够了。但如果成员变量存在指针等复杂类型，那么需要自定义复制构造函数，用于分配新的内存等操作。</p>
<p><strong>Pass-by-value 将自动调用复制构造函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box(Box&amp; other); <span class="comment">// Avoid if possible--allows modification of other.</span></span><br><span class="line">Box(<span class="keyword">const</span> Box&amp; other);</span><br><span class="line">Box(<span class="keyword">volatile</span> Box&amp; other);</span><br><span class="line">Box(<span class="keyword">volatile</span> <span class="keyword">const</span> Box&amp; other);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Additional parameters OK if they have default values</span></span><br><span class="line">Box(Box&amp; other, <span class="keyword">int</span> i = <span class="number">42</span>, <span class="built_in">string</span> label = <span class="string">"Box"</span>);</span><br></pre></td></tr></table></figure>

<p>通过将复制构造函数定义为已删除，可以防止对象被复制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box (<span class="keyword">const</span> Box&amp; other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果定义了复制构造函数，还应定义复制赋值运算符 (=)。</strong></p>
<h2 id="赋值运算符-Copy-Assignment"><a href="#赋值运算符-Copy-Assignment" class="headerlink" title="赋值运算符 Copy Assignment"></a>赋值运算符 Copy Assignment</h2><p>赋值运算符 (<strong>=</strong>) 严格地说是二元运算符，但比较特殊：</p>
<ul>
<li>必须是<strong>非静态</strong> <strong>成员函数</strong>。 </li>
<li>不会被派生类继承。</li>
<li>如果不手动定义，编译器会自动生成一个默认的赋值运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Right side of copy assignment is the argument.</span></span><br><span class="line">    Box&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Box&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define copy assignment operator.</span></span><br><span class="line">Box&amp; Box::<span class="keyword">operator</span>=(<span class="keyword">const</span> Box&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_width = other.m_width;</span><br><span class="line">        m_length = other.m_length;</span><br><span class="line">        m_height = other.m_height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment operator returns left side of assignment.</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复制构造函数和赋值运算符的区别</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box box1;</span><br><span class="line">Box box2 = box1; <span class="comment">// Copy constructor is called</span></span><br><span class="line"><span class="function">Box <span class="title">box3</span><span class="params">(box1)</span></span>; <span class="comment">// Copy constructor call.</span></span><br></pre></td></tr></table></figure>

<h2 id="移动构造-Move-Constructor"><a href="#移动构造-Move-Constructor" class="headerlink" title="移动构造 Move Constructor"></a>移动构造 Move Constructor</h2><p>移动构造函数是一种特殊成员函数，它无需复制原始数据即可将现有对象数据的所有权移动到新对象。它采用左值引用作为第一个参数，任何其他参数都必须具有默认值。移动构造函数可以在传递大型对象时显著提高程序的效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box(Box&amp;&amp; other);</span><br></pre></td></tr></table></figure>

<p>如果对象由即将销毁且不再需要其资源的另一个相同类型的对象初始化，编译器会选择使用移动构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestClass(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;b) : a_(a), b_(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  TestClass(<span class="keyword">const</span> TestClass &amp;other) : a_(other.a_), b_(other.b_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TestClass(TestClass &amp;&amp;other) : a_(other.a_), b_(<span class="built_in">std</span>::move(other.b_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TestClass&gt; vec;</span><br><span class="line">  vec.reserve(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(TestClass(<span class="number">1</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">move</span><br></pre></td></tr></table></figure>

<p>如果<strong>没有定义移动构造函数</strong>，则输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果没有定义移动构造函数，且没有用户声明的复制构造函数、复制赋值运算符、移动赋值运算符或析构函数，编译器将生成隐式构造函数。</p>
</li>
<li><p>如果未定义显式或隐式移动构造函数，则使用移动构造函数的操作将被改为使用复制构造函数。</p>
</li>
<li><p>如果定义了移动构造函数或移动赋值运算符，则隐式声明的复制构造函数将被定义为 <code>deleted</code>。</p>
</li>
<li><p>如果作为类类型的任何成员缺少析构函数或编译器无法确定要用于移动操作哪个构造函数，则隐式声明移动构造函数定义为 <code>deleted</code>。</p>
</li>
</ul>
<h2 id="委托构造函数-Delegating-Constructor"><a href="#委托构造函数-Delegating-Constructor" class="headerlink" title="委托构造函数 Delegating Constructor"></a>委托构造函数 Delegating Constructor</h2><p>委托构造函数调用同一类中的不同构造函数来执行某些初始化工作。</p>
<p>可以在一个构造函数中编写主逻辑，并从其他构造函数调用它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> i) :  Box(i, i, i) &#123;&#125;  <span class="comment">// 委托构造</span></span><br><span class="line">    Box(<span class="keyword">int</span> width, <span class="keyword">int</span> length, <span class="keyword">int</span> height)</span><br><span class="line">        : m_width(width), m_length(length), m_height(height) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="explicit-显式构造"><a href="#explicit-显式构造" class="headerlink" title="explicit 显式构造"></a>explicit 显式构造</h2><p>将构造函数声明为 <code>explicit</code> 可以防止隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    explicit Test(int i) : num(i) &#123; cout &lt;&lt; "Test(int)" &lt;&lt; endl; &#125;</span><br><span class="line">    explicit Test(char c) : letter(c) &#123; cout &lt;&lt; "Test(char)" &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> letter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="string">'2'</span>)</span></span>;</span><br><span class="line">    Test t = <span class="number">3</span>; <span class="comment">// 编译器错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显式默认和删除"><a href="#显式默认和删除" class="headerlink" title="显式默认和删除"></a>显式默认和删除</h2><ul>
<li>可以显式默认复制构造函数、默认构造函数、move构造函数、复制赋值操作符、move赋值操作符和析构函数。</li>
<li>可以显式地删除所有特殊成员函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">    Noncopyable(<span class="keyword">const</span> Noncopyable&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Noncopyable&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable(Noncopyable&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable&amp; <span class="keyword">operator</span>=(Noncopyable&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleOnly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DoubleOnly(<span class="keyword">float</span>) = <span class="keyword">delete</span>;</span><br><span class="line">  DoubleOnly(<span class="keyword">double</span> d) : d_(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些规则：</p>
<ul>
<li>如果显式声明了任何构造函数，则不会自动生成默认构造函数。</li>
<li>如果显式声明了虚拟析构函数，则不会自动生成默认析构函数。</li>
<li>如果显式声明了移动构造函数或移动赋值运算符，则：<ul>
<li>不自动生成复制构造函数。</li>
<li>不自动生成复制赋值运算符。</li>
</ul>
</li>
<li>如果显式声明了复制构造函数、复制赋值运算符、移动构造函数、移动赋值运算符或析构函数，则：<ul>
<li>不自动生成移动构造函数。</li>
<li>不自动生成移动赋值运算符。</li>
</ul>
</li>
</ul>
<h2 id="构造顺序"><a href="#构造顺序" class="headerlink" title="构造顺序"></a>构造顺序</h2><p>构造函数按此顺序执行工作：</p>
<ul>
<li><p>按声明顺序调用基类和成员构造函数。</p>
</li>
<li><p>如果类继承自一个虚拟基类，将对象的虚拟基指针初始化。</p>
</li>
<li><p>如果类具有或继承了虚函数，将对象的虚函数指针初始化。虚函数指针指向类中的虚函数表，确保虚函数正确地调用绑定代码。</p>
</li>
<li><p>执行构造函数体中的代码。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained1 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained2() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained2 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained3() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained3 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseContainer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BaseContainer() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"BaseContainer ctor\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Contained1 c1;</span><br><span class="line">  Contained2 c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedContainer</span> :</span> <span class="keyword">public</span> BaseContainer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DerivedContainer() : BaseContainer() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DerivedContainer ctor\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Contained3 c3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DerivedContainer dc;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Contained1 ctor</span><br><span class="line">Contained2 ctor</span><br><span class="line">BaseContainer ctor</span><br><span class="line">Contained3 ctor</span><br><span class="line">DerivedContainer ctor</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 解压缩rar包</title>
    <url>/extract_from_rar.html</url>
    <content><![CDATA[<h4 id="下载rar软件安装包"><a href="#下载rar软件安装包" class="headerlink" title="下载rar软件安装包"></a>下载rar软件安装包</h4><ol>
<li><p>直接从 <a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">rarlab</a> 下载安装包</p>
</li>
<li><p>通过命令行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.rarlab.com/rar/rarlinux-x64-6.0.1.tar.gz  <span class="comment"># 64位</span></span><br><span class="line">wget https://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz	   <span class="comment"># 32位</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf rarlinux-x64-6.0.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> rar</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h4 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar x xxx.rar  <span class="comment"># Extract files with full path</span></span><br><span class="line">rar e xxx.rar  <span class="comment"># Extract files without archived paths</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>



<h4 id="将xxx目录压缩为xxx-rar"><a href="#将xxx目录压缩为xxx-rar" class="headerlink" title="将xxx目录压缩为xxx.rar"></a>将xxx目录压缩为xxx.rar</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar a xxx.rar xxx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uncompress</tag>
        <tag>rar</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 搭建FTP服务器</title>
    <url>/ftp_server.html</url>
    <content><![CDATA[<h4 id="安装ftp和vsftpd"><a href="#安装ftp和vsftpd" class="headerlink" title="安装ftp和vsftpd"></a>安装ftp和vsftpd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ftp</span><br><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用vsftpd软件，主要包括如下几个命令：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动ftp</span></span><br><span class="line">service vsftpd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止ftp</span></span><br><span class="line">service vsftpd stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启ftp</span></span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure><a id="more"></a>



<h4 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h4><p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># vi /etc/vsftpd/vsftpd.conf</span></span><br></pre></td></tr></table></figure>

<p>按照需求修改为以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"></span><br><span class="line"># local root</span><br><span class="line">local_root=/home/bot/dev/moma_app/scanner_images</span><br></pre></td></tr></table></figure>

<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>

<h4 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录本地ftp</span></span><br><span class="line">ftp 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名和密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前路径是否设置的local root</span></span><br><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>使用clang和black 对C++、Python代码自动格式化</title>
    <url>/format_code.html</url>
    <content><![CDATA[<h4 id="使用clang对C-进行格式化"><a href="#使用clang对C-进行格式化" class="headerlink" title="使用clang对C++进行格式化"></a>使用<code>clang</code>对C++进行格式化</h4><ul>
<li><p>安装<code>clang-format-7</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y clang-format-7</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写脚本 <code>clang_format.bash</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -regextype egrep -regex <span class="string">".*\.(c|cc|h|hh)$"</span> -not -path <span class="string">'*/install/*'</span> \</span><br><span class="line">  -not -path <span class="string">'*/build/*'</span> -not -path <span class="string">'*/log/*'</span> -not -path <span class="string">'*/deps/*'</span>| xargs clang-format-7 -i</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./clang_format.bash</span><br></pre></td></tr></table></figure>





</li>
</ul><a id="more"></a>
<h4 id="使用black对python进行格式化"><a href="#使用black对python进行格式化" class="headerlink" title="使用black对python进行格式化"></a>使用<code>black</code>对python进行格式化</h4><ul>
<li><p>安装<code>black</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install black==20.8b1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">black .</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>clang</tag>
        <tag>linux</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 笔记</title>
    <url>/Effective-Cpp.html</url>
    <content><![CDATA[<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="1-视C-为一个语言联邦"><a href="#1-视C-为一个语言联邦" class="headerlink" title="1. 视C++为一个语言联邦"></a>1. 视C++为一个语言联邦</h3><p>C++是从四个次语言组成的联邦政府，每个次语言都有自己的规则。</p><ul>
<li>C：C++的基础</li>
<li>Object-Oriented C++：面向对象设计，类/封装/继承/多态/virtual函数等</li>
<li>Template C++：范型编程/模版元编程</li>
<li>STL：容器/迭代器/算法/函数对象</li>
</ul><a id="more"></a>

<p>对于不同的次语言，往往有不同的高效编程守则。</p>
<p>对于内置类型（C-like）而言 pass-by-value 通常比 pass-by-referenece 高效；对于用户自定义的类型（Object-Oriented C++），因为构造函数和析构函数的存在，pass-by-reference-to-const 往往更好；对于 Template C++，由于所处理的对象的类型不确定，也应使用 pass-by-reference-to-const；对于 STL 的迭代器和函数对象，由于它们都是基于C指针塑造出来的，所以 pass-by-value的守则再次适用。</p>
<h3 id="2-尽量以-const-enum-inline-替代-define"><a href="#2-尽量以-const-enum-inline-替代-define" class="headerlink" title="2. 尽量以 const, enum, inline 替代 #define"></a>2. 尽量以 const, enum, inline 替代 #define</h3><ul>
<li><p>#define 不被视为语言的一部分，预处理器会将所有的宏替换，容易导致问题且难以追踪。</p>
</li>
<li><p>#define 不重视作用域，在被定义后的编译过程中一直有效，所以没有任何封装性，不能用来定义 class 专属常量，也没有 private #define 这样的东西。</p>
</li>
</ul>
<h4 id="普通常量替代-define-gt-const"><a href="#普通常量替代-define-gt-const" class="headerlink" title="普通常量替代 #define -&gt; const"></a>普通常量替代 #define -&gt; const</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.635</span>;</span><br></pre></td></tr></table></figure>

<h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><p>由于常量指针通常被放在头文件内，因此有必要将指针也声明为 const。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"Tiffany"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">"Tiffany"</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="class-专属常量"><a href="#class-专属常量" class="headerlink" title="class 专属常量"></a>class 专属常量</h4><p>为了确保常量只有一份实体，必须让它成为 <code>static</code> 成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Num = <span class="number">5</span>;  <span class="comment">// 声明式</span></span><br><span class="line">	<span class="keyword">int</span> scores[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A::Num; <span class="comment">// 定义式，应写在.cc文件中</span></span><br></pre></td></tr></table></figure>

<h4 id="enum-hack"><a href="#enum-hack" class="headerlink" title="enum hack"></a>enum hack</h4><p>旧式编译器有可能不允许 static 成员在声明式上获得初值（只能在定义式时初始化），可以使用 the enum back 补偿做法，将枚举类型的数值当做int使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123; Num = <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> scores[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="template-inline-函数替代宏"><a href="#template-inline-函数替代宏" class="headerlink" title="template inline 函数替代宏"></a>template inline 函数替代宏</h4><p>宏看起来像函数，但不会招致函数调用带来的额外开销，可是非常容易导致不确定行为。使用 template inline 函数可以获得宏带来效率以及一般函数的所有可预料行为和类型安全性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;typanme T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">call_with_max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> <span class="comment">// pass by reference-to-const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-尽可能使用-const"><a href="#3-尽可能使用-const" class="headerlink" title="3. 尽可能使用 const"></a>3. 尽可能使用 const</h3><h4 id="const-语法"><a href="#const-语法" class="headerlink" title="const 语法"></a>const 语法</h4><p>如果 const 出现在星号左边，表示被指物为常量；如果出现在星号右边，表示指针自身是常量（不能指向别的东西，但所指的东西的值可以改动）；如果出现在星号两边，表示被指物和指针都是常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = greeting;             <span class="comment">// 非常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;       <span class="comment">// 被指的data为常量</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* p = greeting;       <span class="comment">// 被指的data为常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;       <span class="comment">// 指针为常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 指针和被指的data都为常量</span></span><br></pre></td></tr></table></figure>

<h4 id="函数返回值声明为const"><a href="#函数返回值声明为const" class="headerlink" title="函数返回值声明为const"></a>函数返回值声明为const</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>此处 const 可以避免一些<del>傻逼</del>行为，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line"><span class="keyword">if</span> ((a + b) = c) <span class="comment">// 奇怪的赋值</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对照查看 <a href="#10-令-operator=-返回一个-reference-to-*this">条例10-令 operator= 返回一个 reference to *this</a></p>
</blockquote>
<h4 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h4><ul>
<li><p>const 对象只能访问其 const 成员函数，所以当对象被以 pass-by-reference-to-const 方式传递时，也只能调用其 const 成员函数。</p>
</li>
<li><p>两个函数如果只是常量性不同，也是重载。</p>
</li>
<li><p><strong>bitwise const</strong>：成员函数只有在不更改对象的任何变量时才可以说是const。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">// !!返回也为const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> text[position];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> position)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> text[position];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBolck <span class="title">tb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>; <span class="comment">// non-const TextBlock</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>];    <span class="comment">// 调用 non-const TextBlock::operator[]</span></span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">'x'</span>;           <span class="comment">// 没问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>; <span class="comment">// const Textblock</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];          <span class="comment">// 调用 const TextBlock::operator[]</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">'x'</span>;                 <span class="comment">// 错误，不允许写入</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrongTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">// 返回值未声明为const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> text[position];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> WrongTextBlock <span class="title">cwtb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line">cwtc[<span class="number">0</span>] = <span class="string">'x'</span>;     <span class="comment">// Hello -&gt; xello</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>将成员变量声明为 mutable，则此变量在 const 成员函数内也可以被修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">size_t</span> text_length;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">bool</span> length_is_valid;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!length_is_valid)</span><br><span class="line">    &#123;</span><br><span class="line">      text_length = text.size();  <span class="comment">// mutable members</span></span><br><span class="line">      length_is_valid = <span class="literal">true</span>;     <span class="comment">// 可以被修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> text_length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本（通过转型）避免代码重复。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line">  cosnt <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">		<span class="keyword">return</span> text[position];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> position)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// static_cast: *this -&gt; const TextBlock&amp;</span></span><br><span class="line">    <span class="comment">// const_cast: const char&amp; -&gt; char&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-确定对象被使用前已被初始化"><a href="#4-确定对象被使用前已被初始化" class="headerlink" title="4. 确定对象被使用前已被初始化"></a>4. 确定对象被使用前已被初始化</h3><h4 id="内置类型需要手动初始化"><a href="#内置类型需要手动初始化" class="headerlink" title="内置类型需要手动初始化"></a>内置类型需要手动初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* test = <span class="string">"A C-style string"</span>;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d;  <span class="comment">// 以读取 input stream 的方式完成初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义类型：使用初始化列表"><a href="#自定义类型：使用初始化列表" class="headerlink" title="自定义类型：使用初始化列表"></a>自定义类型：使用初始化列表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address, </span><br><span class="line">          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    : the_name(name),</span><br><span class="line">      the_address(address),</span><br><span class="line">      the_phones(phones),</span><br><span class="line">      num_times_consulted(<span class="number">0</span>) </span><br><span class="line">  &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  ABEntry() </span><br><span class="line">    : the_name(),   <span class="comment">// 调用the_name的default构造函数</span></span><br><span class="line">      the_address(),</span><br><span class="line">      the_phones(),</span><br><span class="line">      num_times_consulted(<span class="number">0</span>)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> the_name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> the_address;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; the_phones;</span><br><span class="line">  <span class="keyword">int</span> num_times_consulted;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="non-local-static-对象"><a href="#non-local-static-对象" class="headerlink" title="non-local static 对象"></a>non-local static 对象</h4><ul>
<li><code>static</code> 对象的寿命从被构造出来直到程序结束为止，包括 ：<code>global</code>对象，定义于 <code>namespace</code> 作用域内的对象，在 <code>classes</code> 内，在函数内，在 <code>file</code> 作用域内被申明为 <code>static</code> 的对象。</li>
<li>函数内的 <code>static</code> 对象称为 <code>local static</code> 对象，其他称为 <code>non-local static</code>  对象。</li>
<li>编译单元是指产出单一目标文件的源码，基本上是单一源码文件加上所含的头文件。</li>
<li>如果编译单元内的某个 non-local static 对象的初始化动作使用了另一编译单元内的某个 non-local static 对象，后者可能尚未被初始化。<strong>因为C++对 ”定义于不同编译单元内的 non-local static 对象“ 的初始化次序并无明确定义</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> num_disks() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dictory(params)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> discks = tfs.numsDicks();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">temp_dir</span><span class="params">(params)</span></span>;   <span class="comment">// tfs可能还没被初始化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方法（Singleton模式常用实现方法）：将每个 non-local static 对象搬到自己的专属函数内 (在函数内声明为 static)，这些函数返回一个 reference 指向它所含的 static 对象，用户调用这些函数而不直接指涉这些对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">  <span class="keyword">return</span> fs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>...&#125;;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">size_t</span> disks = tfs().numsDisks();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Directory td;</span><br><span class="line">  <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造 / 析构 / 赋值运算"></a>构造 / 析构 / 赋值运算</h2><h3 id="5-了解C-默默编写并调用哪些函数"><a href="#5-了解C-默默编写并调用哪些函数" class="headerlink" title="5. 了解C++默默编写并调用哪些函数"></a>5. 了解C++默默编写并调用哪些函数</h3><ul>
<li><p>对于每个 class，如果没有声明，编译期会为它自动声明（编译器版本的）一个 <strong>copy 构造函数</strong>，一个 <strong>copy assignment 操作符</strong>和一个<strong>析构函数</strong>。如果没有声明任何的构造函数，编译器也会自动声明一个 <strong>default 构造函数</strong>。这些函数都是 <strong>public 且 inline</strong> 的。</p>
</li>
<li><p>编译器产出的析构函数是 non-virtual 的，除非这个类的基类自身声明有虚析构函数。</p>
</li>
<li><p>编译器生成的 copy 构造函数和 copy assignment 操作符，只是单纯地将来源对象的每一个 non-static 成员变量拷贝到目标对象。</p>
</li>
<li><p>只有当生出的代码合法且有适当机会证明它有意义，编译器才会自动生成 copy assignment 操作符，任一条件不符合时（比如 class 内含 reference 成员 / const 成员），编译器将拒绝生成 operator=。</p>
</li>
</ul>
<h3 id="6-若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#6-若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="6. 若不想使用编译器自动生成的函数，就该明确拒绝"></a>6. 若不想使用编译器自动生成的函数，就该明确拒绝</h3><ul>
<li><p>将默认生成的成员函数声明为 private 且不实现他们，或者继承（可以是 private 继承）Uncopyable 也是一种做法。</p>
</li>
<li><p>现在可以使用关键字 delete 阻止编译器自动生成相关函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A() = <span class="keyword">delete</span>;                     <span class="comment">// 阻止编译器生成默认构造函数</span></span><br><span class="line">  A(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;             <span class="comment">// 阻止编译器生成copy构造函数</span></span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 阻止编译器生成copy assignment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="7-为多态基类声明-virtual-析构函数"><a href="#7-为多态基类声明-virtual-析构函数" class="headerlink" title="7. 为多态基类声明 virtual 析构函数"></a>7. 为多态基类声明 virtual 析构函数</h3><ul>
<li><p>当一个派生类对象经由一个基类指针被删除，而该基类带着一个non-virtual析构函数，其结果未有定义——实际执行时通常发生的事对象的 derived 成分没被销毁（造成一个诡异的局部销毁对象）。</p>
</li>
<li><p>任何 class 只要带有 virtual 函数都几乎确定应该也有一个 virtual析构函数。</p>
</li>
<li><p><strong>多态机制</strong>：在<strong>运行期</strong>决定哪一个 virtual 函数应该被调用。每一个有虚函数的类或有虚函数的类的派生类，都有一个由函数指针构成的数组，存放着所有虚函数的地址，称为<strong>虚函数表 vtbl</strong> (virtual table)；该类的任何对象中都放着一个指向虚函数表的指针 vptr (virtual table pointer)；当对象调用某一 virtual 函数，实际被调用的函数取决于该对象的 vptr 所指的那个 vtbl。</p>
</li>
<li><p>由于 vptr 的存在，对象的体积会增加，也就是会增加程序运行时的开销。所以对于不含任何 virutal 函数的类，没必要为它声明 virtual 析构函数。</p>
</li>
<li><p>如果希望一个基类成为抽象类，但它本身没有任何纯虚函数，可以为它声明一个<strong>纯虚析构函数</strong>，且（必须）为它提供定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AWOV::~AWOV() &#123;&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8. 别让异常逃离析构函数"></a>8. 别让异常逃离析构函数</h3><ul>
<li>析构函数绝对不要吐出异常，否则很可能造成程序过早结束或出现不明确行为。</li>
<li>如果析构函数将调用一个可能抛出异常的函数，析构函数应该捕捉异常，然后吞下它们或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 abort() 强迫结束程序</span></span><br><span class="line">DBConn::DBConn()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; db.close(); &#125; <span class="comment">// 可能抛出异常</span></span><br><span class="line">  <span class="keyword">catch</span> (...)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 制作运转记录</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 吞掉异常（只记录不处理）</span></span><br><span class="line">DBConn::DBConn()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123; db.close(); &#125; <span class="comment">// 可能抛出异常</span></span><br><span class="line">  <span class="keyword">catch</span> (...)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 制作运转记录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 提供普通函数，客户可以在别的地方调用并处理可能的异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>    <span class="comment">// 供客户使用的新函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    dv.close();</span><br><span class="line">    closed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ~DBConn()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!close)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123; db.close(); &#125;  <span class="comment">// 跟2是一样的 "双保险"</span></span><br><span class="line">      <span class="keyword">catch</span> (...)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 制作运转记录</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  DBConnection db;</span><br><span class="line">  <span class="keyword">bool</span> closed = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-绝不在构造和析构过程中调用-virtual-函数"><a href="#9-绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="9. 绝不在构造和析构过程中调用 virtual 函数"></a>9. 绝不在构造和析构过程中调用 virtual 函数</h3><ul>
<li><p>在派生类对象的基类构造期间，此对象的类型是基类而不是派生类，所以调用 virtual 函数也之后调用到基类对应的函数，不会下降到派生类。同理，对象进入基类的析构函数后，对象也就称为一个基类对象，同样需函数不会下降到派生类。</p>
</li>
<li><p>所以绝不要在构造函数和析构函数中调用 virtual 函数，且它们调用的所有函数也都应服从同一约束。</p>
</li>
</ul>
<h3 id="10-令-operator-返回一个-reference-to-this"><a href="#10-令-operator-返回一个-reference-to-this" class="headerlink" title="10. 令 operator= 返回一个 reference to *this"></a>10. 令 operator= 返回一个 reference to *this</h3><p>为了实现连锁赋值，赋值操作符必须返回一个reference指向操作符的左侧实参。为classes 实现赋值 (=) 操作符以及所有复制相关运算 (+=, -=, *=等) 时应该遵循此协议：返回一个 reference to *this。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>* <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连锁赋值</span></span><br><span class="line">Widget a, b, c;</span><br><span class="line">a = b = c = Widget();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对照查看 <a href="#函数返回值声明为const">条例3-函数返回值声明为const</a></p>
</blockquote>
<h3 id="11-在-operator-中处理“自我赋值”"><a href="#11-在-operator-中处理“自我赋值”" class="headerlink" title="11. 在 operator= 中处理“自我赋值”"></a>11. 在 operator= 中处理“自我赋值”</h3><ul>
<li><p>验同测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Bitmap* pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;   <span class="comment">// 验同测试</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> pb;</span><br><span class="line">  pb = <span class="keyword">new</span> Bitmap(*rgs.pb);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>精心安排的语句</strong>可以使代码具有“异常安全性“（自动获得“自我赋值安全性”）：在复制构造之前别删除原指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123; </span><br><span class="line">  Bitmap* p_ori = pb;</span><br><span class="line">  pb = <span class="keyword">new</span> Bitmap(*rgs.pb);</span><br><span class="line">  <span class="keyword">delete</span> p_ori;             <span class="comment">// 复制后再删除原指针</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>copy and swap</strong> 技术</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 常见</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123; </span><br><span class="line">  Widget temp(rhs);</span><br><span class="line">  swap(temp);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. pass by value</span></span><br><span class="line"><span class="comment">// 将copying从函数本体移到函数参数构造阶段，更高效，但牺牲了清晰性</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)</span><br><span class="line">&#123; </span><br><span class="line">  swap(rhs);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[条例25](25. 考虑写出一个不抛异常的 swap 函数) 详细介绍 swap</p>
</blockquote>
</li>
</ul>
<h3 id="12-复制对象时勿忘其每一个成分"><a href="#12-复制对象时勿忘其每一个成分" class="headerlink" title="12. 复制对象时勿忘其每一个成分"></a>12. 复制对象时勿忘其每一个成分</h3><ul>
<li><p>Copying 函数应该确保复制 ”对象内的所有成员变量“ 以及 ”所有 base class 成分“。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived(<span class="keyword">const</span> Derived&amp; rhs);</span><br><span class="line">  Derived&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Derived&amp; rhs);</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived::Derived(<span class="keyword">const</span> Derived&amp; rhs)</span><br><span class="line">  : Base(rhs),             <span class="comment">// 调用base的copy构造函数</span></span><br><span class="line">    member(rhs.member) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Derived::Derived&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Derived&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  Base::<span class="keyword">operator</span>=(rhs);    <span class="comment">// 调用base的赋值运算符</span></span><br><span class="line">  member = rhs.member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>不要尝试以一个 copying 函数实现另一个。如果 copy 构造函数和 copy assignment 操作符有相近的代码，消除重复代码的做法是，将重复代码放进一个新的成员函数中 (private init() )，由两个 copy 函数共同调用。</li>
</ul>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13. 以对象管理资源"></a>13. 以对象管理资源</h3><ul>
<li><p>*<em>RAII: Resource Acquisition Is initialization; *</em>获得资源后立刻放进管理对象内。</p>
</li>
<li><p>常用的 RAII classes：</p>
<ul>
<li><code>auto_ptr</code> (已被删除) : 复制动作会使他指向null。</li>
<li><strong>引用计数型智慧指针 (RCSP, reference-counting smart pointer)</strong>  <code>tr1::shared_ptr</code> : 持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源。</li>
</ul>
</li>
</ul>
<h3 id="14-在资源管理类中小心-copying-行为"><a href="#14-在资源管理类中小心-copying-行为" class="headerlink" title="14. 在资源管理类中小心 copying 行为"></a>14. 在资源管理类中小心 copying 行为</h3><ul>
<li><p>复制<strong>RAII</strong>对象时必须一并复制它所管理的资源。</p>
</li>
<li><p>一般资源管理类复制时可以选择以下做法：</p>
<ul>
<li><p>禁止复制</p>
<blockquote>
<p>参照<a href="#6-若不想使用编译器自动生成的函数，就该明确拒绝">条例6</a></p>
</blockquote>
</li>
<li><p>“引用计数法”（使用 <code>tr1::shared_ptr</code> 指定 “删除器” 替代引用次数为0时的删除行为）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span></span></span><br><span class="line">    : mutex_ptr(pm, unlock)  // 以unlock作为删除器</span><br><span class="line">  &#123;</span><br><span class="line">    lock(mutex_ptr.get());   <span class="comment">// 条例15谈到"get" </span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutex_ptr;  <span class="comment">// shared_ptr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="#15-在资源管理类中提供对原始资源的访问">条例15</a>谈到 <code>get()</code></p>
</blockquote>
<blockquote>
<p><a href="#18-让接口容易被正确使用，不易被误用">条例18</a> 谈到 定制删除器可以防范DLL问题</p>
</blockquote>
</li>
<li><p>复制底层资源（“深度拷贝”）</p>
</li>
<li><p>转移底部资源的拥有权（<code>auto_ptr</code>）: 资源的拥有权从被父之物转移到目标物。</p>
</li>
</ul>
</li>
</ul>
<h3 id="15-在资源管理类中提供对原始资源的访问"><a href="#15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15. 在资源管理类中提供对原始资源的访问"></a>15. 在资源管理类中提供对原始资源的访问</h3><ul>
<li>许多 APIs 要求直接访问原始资源，所以每一个 RAII class 应该提供一个 “取得其所管理资源” 的办法。</li>
<li>对原始资源的访问可能经由显示转换或隐式转换；一般显式转换更安全，而隐式转换对客户更方便。</li>
<li><code>tr1::shared_ptr</code> 和 <code>auto_ptr</code> 都提供一个 <code>get</code> 成员函数，用来执行显式转换，也就是返回只能指针内部的原始指针（的复件）。</li>
<li><code>tr1::shared_ptr</code> 和 <code>auto_ptr</code> 也重载了指针取值操作符 (<code>operator-&gt;</code> 和 <code>operator*</code> )，它们允许隐式转换至底层指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C APIs</span></span><br><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeFontSize</span><span class="params">(FontHandle f, <span class="keyword">int</span> newSize)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  explicit Font(FontHandle fh) : f(fh) &#123;&#125;</span><br><span class="line">  ~ Font() &#123; releaseFront(f); &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 显式转换函数</span></span><br><span class="line">  <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> f; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 隐式转换函数</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FontHandle f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Font f(getFont())；</span><br><span class="line">in newFontSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 显示转换</span></span><br><span class="line">changeFontSize(f.get(), newFontSize);</span><br><span class="line"><span class="comment">// 2. 隐式转换</span></span><br><span class="line">changeFontSize(f, newFontSize);</span><br></pre></td></tr></table></figure>

<h3 id="16-成对使用-new-和-delete-时要采取相同形式"><a href="#16-成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="16. 成对使用 new 和 delete 时要采取相同形式"></a>16. 成对使用 new 和 delete 时要采取相同形式</h3><p>new 和 delete 成对， new[] 和 delete[] 成对。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr1 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> stringStr1;</span><br><span class="line"><span class="keyword">delete</span> [] stringStr2;</span><br></pre></td></tr></table></figure>

<h3 id="17-以独立语句将-newed-对象置入智能指针"><a href="#17-以独立语句将-newed-对象置入智能指针" class="headerlink" title="17. 以独立语句将 newed 对象置入智能指针"></a>17. 以独立语句将 newed 对象置入智能指针</h3><p>应以独立语句将 newed 对象存储于智能指针内，否则一旦异常被抛出，有可能导致难以察觉的资源泄漏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::tr1::Shared_ptr&lt;Widger&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="comment">// 核算实参的次序不确定，有可能：</span></span><br><span class="line"><span class="comment">// 1. new Widget</span></span><br><span class="line"><span class="comment">// 2. 调用priority</span></span><br><span class="line"><span class="comment">// 3. 调用tr1::shared_ptr构造</span></span><br><span class="line"><span class="comment">// 假设priority()调用导致异常，则new Widget返回的指针将会遗失</span></span><br><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br><span class="line"></span><br><span class="line"><span class="comment">// correct</span></span><br><span class="line"><span class="comment">// 次序确定</span></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure>

<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="18-让接口容易被正确使用，不易被误用"><a href="#18-让接口容易被正确使用，不易被误用" class="headerlink" title="18. 让接口容易被正确使用，不易被误用"></a>18. 让接口容易被正确使用，不易被误用</h3><ul>
<li><p>**”促进正确使用” **的办法包括接口的一致性，以及与内置类型的行为兼容。</p>
</li>
<li><p>**”防治误用” **的办法包括建立新类型，限制类型上的操作，束缚对象值 (加上 <code>const</code> )，以及消除用户的资源管理责任。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建新类型，避免错误调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Month(<span class="number">1</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Month(<span class="number">2</span>);&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>条例4 谈到 [non-local static对象](#non-local static 对象)的初始化次序问题，以函数代替对象</p>
</blockquote>
</li>
<li><p><code>tr1::shared_ptr</code> 有一个特别好的特质是：它支持定制型删除器，也就是会自动追踪/使用 “每个指针专属的删除器“，可以消除所谓的 “cross-DLL problem”（这个问题发生于 “对象在动态链接程序库(DLL)中被 <code>new</code> 创建，却在另一个DLL中被 <code>delete</code> 销毁。在许多平台上，这一来跨DLL之 new/delete 成对运用会导致运行器错误。）</p>
<blockquote>
<p>参照[条例14](#14-在资源管理类中小心 copying 行为) 定制删除器用来自动解除互斥锁</p>
</blockquote>
</li>
<li><p><code>tr1::shared_ptr</code> 带来性能上的损失(并不显著)：Boost 的 shared_ptr 是原始指针的两倍大，以动态分配内存作为簿记用途和 “删除器之专属数据”，以 virtual 形式调用删除器，并在多线程程序修改引用次数时蒙受线程同步化的额外开销。</p>
</li>
</ul>
<h3 id="19-设计-class-犹如设计-type"><a href="#19-设计-class-犹如设计-type" class="headerlink" title="19. 设计 class 犹如设计 type"></a>19. 设计 class 犹如设计 type</h3><p>设计一个高效的 class，往往需要思考以下问题</p>
<ul>
<li><p>新 type 的对象应该如何被创建和销毁？</p>
</li>
<li><p>对象的初始化和对象的赋值应该有什么样的差别？</p>
</li>
<li><p>新 type 的对象如果被 passed by value，意味着什么？（copy构造）</p>
</li>
<li><p>什么是新 type 的 “合法值” ？（构造函数/赋值操作符/setter函数的约束条件）</p>
</li>
<li><p>你的新 type 需要配合某个继承图系吗？（考虑virtual）</p>
</li>
<li><p>你的新 type 需要什么样的转换？（显式/隐式转换）</p>
</li>
<li><p>什么样的操作符和函数对此新 type 而言是合理的？</p>
</li>
<li><p>什么样的标准函数应该驳回？</p>
</li>
<li><p>谁该取用新 type 的成员？（关于public/protected/private）</p>
</li>
<li><p>什么是新 type 的 “未声明接口” ？（异常安全性？）</p>
</li>
<li><p>你的新 type 有多么一般化？（需要template吗）</p>
</li>
<li><p>你真的需要一个新 type 吗？</p>
</li>
</ul>
<h3 id="20-宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#20-宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="20. 宁以 pass-by-reference-to-const 替换 pass-by-value"></a>20. 宁以 pass-by-reference-to-const 替换 pass-by-value</h3><ul>
<li><p>效率更高：不需要创建新对象 -&gt; 不需要调用构造函数/析构函数</p>
</li>
<li><p>可以避免对象切割 (slicing) 问题：当一个 derived class 对象以 by value 方式传递并被视为一个 base class 对象，那么 base class 的 copy 构造函数会被调用，造成 derived class 部分被切割。</p>
</li>
<li><p>但对于内置类型/STL的迭代器和函数对象，pass-by-value往往比较合适。</p>
</li>
</ul>
<h3 id="21-必须返回对象时，别妄想返回其-reference"><a href="#21-必须返回对象时，别妄想返回其-reference" class="headerlink" title="21. 必须返回对象时，别妄想返回其 reference"></a>21. 必须返回对象时，别妄想返回其 reference</h3><ul>
<li><p>函数创建新对象的途径：</p>
<ul>
<li>在 stack 空间上创建：定义一个 local 变量</li>
<li>在 heap 空间上创建：用 new 创建一个对象</li>
</ul>
</li>
<li><p>不要返回 pointer 或 reference 指向一个 local stack 对象：在函数退出之前就被销毁了</p>
</li>
<li><p>不要返回 pointer 或 reference 指向一个 heap 对象：违背了 new 和 delete 成对出现的原则，用户不知道如何 delete</p>
</li>
<li><p>不要返回 pointer 或 reference 指向一个 local static 对象的引用，否则多次调用时会出现问题（static 只有一份）</p>
</li>
<li><p>一个 ”必须返回新对象“ 的函数的正确写法是：就让它返回一个新对象呗</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="22-将成员变量声明为private"><a href="#22-将成员变量声明为private" class="headerlink" title="22. 将成员变量声明为private"></a>22. 将成员变量声明为private</h3><p>将成员变量声明为 private可以：</p>
<ul>
<li>使客户只能通过成员函数访问对象（一致性）</li>
<li><strong>封装</strong>：将成员变量隐藏在函数接口的背后，可以为实现提供弹性（保留了日后变更实现的权利）</li>
</ul>
<h3 id="23-宁以-non-member-non-friend-替换-member-函数"><a href="#23-宁以-non-member-non-friend-替换-member-函数" class="headerlink" title="23. 宁以 non-member / non-friend 替换 member 函数"></a>23. 宁以 non-member / non-friend 替换 member 函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// member function</span></span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cleraCache();</span><br><span class="line">    clearHistory();</span><br><span class="line">    removeCookies();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webbrowser.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// non-member non-friend function</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    wb.cleraCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.removeCookies();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webbrowserbookmarks.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">  ...           <span class="comment">// 与书签相关的便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">  ...           <span class="comment">// 与cookie相关的便利函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>member 函数比 non-member non-friend 函数的封装性低。</li>
<li>将所有便利函数放在多个头文件内但是隶属于同一个命名空间，这允许客户只对他们所用的那一小部分系统形成编译相依（降低编译依存性），也可以轻松扩展这一组便利函数。</li>
</ul>
<blockquote>
<p>[条例31](#31. 将文件间的编译依存关系降至最低) 讨论其他降低编译依存性的做法</p>
</blockquote>
<h3 id="24-若所有参数皆需类型转换，请为此采用-non-member-函数"><a href="#24-若所有参数皆需类型转换，请为此采用-non-member-函数" class="headerlink" title="24. 若所有参数皆需类型转换，请为此采用 non-member 函数"></a>24. 若所有参数皆需类型转换，请为此采用 non-member 函数</h3><ul>
<li><p><strong>建立数值类型</strong>时可以令 classes 支持隐式转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>); <span class="comment">// 允许int-&gt;Rational隐式转换</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只有参数列中的参数才是隐式转换的有效参与者</strong>，this 对象无法进行隐式转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// member function</span></span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneHalf * <span class="number">2</span>;  <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">// wrong!</span></span><br><span class="line">                       <span class="comment">// -&gt; 2.operator(oneHalf)</span></span><br><span class="line">                       <span class="comment">// -&gt; operator*(2, oneHalf)</span></span><br><span class="line">                       <span class="comment">// 只有后者才在参数列中，可以进行隐式转换</span></span><br><span class="line">                       <span class="comment">// this对象无法进行隐式转换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// non-member function</span></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                  lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> result = <span class="number">2</span> * oneHalf; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>由于有 public 的接口 <code>numerator()</code>  <code>denominator()</code>，不需要调用 private 的成员变量，所以此 operator* 函数<strong>不需要成为 friend 函数</strong>。</p>
</li>
</ul>
<h3 id="25-考虑写出一个不抛异常的-swap-函数"><a href="#25-考虑写出一个不抛异常的-swap-函数" class="headerlink" title="25. 考虑写出一个不抛异常的 swap 函数"></a>25. 考虑写出一个不抛异常的 swap 函数</h3><ul>
<li><code>swap()</code> 是<strong>异常安全性编程的脊柱</strong>，也是用来<strong>处理自我赋值可能性的一个常见机制</strong>。</li>
</ul>
<blockquote>
<p>[条例29](#29-为 “异常安全” 努力是值得的) 讨论异常安全性编程</p>
<p>[条例11](#11. 在 operator= 中处理”自我赋值”) 谈到自我赋值的处理</p>
</blockquote>
<ul>
<li><p>pimpl (pointer to implementation) 手法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a, b, c;</span><br><span class="line">  <span class="built_in">std</span>::Vector&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    *pImpl = *(rhs.pImpl);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只要类型支持copying，缺省情况下 swap 动作可由标准程序库提供的 swap 算法完成。但对于某些类型而言，没有必要深拷贝来进行 swap。比如 Widget，只需要置换其 pImpl 指针就可以完成置换。像这样 <strong>std::swap 对自定义类型效率不高时，可以将 std::swap 针对 Widget 特化</strong>（提供一个 member swap 和一个 non-member swap 来调用前者）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(pImpl, other.pImpl);  <span class="comment">// 编译器将寻找适合的swap版本</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;                                <span class="comment">// template&lt;&gt; 表示全特化版本</span></span><br><span class="line">  <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp;b)    <span class="comment">// 针对Widget</span></span><br><span class="line">  &#123;</span><br><span class="line">    a.swap(b);                              <span class="comment">// 避免直接调用private成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 class templates (假设 Widget 和 WidgetImpl 都是 class templates)，还是声明一个 non-member swap 让它调用 member swap，但不再将那个 non-member swap 声明为 std::swap 的特化版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff               <span class="comment">// 不在std里</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;;</span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp;a, Widget&lt;T&gt;&amp;b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++只允许对 class templates 偏特化，不允许偏特化一个 function template。</p>
</li>
<li><p>调用 swap 时应使用 <code>using std::swap;</code> 使标准库版本曝光，然后不带任何命名空间资格修饰地调用 swap。</p>
</li>
<li><p><strong>成员版本 swap 绝不可抛出异常</strong>，因为 swap 的一个最好的应用是帮助 classes 和 class templates 提供强烈的异常安全性保障。 swap 的缺省版本时以 copying 为基础的，一般情况下 copy 构造和copy assignment 操作符都允许抛出异常。因此当写下一个自定义版本的 swap，往往提供的不只是高效置换对象的办法，而且不抛出异常。</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="26-尽可能延后变量定义式的出现时间"><a href="#26-尽可能延后变量定义式的出现时间" class="headerlink" title="26. 尽可能延后变量定义式的出现时间"></a>26. 尽可能延后变量定义式的出现时间</h3><ul>
<li><p>定义变量需要承担一次构造函数和一次析构函数的时间。假如该变量未被使用，那么构造函数和析构函数的时间就白白浪费了。尤其是在可能发生异常的函数中，假如你过早的定义变量，然后在你使用这个变量之前抛出了异常，那么这个变量的构造函数就没有意义而且降低效率。所以应该尽可能延后变量定义得时间，只有真正使用这个变量的时候才定义它。</p>
</li>
<li><p>不只应该延后变量定义直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止，这样可增加程序的清晰度并改善程序效率。</p>
</li>
<li><p>copy construction的效率 &gt; default construction + assign function，所以最好的做法是直接调用copy construction函数对变量直接进行初始化，而不是先定义，再赋值。</p>
</li>
</ul>
<h3 id="27-尽量少做转型动作"><a href="#27-尽量少做转型动作" class="headerlink" title="27. 尽量少做转型动作"></a>27. 尽量少做转型动作</h3><ul>
<li><p>C++提供4种新式转型：尽量使用新式转型替换旧式转型</p>
<ul>
<li><code>const_cast&lt;T&gt;()</code>：用来将对象的常量性转除。</li>
<li><code>dynamic_cast&lt;T&gt;()</code>：用来执行 “安全向下转型”，无法由旧式语法执行，但可能耗费重大运行成本。</li>
<li><code>reinterpret_cast&lt;T&gt;()</code>：执行低级转型，实际动作及结果可能取决于编译期，所以不可移植。例如将一个 pointer to int 转型为 int，很少见。</li>
<li><code>static_cast&lt;T&gt;()</code>：用来强迫隐式转换，比如将 non-const 对象转为 const 对象，将 int 转为 double 等。</li>
</ul>
</li>
<li><p>在注重效率的代码中避免 dynamic_cast，一般用虚函数的方式来避免转型。</p>
</li>
</ul>
<h3 id="28-避免返回-handles-指向对象内部成分"><a href="#28-避免返回-handles-指向对象内部成分" class="headerlink" title="28. 避免返回 handles 指向对象内部成分"></a>28. 避免返回 handles 指向对象内部成分</h3><p><strong>Reference、指针和迭代器都是所谓的handles。</strong></p>
<ul>
<li><p>如果返回一个 “代表对象内部数据” 的handle，就可以通过这个修改类内的 private 成员，带来降低对象封装性的风险。这一点可以通过给返回类型加 const 修饰符来防止内部成员变量被修改 (只让渡读取权，而禁止涂写权)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Point ulhc;  <span class="comment">// upper left-hand corner</span></span><br><span class="line">  Point lrhc;  <span class="comment">// lower right-hand corner</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外可能导致 <strong>dangling handles</strong> (handles 所指东西不再存在)。如果获得的类内的一个成员的handle，但在使用之前，对象被释放了，那么这个handle就指向一个不再存在的对象，handle也就变成虚吊的 (dangling)，会导致 core dump 错误。</p>
</li>
</ul>
<h3 id="29-为-“异常安全”-努力是值得的"><a href="#29-为-“异常安全”-努力是值得的" class="headerlink" title="29. 为 “异常安全” 努力是值得的"></a>29. 为 “异常安全” 努力是值得的</h3><p><strong>异常安全函数：即使发生异常也不会泄漏资源，不允许任何数据结构败坏。</strong></p>
<ul>
<li><p>异常安全函数提供以下三个保证之一：</p>
<ul>
<li>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。</li>
<li>强烈保证：如果异常被抛出，程序状态不改变。如果函数成功，就是完全成功；如果函数失败，程序会恢复到调用函数之前的状态。</li>
<li>不抛掷保证：承诺绝不抛出异常。</li>
</ul>
</li>
<li><p>强烈保证往往能够以 <strong>copy-and-swap</strong> 实现出来：为你打算修改的对象做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍然保持未改变状态。待所有改变都成功之后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换(swap)。但并非所有函数都可实现强烈保证，或不具备现实意义（拷贝效率较低）。</p>
<blockquote>
<p>[条例25](#25. 考虑写出一个不抛异常的 swap 函数) 有介绍 swap 的实现</p>
</blockquote>
</li>
<li><p>撰写新代码或修改旧码时，首先是 “<a href="#13-以对象管理资源">以对象管理资源</a>” 阻止资源泄漏，然后挑选三个 “异常安全保证” 中现实可实施的最强烈等级，将它实施于每一个函数身上。</p>
</li>
</ul>
<h3 id="30-透彻了解-inlining-的里里外外"><a href="#30-透彻了解-inlining-的里里外外" class="headerlink" title="30. 透彻了解 inlining 的里里外外"></a>30. 透彻了解 inlining 的里里外外</h3><ul>
<li><p>编译器最优化机制通常被设计用来浓缩那些 “不含函数调用” 的代码，所以当你 inline 某个函数，或许编译期就因此有能力对它执行语境相关最优化。</p>
</li>
<li><p>inline 函数背后的整体观念是：<strong>将对此函数的每一个调用，都以函数本体替换。</strong></p>
</li>
<li><p>明确声明 inline 函数的做法是在其定义式前加上关键字 inline，隐喻方法是将函数定义于 class 定义式内。</p>
</li>
<li><p><strong>inline 只是对编译器对一个申请，不是强制命令，</strong>大部分编译器拒绝太复杂（例如带有循环或者递归）的函数 inlining。</p>
</li>
<li><p>inline 函数通常只能放在头文件里，因为大多数建置环境 (build environments) 在编译过程中进行 inlining，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样。</p>
</li>
<li><p>templates 通常也只能放在头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样。但 template 的具现化和 inlining 无关，所以不要因为 function templates 出现在头文件就将它们声明为 inline。</p>
</li>
<li><p><strong>编译器通常拒绝将virtual 函数 inlining</strong>，因为 virtual 意味着 “等待，直到运行期才确定调用哪个函数”，而 inline 意味着 “执行前，先将调用动作替换为调用函数的本体”。</p>
</li>
<li><p>构造函数和析构函数也是 inlining 的糟糕候选人，即使它根本不含任何代码。因为C++对于 “对象被创建和被销毁时发生什么事” 做了各式各样的保证。当你创建一个对象时，其每一个 base class 及每一个成员变量都会被自动构造；当你销毁一个对象时，反向程序的析构行为亦会自动发生；如果有个异常在对象构造期间被抛出，该对象已构造好的那一部分会被自动销毁——这些都由编译器于编译期间自动产生的代码执行，这些代码有时候就放在构造函数和析构函数中。</p>
</li>
<li><p>inline 的弊端：</p>
<ul>
<li>可能造成程序体积太大</li>
<li>无法随着程序库的升级而升级：一旦需要改变一个 inline 函数 f，所有用到 f 的客户端程序都必须重新编译。（如果 f 是 non-inline 函数，客户端只需要重新连接就可以。如果采取动态链接，改动甚至可以不知不觉地被应用程序吸纳。）</li>
<li>难以调试（无法在一个并不存在的函数内设立断点）</li>
</ul>
</li>
</ul>
<h3 id="31-将文件间的编译依存关系降至最低"><a href="#31-将文件间的编译依存关系降至最低" class="headerlink" title="31. 将文件间的编译依存关系降至最低"></a>31. 将文件间的编译依存关系降至最低</h3><p>支持 ”编译依存性最小化“ 的一般构想是：依赖声明式，而不要依赖定义式。基于此构想的两个手段是 Handle classes 和 Interface classes。它们解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。</p>
<p>当然这两种方式都存在一定的代价：Handle classes 的实现要多分配指针大小的内存，每次访问都是间接访问。Interface classes 的实现方式要承担虚函数表的代价以及运行时的查找表的代价。但是一般这两种实现对资源和效率的影响通常不是最关键的，因此可以放心的使用，类似 tensorflow 源码中就大量使用这种方式降低编译依赖。</p>
<h4 id="Handle-Class"><a href="#Handle-Class" class="headerlink" title="Handle Class"></a>Handle Class</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person.hh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span>   <span class="comment">// 声明式，不需要include它的头文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>        // <span class="title">handle</span> <span class="title">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 因为是指针，编译器不需要知道PersonImpl的大小</span></span><br><span class="line">  <span class="comment">// 只需要分配指针需要的内存</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; impl_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person_impl.hh</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>  // 实现类，完成实际工作</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  PersonImpl(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) : name_(name) &#123;&#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.hh"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person_impl.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span><br><span class="line">  :impl_(<span class="built_in">std</span>::make_shared&lt;PersonImpl&gt;(name))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Person::name() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> impl_-&gt;name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像 Person 这样使用 <strong>pimpl idiom</strong> 的类，称为 <strong>Handle classes</strong>。它们将所有函数转交给相应的实现类并由后者完成实际工作。这样的调用并不会改变它做的事，只会改变它做事的方法。</p>
<p>此时 Person 类头文件只使用了实现类 (PersonImpl) 的声明式，所以实现类的任何变化并不会导致 Person 类头文件需要重新编译，因此所有只 include 了 person.hh 的文件也都不需要重新编译了，这样就大大降低了文件之间的编译依存关系。</p>
<h4 id="Interface-Class"><a href="#Interface-Class" class="headerlink" title="Interface Class"></a>Interface Class</h4><p>可以令 Person 成为一种特殊的 abstract base class，称为 <strong>Interface class</strong>。这种类的目的是详细一一描述 derived classes 的接口，因此它通常不带成员变量，也没有构造函数，<strong>只有一个虚析构函数以及一组纯虚函数</strong>，用来叙述整个接口。客户通过 <strong>factory 函数</strong> (或称为 virtual 构造函数，往往在 interface class 内被声明为 static) 来为这种类创建新对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person.hh</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Person();</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// real_person.hh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  RealPerson(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name):name_(name) &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~RealPerson() &#123;&#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> cosnt </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.hh"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"real_person.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; Person::create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;RealPerson&gt;(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="32-确定你的-public-继承塑模出-is-a-关系"><a href="#32-确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="32. 确定你的 public 继承塑模出 is-a 关系"></a>32. 确定你的 public 继承塑模出 is-a 关系</h3><p>“public继承” 意味 is-a。适用于 base class 身上的每一件事情一定也适用于 derived class 身上，因为每一个 derived class 对象也都是一个 base class 对象。</p>
<h3 id="33-避免遮掩继承而来的名称"><a href="#33-避免遮掩继承而来的名称" class="headerlink" title="33. 避免遮掩继承而来的名称"></a>33. 避免遮掩继承而来的名称</h3><p>子类会遮掩父类同名的函数（这其实违反了 public 继承所暗示的 is-a 关系），可以使用 <strong>using 声明式</strong>或者<strong>inline转交函数</strong>避免。</p>
<h3 id="34-区分接口继承和实现继承"><a href="#34-区分接口继承和实现继承" class="headerlink" title="34. 区分接口继承和实现继承"></a>34. 区分接口继承和实现继承</h3><ul>
<li><p>接口继承和实现继承不同。</p>
<ul>
<li>pure virtual 函数只指定接口继承</li>
<li>impure virtual 函数指定接口继承和缺省实现继承</li>
<li>non-virtual 函数指定接口继承及强制实现继承</li>
</ul>
</li>
<li><p>将一个 impure virtual 函数拆成一个 pure virtual 函数 和一个 non-virtual 函数，可以实现接口和默认实现的分离。</p>
</li>
<li><p>pure virtual 函数可以拥有定义式，但调用它的唯一途径是调用时明确指出其 class 名称。通过这种方式也可以实现接口和默认实现分离，但是这样两者就无法拥有不同保护级别了。</p>
</li>
</ul>
<h3 id="35-考虑-virtual-函数以外的选择"><a href="#35-考虑-virtual-函数以外的选择" class="headerlink" title="35. 考虑 virtual 函数以外的选择"></a>35. 考虑 virtual 函数以外的选择</h3><p>讨论例子的原版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="由-non-virtual-interface-NVI-手法实现-template-method-模式"><a href="#由-non-virtual-interface-NVI-手法实现-template-method-模式" class="headerlink" title="由 non-virtual interface (NVI) 手法实现 template method 模式"></a>由 non-virtual interface (NVI) 手法实现 template method 模式</h4><p><strong>NVI 手法:</strong> 通过 public non-virtual 成员函数间接调用 private virtual 函数。这是所谓 <strong>template method</strong> 设计模式的一种独特表现形式。这种手法允许子类重新定义虚函数，从而赋予它们 ”如何实现机能“ 的控制能力， 但父类保留 ”函数如何被调用“ 的权利。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ...														<span class="comment">// pre-process</span></span><br><span class="line">    <span class="keyword">int</span> reVal = doHealthValue();  <span class="comment">// process</span></span><br><span class="line">    ...														<span class="comment">// post-process</span></span><br><span class="line">    <span class="keyword">return</span> reVal;</span><br><span class="line">  &#125;</span><br><span class="line"> 	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="由-function-pointers-实现-strategy-模式"><a href="#由-function-pointers-实现-strategy-模式" class="headerlink" title="由 function pointers 实现 strategy 模式"></a>由 function pointers 实现 strategy 模式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> class GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> <span class="comment">// 传入计算的函数指针</span></span></span><br><span class="line"> 		: healthFunc(hcf) &#123;&#125;                                         // 且有默认值</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">helthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> healFunc(*<span class="keyword">this</span>); &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  HealthCalcFunc helthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入函数指针替代虚函数，好处是可以进行运行期变更 (可以提供一个 setHealthCalcFunc 函数)，缺点是可能会牺牲封装性(需要声明non-member 的计算函数为 friend 以访问成员变量或将某一部分提供 public 访问函数)。</p>
<h4 id="由-tr1-function-完成-strategy-模式"><a href="#由-tr1-function-完成-strategy-模式" class="headerlink" title="由 tr1::function 完成 strategy 模式"></a>由 tr1::function 完成 strategy 模式</h4><p>将前者的函数指针改为一个类型为 tr1::function 的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原用函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tr1::function</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::tr1::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HEalthCalcFunc;</span><br></pre></td></tr></table></figure>

<p>目前这个签名式代表的函数是 “接受一个 reference 指向 const GameCharacter，并返回 int”。这个 tr1::function 类型产生的对象可以持有任何与此签名式兼容的可调用物 (函数指针/函数对象/成员函数指针)。所谓兼容，就是这个可调用物的参数可被隐式转换为 <code>const GameCharacter&amp;</code>，而其返回类型可被隐式转换为 <code>int</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下都是兼容的可调用物</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">calHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">GameCharacter <span class="title">gc1</span><span class="params">(calHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">GameCharacter <span class="title">gc2</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line"><span class="function">GameCharacter <span class="title">gc3</span><span class="params">(<span class="built_in">std</span>::tr1::bind(&amp;GameLevel::health, currentLevel, _1))</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="古典的-strategy-模式"><a href="#古典的-strategy-模式" class="headerlink" title="古典的 strategy 模式"></a>古典的 strategy 模式</h4><p>Strategy 设计模式的传统实现手法是：将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HealthCalcFunc 继承体系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> class GameCharacter&amp; gc)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowHealthLoser</span> :</span> <span class="keyword">public</span> HealthCalcFunc &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GameCharacter 继承体系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line">    : pHealthCalc(phcf) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pHealthCalc-&gt;clac(*<span class="keyword">this</span>); &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="36-绝不重新定义继承而来的-non-virtual-函数"><a href="#36-绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="36. 绝不重新定义继承而来的 non-virtual 函数"></a>36. 绝不重新定义继承而来的 non-virtual 函数</h3><p>绝对不要重新定义继承而来的 non-virtual 函数。non-virtual 在实现上是<strong>静态绑定</strong>的，调用父类还是子类的函数完全取决于指针或者对象的类型。在子类重定义 non-virtual 时，父类的相同的函数是不会被覆盖的。</p>
<h3 id="37-绝不重新定义继承而来的-virtual函数的-缺省参数值"><a href="#37-绝不重新定义继承而来的-virtual函数的-缺省参数值" class="headerlink" title="37. 绝不重新定义继承而来的(virtual函数的)缺省参数值"></a>37. 绝不重新定义继承而来的(virtual函数的)缺省参数值</h3><ul>
<li><p>virtual 函数是动态绑定 (后期绑定) 的，而缺省参数值是静态绑定 (前期绑定) 的。所以可能会 “调用一个定义于 devired class 内的 virtual 函数” 的同时，却使用 base class 为它制定的缺省参数值。</p>
</li>
<li><p>virtual 函数不应该带有缺省值，可以拆分成一个带有缺省值的 non-virtual 函数和一个不带缺省值的 virtual 函数，在前者内部调用后者，也就是条例35中介绍的[NVI 手法](#由 non-virtual interface (NVI) 手法实现 template method 模式)。</p>
</li>
</ul>
<h3 id="38-通过复合塑模出-has-a-或-“根据某物实现出”"><a href="#38-通过复合塑模出-has-a-或-“根据某物实现出”" class="headerlink" title="38. 通过复合塑模出 has-a 或 “根据某物实现出”"></a>38. 通过复合塑模出 has-a 或 “根据某物实现出”</h3><ul>
<li><p>复合是类型之间的一种关系，也就是某种类型的对象内含另一种类型的对象。</p>
</li>
<li><p>复合的意义和 public 继承完全不同。</p>
</li>
<li><p>在应用域 (程序中的对象相当于你所塑造的世界中的某些事物，如人、车辆等)，复合意味着 has-a。</p>
</li>
<li><p>在实现域 (实现细节上的人工制品，如缓冲区、互斥器、查找树等)，复合意味着 is-implemented-in-terms-of (根据某物实现出)。</p>
</li>
</ul>
<h3 id="39-明智而审慎地使用-private-继承"><a href="#39-明智而审慎地使用-private-继承" class="headerlink" title="39. 明智而审慎地使用 private 继承"></a>39. 明智而审慎地使用 private 继承</h3><ul>
<li>对于 private 继承关系，编译器不会自动将一个 derived class 对象转换为一个 base class 对象。</li>
<li>由 private base class 继承而来的所有成员，在 derived class 对象中都会变成 private 属性。</li>
<li>private 继承纯粹是一种实现技术，它意味着只有实现部分被继承，而接口部分应略去。</li>
<li>private 继承也意味着 is-implemented-in-terms-of。</li>
<li>尽可能使用复合，必要时才使用 private 继承。一般当 derived class 需要访问 base class 的 protected 成员时，或需要重新定义继承而来的 virtual 函数时，才选择使用 private 继承。</li>
<li>private 继承可以造成 empty base 最优化。</li>
</ul>
<h3 id="40-明智而审慎地使用多重继承"><a href="#40-明智而审慎地使用多重继承" class="headerlink" title="40. 明智而审慎地使用多重继承"></a>40. 明智而审慎地使用多重继承</h3><ul>
<li><p>多重继承 (multiple inheritance, MI) 的意思是继承一个以上的 base classes</p>
</li>
<li><p>可能导致歧义 (从多个基类中继承相同名称)，需要明确指出要调用的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorrowableItem</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectronicGadget</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3Player</span>:</span> <span class="keyword">public</span> BorrowableItem,</span><br><span class="line">								 <span class="keyword">public</span> ElectronicGadget</span><br><span class="line">&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.BorrowableItem::checkOut();  <span class="comment">// 明确指出要调用的函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可能导致要命的 “钻石型多重继承”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">File &lt;|-- InputFile</span><br><span class="line">File &lt;|-- OutputFile</span><br><span class="line">InputFile &lt;|-- IOFile</span><br><span class="line">OutputFile &lt;|-- IOFile</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了<strong>虚继承</strong>，使得在派生类中只保留一份间接基类的成员。虚继承的目的是让某个类做出声明，承诺愿意共享它的基类，被共享的基类就称为<strong>虚基类</strong>。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p>
</li>
<li><p>InputFile 和 OutputFile 必须采用虚继承，否则将导致 IOFile 类中保留两份 File 类的成员。</p>
</li>
<li><p>虚继承会增加大小、速度、初始化复杂度等成本。</p>
</li>
<li><p>多重继承可用于：public 继承某个 Interface class + private 继承某个协助实现的 class。</p>
</li>
</ul>
<h2 id="模版与范型编程"><a href="#模版与范型编程" class="headerlink" title="模版与范型编程"></a>模版与范型编程</h2><h3 id="41-了解隐式接口和编译期多态"><a href="#41-了解隐式接口和编译期多态" class="headerlink" title="41. 了解隐式接口和编译期多态"></a>41. 了解隐式接口和编译期多态</h3><ul>
<li>面对对象编程总是以显式接口和运行时多态来解决问题，而在templates及泛型编程的世界中，隐式接口和编译期多态则更重要。</li>
<li>显式接口由函数的签名式 (也就是函数名称、参数类型、返回类型)构成。</li>
<li>隐式接口则并不基于函数签名式，而是由有效表达式组成。T 必须支持哪一组接口，由 template 中执行于 T 身上的操作来决定。</li>
<li>编译期多态：以不同的 template 参数具现化 function templates，会导致调用不同的函数 (函数重载解析)，而这样的具现行为发生在编译期。</li>
</ul>
<h3 id="42-了解-typename-的双重意义"><a href="#42-了解-typename-的双重意义" class="headerlink" title="42. 了解 typename 的双重意义"></a>42. 了解 typename 的双重意义</h3><ul>
<li><p>用于声明 template 类型参数时，class 和 typename 的意义完全相同，可以互换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Widget</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>template 内出现的名称如果相依于某个 template 参数，那么这个名称称为从属名称 (dependent names)；如果从属名称在 calss 内呈嵌套状，则称为嵌套从属名称 (nasted dependent names)；而不依赖于任何template 参数的名称称为非从属名称 (non-dependent names)。</p>
</li>
<li><p>编译器在 template 中遇到嵌套从属名称时，将<strong>默认此名称不是一个类型</strong> (比如 <code>T::iterator</code> 有可能是个静态变量或者T namespace中的变量)，除非我们用关键字 <strong>typename</strong> 指明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> T&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (container.size() &gt;= <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 用typename说明T::const_iterator是一个类型</span></span><br><span class="line">    <span class="keyword">typename</span> T::<span class="function">const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的<strong>继承列表</strong>和<strong>初始化列表</strong>中的类型不需要 typename 指定类型，因为继承的一定是一个类，而初始化列表一定是调用父类的构造或者初始化某个成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested         <span class="comment">// 继承列表: 不需要typename</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  explict Derived(int x) : Base&lt;T&gt;::Nested(x) // 初始化列表: 不需要typename</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;            <span class="comment">// 需要用typename</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配合 <strong>typedef</strong>使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">  <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="43-学习处理模版化基类内的名称"><a href="#43-学习处理模版化基类内的名称" class="headerlink" title="43. 学习处理模版化基类内的名称"></a>43. 学习处理模版化基类内的名称</h3><p>在 <code>derived class templates</code> 内直接调用 <code>base class</code> 函数将无法通过编译。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      print();    <span class="comment">// 调用base class函数，无法通过编译</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是由于 <code>base class templates</code> 有可能被特化，而那个特化版本可能并不提供和一般性 <code>template</code> 相同的接口，因此编译器拒绝在 <code>templatized base classes</code> 内寻找继承而来的名称 (例子中的 <code>print</code> )。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果针对ClassA产生一个Base特化版，它可以不提供某些一般性的接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;ClassA&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//  沒有提供 print()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有3种方式使其进入<code>templatized base classes</code> 内寻找（实际上都是对编译器承诺 base class template 的任何特化版本都将支持一般版本所提供的接口，如果后续使用时违反此承诺仍将无法通过编译）：</p>
<ol>
<li><p><code>this-&gt;</code> 调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;print();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>using</code> 声明式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> Base&lt;T&gt;::print;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      print();    <span class="comment">// 调用base class函数，无法通过编译</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>明确指出被调用的函数位于 <code>base class</code> 内</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base&lt;T&gt;::print();</span><br></pre></td></tr></table></figure>

<p>但这种方式由于需要明确资格修饰，无法进行 <code>virtual</code> 绑定。</p>
</li>
</ol>
<h3 id="44-将与参数无关的代码抽离-templates"><a href="#44-将与参数无关的代码抽离-templates" class="headerlink" title="44. 将与参数无关的代码抽离 templates"></a>44. 将与参数无关的代码抽离 templates</h3><ul>
<li>Templates 会根据具体类型具像化多份代码，如果将与模板无关的代码也放入模板函数或者类中，可能会导致代码膨胀：其二进制码带着重复的代码/数据。</li>
<li>任何template代码都不应该与某个造成膨胀的template参数产生相依关系。</li>
<li>在 non-template 代码中，重复十分明确，你可以明显看到两个函数或两个 classes 之间有所重复；但在 template 代码中，重复往往是隐晦的，因为只存在一份 template 源码，当 template 被具现化多次时却可能发生重复。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型参数T 非类型参数n</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>,<span class="number">5</span>&gt; sm1;</span><br><span class="line">sm1.invert();</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>,<span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.invert();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码具现化了两份invert函数，它们并非完全重复，因为其中一个操作的是5*5的矩阵而另一个操作的是10*10的矩阵，但除了常量5和10，两个函数的其他部分完全相同。这就造成了代码膨胀。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数模板中与参数无关的代码可以包装成单独的函数，类模板中与参数无关的模板可以放到父类中。</p>
</li>
<li><p>因非类型模版参数而造成的代码膨胀，往往可以用函数参数或class成员变量替换template参数来消除。</p>
</li>
<li><p>因类型参数而造成的代码膨胀，往往可以通过带有完全相同二进制表述的具现类型共享实现码来降低。比如 <code>list&lt;int*&gt;</code> , <code>list&lt;const int*&gt;</code> 等使用指针的情况，往往应该对每个成员函数使用唯一一份底层实现。所以，对于操作强型指针 ( <code>T*</code> ) 的成员函数，应该让它们调用另一个操作无类型指针 (void *) 的函数，由后者来完成实际工作。</p>
</li>
</ul>
<h3 id="45-运用成员函数模版接受所有兼容类型"><a href="#45-运用成员函数模版接受所有兼容类型" class="headerlink" title="45. 运用成员函数模版接受所有兼容类型"></a>45. 运用成员函数模版接受所有兼容类型</h3><h3 id="46-需要类型转换时请为模版定义非成员函数"><a href="#46-需要类型转换时请为模版定义非成员函数" class="headerlink" title="46. 需要类型转换时请为模版定义非成员函数"></a>46. 需要类型转换时请为模版定义非成员函数</h3><h3 id="47-请使用-traits-classes-表现类型信息"><a href="#47-请使用-traits-classes-表现类型信息" class="headerlink" title="47. 请使用 traits classes 表现类型信息"></a>47. 请使用 traits classes 表现类型信息</h3><h3 id="48-认识-template-元编程"><a href="#48-认识-template-元编程" class="headerlink" title="48. 认识 template 元编程"></a>48. 认识 template 元编程</h3><h2 id="定制-new-和-delete-暂时不做总结"><a href="#定制-new-和-delete-暂时不做总结" class="headerlink" title="定制 new 和 delete [暂时不做总结]"></a>定制 new 和 delete [暂时不做总结]</h2><h3 id="49-了解-new-handle-的行为"><a href="#49-了解-new-handle-的行为" class="headerlink" title="49. 了解 new-handle 的行为"></a>49. 了解 new-handle 的行为</h3><h3 id="50-了解-new-和-delete-的合理替换时机"><a href="#50-了解-new-和-delete-的合理替换时机" class="headerlink" title="50. 了解 new 和 delete 的合理替换时机"></a>50. 了解 new 和 delete 的合理替换时机</h3><h3 id="51-编写-new-和-delete-时需要固守常规"><a href="#51-编写-new-和-delete-时需要固守常规" class="headerlink" title="51. 编写 new 和 delete 时需要固守常规"></a>51. 编写 new 和 delete 时需要固守常规</h3><h3 id="52-写了-placement-new-也要写-placement-delete"><a href="#52-写了-placement-new-也要写-placement-delete" class="headerlink" title="52. 写了 placement new 也要写 placement delete"></a>52. 写了 placement new 也要写 placement delete</h3><h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2><h3 id="53-不要轻忽编译期的警告"><a href="#53-不要轻忽编译期的警告" class="headerlink" title="53. 不要轻忽编译期的警告"></a>53. 不要轻忽编译期的警告</h3><h3 id="54-让自己熟悉包括-TR1-在内的标准程序库"><a href="#54-让自己熟悉包括-TR1-在内的标准程序库" class="headerlink" title="54. 让自己熟悉包括 TR1 在内的标准程序库"></a>54. 让自己熟悉包括 TR1 在内的标准程序库</h3><h3 id="55-让自己熟悉boost"><a href="#55-让自己熟悉boost" class="headerlink" title="55. 让自己熟悉boost"></a>55. 让自己熟悉boost</h3>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像处理1-使用高通滤波进行边缘检测</title>
    <url>/image-processing-high-pass-filter.html</url>
    <content><![CDATA[<h2 id="高通滤波-通常使用来检测边缘"><a href="#高通滤波-通常使用来检测边缘" class="headerlink" title="高通滤波: 通常使用来检测边缘"></a>高通滤波: 通常使用来检测边缘</h2><h3 id="常见算子"><a href="#常见算子" class="headerlink" title="常见算子"></a>常见算子</h3><h5 id="sobel算子"><a href="#sobel算子" class="headerlink" title="sobel算子"></a>sobel算子</h5><p><img src="image-processing-high-pass-filter/math-1.png" alt="math-1"></p><h5 id="Scharr算子-更敏感-细致"><a href="#Scharr算子-更敏感-细致" class="headerlink" title="Scharr算子 (更敏感/细致)"></a>Scharr算子 (更敏感/细致)</h5><p><img src="image-processing-high-pass-filter/math-2.png" alt="math-2"></p><h5 id="Laplacian-拉普拉斯-算子-对噪声较敏感，一般搭配其他操作"><a href="#Laplacian-拉普拉斯-算子-对噪声较敏感，一般搭配其他操作" class="headerlink" title="Laplacian(拉普拉斯)算子 (对噪声较敏感，一般搭配其他操作)"></a>Laplacian(拉普拉斯)算子 (对噪声较敏感，一般搭配其他操作)</h5><p><img src="image-processing-high-pass-filter/math-3.png" alt="math-3"></p><h3 id="具体代码例子"><a href="#具体代码例子" class="headerlink" title="具体代码例子"></a>具体代码例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the image</span></span><br><span class="line">image = cv2.imread(<span class="string">'images/curved_lane.jpg'</span>)</span><br><span class="line">image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)</span><br><span class="line"></span><br><span class="line">f, (p1, p2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">p1.set_title(<span class="string">'original img'</span>)</span><br><span class="line">p1.imshow(image)</span><br><span class="line"></span><br><span class="line">p2.set_title(<span class="string">'gray img'</span>)</span><br><span class="line">p2.imshow(gray, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a>




<p><img src="image-processing-high-pass-filter/1.png" alt="1"></p>
<h5 id="自定义filter"><a href="#自定义filter" class="headerlink" title="自定义filter"></a>自定义filter</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a custom kernel</span></span><br><span class="line"><span class="comment"># 3x3 array for edge detection</span></span><br><span class="line"></span><br><span class="line">sobel_x= np.array([[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                   [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">sobel_y= np.array([[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>],</span><br><span class="line">                   [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># laplacian, edge filter</span></span><br><span class="line">laplacian=np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">1</span>,<span class="number">-4</span>, <span class="number">1</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<h5 id="单向filter"><a href="#单向filter" class="headerlink" title="单向filter"></a>单向filter</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Filter the image using filter2D, which has inputs: (grayscale image, bit-depth, kernel)  </span></span><br><span class="line">filtered_x_image = cv2.filter2D(gray, <span class="number">-1</span>, sobel_x)</span><br><span class="line">filtered_y_image = cv2.filter2D(gray, <span class="number">-1</span>, sobel_y)</span><br><span class="line"></span><br><span class="line">f, (p1, p2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">p1.set_title(<span class="string">'filtered x'</span>)</span><br><span class="line">p1.imshow(filtered_x_image, cmap=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">p2.set_title(<span class="string">'filtered y'</span>)</span><br><span class="line">p2.imshow(filtered_y_image, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-high-pass-filter/2.png" alt="2"></p>
<h5 id="双向filter"><a href="#双向filter" class="headerlink" title="双向filter"></a>双向filter</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sobel_x_img = cv2.filter2D(gray, cv2.CV_64F, sobel_x) <span class="comment"># CV_64F 可含负数</span></span><br><span class="line">sobel_y_img = cv2.filter2D(gray, cv2.CV_64F, sobel_y)</span><br><span class="line"></span><br><span class="line">sobel_x_img = cv2.convertScaleAbs(sobel_x_img)   <span class="comment"># 将负数取绝对值</span></span><br><span class="line">sobel_y_img = cv2.convertScaleAbs(sobel_y_img)</span><br><span class="line"></span><br><span class="line">f, (p1, p2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">p1.set_title(<span class="string">'sobel_x_img'</span>)</span><br><span class="line">p1.imshow(sobel_x_img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">p2.set_title(<span class="string">'sobel_y_img'</span>)</span><br><span class="line">p2.imshow(sobel_y_img, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-high-pass-filter/7.png" alt="7"></p>
<p>通过和上面的结果对比，可以发现，上面的结果是单向的，而下面的结果是双向的。这是由于直接使用算子滤波时会<strong>产生负数</strong>，而在超出 <code>0-255</code> 范围时<strong>被截取</strong>。这也是为什么在下面的处理过程中需要<strong>先转换成 <code>CV_64F</code> (含负数) 的格式后，再取绝对值</strong>。</p>
<h5 id="使用现成的接口"><a href="#使用现成的接口" class="headerlink" title="使用现成的接口"></a>使用现成的接口</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 也可以直接使用 cv2.Sobel，效果一致</span></span><br><span class="line"><span class="comment"># dst = cv2.Sobel(src, ddepth, dx, dy, ksize)</span></span><br><span class="line"><span class="comment"># ddepth: depth of image</span></span><br><span class="line"><span class="comment"># dx, dy: 0/1, 指定方向 </span></span><br><span class="line"><span class="comment"># ksize: kernal size</span></span><br><span class="line"></span><br><span class="line">sobel_x_img = cv2.Sobel(gray, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>) </span><br><span class="line">sobel_x_img = cv2.convertScaleAbs(sobel_x_img)</span><br><span class="line">sobel_y_img = cv2.Sobel(gray, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobel_y_img = cv2.convertScaleAbs(sobel_y_img)</span><br></pre></td></tr></table></figure>

<h5 id="合并不同方向"><a href="#合并不同方向" class="headerlink" title="合并不同方向"></a>合并不同方向</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># combine x and y</span></span><br><span class="line">sobel_img = cv2.addWeighted(sobel_x_img, <span class="number">0.5</span>, sobel_y_img, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line">plt.imshow(sobel_img, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-high-pass-filter/8.png" alt="8"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># not that good to compute xy together directly</span></span><br><span class="line">sobel_xy_img = cv2.Sobel(gray, cv2.CV_64F, <span class="number">1</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobel_xy_img = cv2.convertScaleAbs(sobel_xy_img)</span><br><span class="line">plt.imshow(sobel_xy_img, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-high-pass-filter/9.png" alt="9"></p>
<p>很明显，<strong>分别计算 x 和 y 再求和的效果比一次性计算的效果要好很多</strong>。</p>
<h5 id="不同算子的结果对比："><a href="#不同算子的结果对比：" class="headerlink" title="不同算子的结果对比："></a>不同算子的结果对比：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scharr_x_img = cv2.Scharr(gray, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">scharr_y_img = cv2.Scharr(gray, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">scharr_x_img = cv2.convertScaleAbs(scharr_x_img)</span><br><span class="line">scharr_y_img = cv2.convertScaleAbs(scharr_y_img)</span><br><span class="line">scharr_img = cv2.addWeighted(scharr_x_img, <span class="number">0.5</span>, scharr_y_img, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">laplacian_img = cv2.Laplacian(gray, cv2.CV_64F)</span><br><span class="line">laplacian_img = cv2.convertScaleAbs(laplacian_img)</span><br><span class="line"></span><br><span class="line">f, (p1, p2, p3) = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">p1.set_title(<span class="string">'sobel'</span>)</span><br><span class="line">p1.imshow(sobel_filtered_img, cmap=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">p2.set_title(<span class="string">'scharr'</span>)</span><br><span class="line">p2.imshow(scharr_img, cmap=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">p3.set_title(<span class="string">'laplacian'</span>)</span><br><span class="line">p3.imshow(laplacian_img, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-high-pass-filter/10.png" alt="10"></p>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>cv</tag>
        <tag>opencv</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu环境下安装使用hexo</title>
    <url>/install-hexo.html</url>
    <content><![CDATA[<h2 id="Install-Git"><a href="#Install-Git" class="headerlink" title="Install Git"></a>Install Git</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail@domain.com"</span></span><br></pre></td></tr></table></figure><h2 id="Configure-Firewall"><a href="#Configure-Firewall" class="headerlink" title="Configure Firewall"></a>Configure Firewall</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ufw</span><br><span class="line">sudo ufw allow <span class="string">"OpenSSH"</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span></span><br><span class="line">sudo ufw allow http</span><br><span class="line">sudo ufw allow https</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>Check the firewall status.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">-                          --          --</span><br><span class="line">OpenSSH                    ALLOW       Anywhere                  </span><br><span class="line">4000                       ALLOW       Anywhere                  </span><br><span class="line">80/tcp                     ALLOW       Anywhere                  </span><br><span class="line">443                        ALLOW       Anywhere                  </span><br><span class="line">OpenSSH (v6)               ALLOW       Anywhere (v6)             </span><br><span class="line">4000 (v6)                  ALLOW       Anywhere (v6)             </span><br><span class="line">80/tcp (v6)                ALLOW       Anywhere (v6)             </span><br><span class="line">443 (v6)                   ALLOW       Anywhere (v6)</span><br></pre></td></tr></table></figure>

<h2 id="Install-nodejs-via-nvm"><a href="#Install-nodejs-via-nvm" class="headerlink" title="Install nodejs via nvm"></a>Install <code>nodejs</code> via <code>nvm</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># installs NVM (Node Version Manager)</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash</span><br><span class="line"><span class="comment"># download and install Node.js</span></span><br><span class="line">nvm install 20</span><br><span class="line"><span class="comment"># verifies the right Node.js version is in the environment</span></span><br><span class="line">node -v <span class="comment"># should print `v20.11.1`</span></span><br><span class="line"><span class="comment"># verifies the right NPM version is in the environment</span></span><br><span class="line">npm -v <span class="comment"># should print `10.2.4`</span></span><br></pre></td></tr></table></figure>

<h2 id="Install-hexo"><a href="#Install-hexo" class="headerlink" title="Install hexo"></a>Install <code>hexo</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="Init-the-hexo-blog"><a href="#Init-the-hexo-blog" class="headerlink" title="Init the hexo blog"></a>Init the hexo blog</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir blog  <span class="comment"># create the blog folder</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像处理2-使用低通滤波进行去噪</title>
    <url>/image-processing-low-pass-filter.html</url>
    <content><![CDATA[<h2 id="低通滤波-通常使用来去噪"><a href="#低通滤波-通常使用来去噪" class="headerlink" title="低通滤波: 通常使用来去噪"></a>低通滤波: 通常使用来去噪</h2><h3 id="常见滤波类型"><a href="#常见滤波类型" class="headerlink" title="常见滤波类型"></a>常见滤波类型</h3><h5 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h5><p><img src="image-processing-low-pass-filter/math-4.png" alt="math-4"></p><h5 id="高斯滤波-权重与距离相关"><a href="#高斯滤波-权重与距离相关" class="headerlink" title="高斯滤波 (权重与距离相关)"></a>高斯滤波 (权重与距离相关)</h5><p><img src="image-processing-low-pass-filter/math-5.png" alt="math-5"></p><h5 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h5><p>顾名思义取中值</p><h3 id="具体代码例子"><a href="#具体代码例子" class="headerlink" title="具体代码例子"></a>具体代码例子</h3><h5 id="高斯的模糊-去噪效果"><a href="#高斯的模糊-去噪效果" class="headerlink" title="高斯的模糊/去噪效果"></a>高斯的模糊/去噪效果</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read in the image</span></span><br><span class="line">image = cv2.imread(<span class="string">'images/brain_MR.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert to grayscale for filtering</span></span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a Gaussian blurred image</span></span><br><span class="line">gray_blur = cv2.GaussianBlur(gray, (<span class="number">9</span>, <span class="number">9</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use custom kernal</span></span><br><span class="line"><span class="comment"># gaussian = (1/16)*np.array([[1, 2, 1],</span></span><br><span class="line"><span class="comment">#                            [2, 4, 2],</span></span><br><span class="line"><span class="comment">#                            [1, 2, 1]])</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># gray_blur = cv2.filter2D(gray, -1, gaussian)</span></span><br><span class="line"></span><br><span class="line">f, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">ax1.set_title(<span class="string">'original gray'</span>),ax1.imshow(gray, cmap=<span class="string">'gray'</span>)</span><br><span class="line">ax2.set_title(<span class="string">'blurred image'</span>),ax2.imshow(gray_blur, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a>




<p><img src="image-processing-low-pass-filter/3.png" alt="3"></p>
<h5 id="与高通滤波配合"><a href="#与高通滤波配合" class="headerlink" title="与高通滤波配合"></a>与高通滤波配合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Filter the orginal and blurred grayscale images using filter2D</span></span><br><span class="line">filtered = cv2.filter2D(gray, <span class="number">-1</span>, sobel_y)</span><br><span class="line">filtered_blurred = cv2.filter2D(gray_blur, <span class="number">-1</span>, sobel_y)</span><br><span class="line"></span><br><span class="line">f, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">ax1.set_title(<span class="string">'original &amp; filtered imnage'</span>),ax1.imshow(filtered, cmap=<span class="string">'gray'</span>)</span><br><span class="line">ax2.set_title(<span class="string">'blurred &amp; filtered image'</span>),ax2.imshow(filtered_blurred, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-low-pass-filter/4.png" alt="4"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">retval, binary_image = cv2.threshold(filtered_blurred, <span class="number">50</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">plt.imshow(binary_image, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-low-pass-filter/5.png" alt="5"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filtered_blurred = cv2.filter2D(gray_blur, <span class="number">-1</span>, laplacian)</span><br><span class="line">retval, binary_image = cv2.threshold(filtered_blurred, <span class="number">5</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">plt.imshow(binary_image, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="image-processing-low-pass-filter/6.png" alt="6"></p>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>cv</tag>
        <tag>opencv</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV Mat像素的遍历方法</title>
    <url>/mat-traverse.html</url>
    <content><![CDATA[<h2 id="OpenCV像素遍历常用的几种方法"><a href="#OpenCV像素遍历常用的几种方法" class="headerlink" title="OpenCV像素遍历常用的几种方法"></a>OpenCV像素遍历常用的几种方法</h2><p>以从 organized 的点云提取 RGB 信息为例</p><h3 id="动态地址at"><a href="#动态地址at" class="headerlink" title="动态地址at"></a>动态地址at</h3><p>基于Mat对象的随机像素访问 API 实现，通过行列索引方式遍历每个像素值。这种方法速度较慢，不太适合用于像素遍历。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract_1</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt;::Ptr cloud, cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_height = cloud-&gt;height;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_width = cloud-&gt;width;</span><br><span class="line"></span><br><span class="line">  image = cv::Mat(cv::Size(cloud_width, cloud_height), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> row = <span class="number">0</span>; row &lt; cloud_height; row++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> col = <span class="number">0</span>; col &lt; cloud_width; col++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> index = row * cloud_width + col;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pt = cloud-&gt;points[index];</span><br><span class="line"></span><br><span class="line">      image.at&lt;cv::Vec3b&gt;(row, col)[<span class="number">0</span>] = pt.b;</span><br><span class="line">      image.at&lt;cv::Vec3b&gt;(row, col)[<span class="number">1</span>] = pt.g;</span><br><span class="line">      image.at&lt;cv::Vec3b&gt;(row, col)[<span class="number">2</span>] = pt.r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h3 id="行指针"><a href="#行指针" class="headerlink" title="行指针"></a>行指针</h3><p>基于Mat对象的行随机访问指针方式实现对每个像素的遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract_2</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt;::Ptr cloud, cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_height = cloud-&gt;height;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_width = cloud-&gt;width;</span><br><span class="line"></span><br><span class="line">  image = cv::Mat(cv::Size(cloud_width, cloud_height), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> row = <span class="number">0</span>; row &lt; cloud_height; row++)</span><br><span class="line">  &#123;</span><br><span class="line">    cv::Vec3b *ptr = image.ptr&lt;cv::Vec3b&gt;(row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> col = <span class="number">0</span>; col &lt; cloud_width; col++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> index = row * cloud_width + col;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pt = cloud-&gt;points[index];</span><br><span class="line"></span><br><span class="line">      cv::Vec3b &amp;pixel = ptr[col];</span><br><span class="line">      pixel[<span class="number">0</span>] = pt.b;</span><br><span class="line">      pixel[<span class="number">1</span>] = pt.g;</span><br><span class="line">      pixel[<span class="number">2</span>] = pt.r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uchar-行指针"><a href="#uchar-行指针" class="headerlink" title="uchar 行指针"></a>uchar 行指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extract_3</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt;::Ptr cloud, cv::Mat &amp;image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_height = cloud-&gt;height;</span><br><span class="line">  <span class="keyword">auto</span> &amp;cloud_width = cloud-&gt;width;</span><br><span class="line"></span><br><span class="line">  image = cv::Mat(cv::Size(cloud_width, cloud_height), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> row = <span class="number">0</span>; row &lt; cloud_height; row++)</span><br><span class="line">  &#123;</span><br><span class="line">    uchar *uc_pixel = image.ptr(row);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> col = <span class="number">0</span>; col &lt; cloud_width; col++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> index = row * cloud_width + col;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pt = cloud-&gt;points[index];</span><br><span class="line"></span><br><span class="line">      uc_pixel[<span class="number">0</span>] = pt.b;</span><br><span class="line">      uc_pixel[<span class="number">1</span>] = pt.g;</span><br><span class="line">      uc_pixel[<span class="number">2</span>] = pt.r;</span><br><span class="line">      uc_pixel += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将图像完全展开"><a href="#将图像完全展开" class="headerlink" title="将图像完全展开"></a>将图像完全展开</h3><p>一般图像行与行之间往往存储是不连续的，但是有些图像可以是连续的，Mat提供了一个检测图像是否连续的函数<code>isContinuous()</code>。当图像连通时，我们就可以把图像完全展开，看成是一行进行处理。</p>
<h3 id="速度比较"><a href="#速度比较" class="headerlink" title="速度比较"></a>速度比较</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> cloud_path = <span class="string">"test.pcd"</span></span><br><span class="line">  pcl::PointCloud&lt;PointT&gt;::Ptr cloud(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;);</span><br><span class="line">  pcl_utils::load_pcd(cloud_path, *cloud);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *cloud &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  cv::Mat img_1;</span><br><span class="line">  extract_1(cloud, img_1);</span><br><span class="line">  <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  <span class="keyword">auto</span> elapsed_seconds = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(end - start);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line"></span><br><span class="line">  start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  cv::Mat img_2;</span><br><span class="line">  extract_2(cloud, img_2);</span><br><span class="line">  end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  elapsed_seconds = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(end - start);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line"></span><br><span class="line">  start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  cv::Mat img_3;</span><br><span class="line">  extract_3(cloud, img_3);</span><br><span class="line">  end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">  elapsed_seconds = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(end - start);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Load pcd file with 1228800 data points.</span><br><span class="line">header: seq: 0 stamp: 0 frame_id: </span><br><span class="line"></span><br><span class="line">points[]: 1228800</span><br><span class="line">width: 1280</span><br><span class="line">height: 960</span><br><span class="line">is_dense: 0</span><br><span class="line">sensor origin (xyz): [0, 0, 0] / orientation (xyzw): [0, 0, 0, 1]</span><br><span class="line"></span><br><span class="line">1 elapsed time: 0.0199077s</span><br><span class="line">2 elapsed time: 0.012727s</span><br><span class="line">3 elapsed time: 0.00880297s</span><br><span class="line">4 elapsed time: 0.00900436s</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>PCL点云的表示方式</title>
    <url>/pcl-cloud-types.html</url>
    <content><![CDATA[<h3 id="点云的表示方式"><a href="#点云的表示方式" class="headerlink" title="点云的表示方式"></a>点云的表示方式</h3><p>pcl里的点云多种表示方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const</span></span><br><span class="line">ConstCloudIterator&lt;PointT&gt; cloud_iterator;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;PointT&gt; cloud;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with indices</span></span><br><span class="line">pcl::PointCloud&lt;PointT&gt; cloud;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line"></span><br><span class="line"><span class="comment">// with indices</span></span><br><span class="line">pcl::PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">pcl::PointIndices indices;</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>几乎每个函数都配有这几种表示方式的 <code>template</code>，比如 <code>compute3DCentroid()</code> 会有对应的以下几种接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (ConstCloudIterator&lt;PointT&gt; &amp;cloud_iterator,</span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud, </span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud,</span><br><span class="line">                   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;indices, </span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud,</span><br><span class="line">                   <span class="keyword">const</span> pcl::PointIndices &amp;indices, </span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid);</span><br></pre></td></tr></table></figure>

<p>在这个特定例子里，<code>centroid</code> 也有多种的表示方式，所以模版数量很多，看起来有些让人眼花缭乱。</p>
<p>但实际上，它们的实现可能非常类似。比如，对比一下点云和带 <code>indices</code> 点云的接口的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud,</span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (cloud.empty ())</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize to 0</span></span><br><span class="line">  centroid.setZero ();</span><br><span class="line">  <span class="comment">// For each point in the cloud</span></span><br><span class="line">  <span class="comment">// If the data is dense, we don't need to check for NaN</span></span><br><span class="line">  <span class="keyword">if</span> (cloud.is_dense)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">    &#123;</span><br><span class="line">      centroid[<span class="number">0</span>] += point.x;</span><br><span class="line">      centroid[<span class="number">1</span>] += point.y;</span><br><span class="line">      centroid[<span class="number">2</span>] += point.z;</span><br><span class="line">    &#125;</span><br><span class="line">    centroid /= <span class="keyword">static_cast</span>&lt;Scalar&gt; (cloud.size ());</span><br><span class="line">    centroid[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; (cloud.size ()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NaN or Inf values could exist =&gt; check for them</span></span><br><span class="line">  <span class="keyword">unsigned</span> cp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Check if the point is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (!isFinite (point))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    centroid[<span class="number">0</span>] += point.x;</span><br><span class="line">    centroid[<span class="number">1</span>] += point.y;</span><br><span class="line">    centroid[<span class="number">2</span>] += point.z;</span><br><span class="line">    ++cp;</span><br><span class="line">  &#125;</span><br><span class="line">  centroid /= <span class="keyword">static_cast</span>&lt;Scalar&gt; (cp);</span><br><span class="line">  centroid[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (cp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud,</span><br><span class="line">                   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;indices,</span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (indices.empty ())</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize to 0</span></span><br><span class="line">  centroid.setZero ();</span><br><span class="line">  <span class="comment">// If the data is dense, we don't need to check for NaN</span></span><br><span class="line">  <span class="keyword">if</span> (cloud.is_dense)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; index : indices)</span><br><span class="line">    &#123;</span><br><span class="line">      centroid[<span class="number">0</span>] += cloud[index].x;</span><br><span class="line">      centroid[<span class="number">1</span>] += cloud[index].y;</span><br><span class="line">      centroid[<span class="number">2</span>] += cloud[index].z;</span><br><span class="line">    &#125;</span><br><span class="line">    centroid /= <span class="keyword">static_cast</span>&lt;Scalar&gt; (indices.size ());</span><br><span class="line">    centroid[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; (indices.size ()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NaN or Inf values could exist =&gt; check for them</span></span><br><span class="line">  <span class="keyword">unsigned</span> cp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; index : indices)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Check if the point is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (!isFinite (cloud [index]))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    centroid[<span class="number">0</span>] += cloud[index].x;</span><br><span class="line">    centroid[<span class="number">1</span>] += cloud[index].y;</span><br><span class="line">    centroid[<span class="number">2</span>] += cloud[index].z;</span><br><span class="line">    ++cp;</span><br><span class="line">  &#125;</span><br><span class="line">  centroid /= <span class="keyword">static_cast</span>&lt;Scalar&gt; (cp);</span><br><span class="line">  centroid[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (cp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，只有少数的几处有区别：</p>
<ul>
<li><p>开头判空</p>
<ul>
<li>cloud</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cloud.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>cloud with indices</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (indices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>for loop</p>
<ul>
<li>cloud</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>cloud with indices</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; index: indices)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// cloud[index]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而带 <code>pcl::PointIndics</code> 的接口则是直接调用了带 <code>std::vector&lt;int&gt;</code> 的接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud,</span><br><span class="line">                   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;indices,</span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud,</span><br><span class="line">                   <span class="keyword">const</span> pcl::PointIndices &amp;indices,</span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (pcl::compute3DCentroid (cloud, indices.indices, centroid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pcl</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>cv</tag>
        <tag>pcl</tag>
      </tags>
  </entry>
  <entry>
    <title>PCL类型转换</title>
    <url>/pcl_type_transform.html</url>
    <content><![CDATA[<h4 id="PCL相关类型-对象与指针互换"><a href="#PCL相关类型-对象与指针互换" class="headerlink" title="PCL相关类型 对象与指针互换"></a>PCL相关类型 对象与指针互换</h4><ol>
<li>pcl::PointIndices -&gt; pcl::PointIndices::Ptr</li>
</ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::<span class="function">Ptr <span class="title">inliers_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices(inliers))</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a>


<ol start="2">
<li>pcl::PointIndices::Ptr -&gt; pcl::PointIndices</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::Ptr inliers_ptr;</span><br><span class="line">inliers=*inliers_ptr;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>std::vector<int> -&gt; pcl::IndicesPtr</int></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_indices;</span><br><span class="line">pcl::IndicesPtr indices_ptr = boost::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(vec_indices);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>pcl::PointCloud<pointt> -&gt; pcl::PointCloud<pointt>::Ptr</pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud=*cloud_ptr;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>pcl::PointCloud<pointt>::Ptr -&gt; pcl::PointCloud<pointt></pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud_ptr=cloud.makeShared();</span><br></pre></td></tr></table></figure>

<h4 id="不同数据类型的点云转换"><a href="#不同数据类型的点云转换" class="headerlink" title="不同数据类型的点云转换"></a>不同数据类型的点云转换</h4><ol>
<li>pcl::PointCloud<a href="pcl::PointXYZRGB" target="_blank" rel="noopener">pcl::PointXYZRGB</a> -&gt; pcl::PointCloud<a href="pcl::PointXYZ" target="_blank" rel="noopener">pcl::PointXYZ</a>::Ptr</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="function">Ptr <span class="title">cloud_ori</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::copyPointCloud(*cloud_ori, *cloud);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pcl</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>pcl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 使用SCP远程拷贝文件</title>
    <url>/scp.html</url>
    <content><![CDATA[<p> 使用scp(secure copy)命令可以实现本地服务器和远程服务器之间的文件传输复制</p>
<a id="more"></a>



<h4 id="从本地复制到远程"><a href="#从本地复制到远程" class="headerlink" title="从本地复制到远程"></a>从本地复制到远程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder/test.txt</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder/test.txt</span><br></pre></td></tr></table></figure>

<h4 id="从远程复制到本地"><a href="#从远程复制到本地" class="headerlink" title="从远程复制到本地"></a>从远程复制到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp bot@10.0.9.211:/home/bot/test_folder text.txt</span><br><span class="line">scp bot@10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br></pre></td></tr></table></figure>

<h4 id="传输整个目录"><a href="#传输整个目录" class="headerlink" title="传输整个目录"></a>传输整个目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /test_folder bot@10.0.9.211:/home/bot/test_folder</span><br></pre></td></tr></table></figure>

<h4 id="其他参数用法"><a href="#其他参数用法" class="headerlink" title="其他参数用法"></a>其他参数用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>PCL提速的一些小细节</title>
    <url>/pcl-speed-up-notes.html</url>
    <content><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#1-替换-compute3dcentroid">1. 替换 compute3DCentroid</a><ul>
<li><a href="#pcl-里的源码">pcl 里的源码</a></li>
<li><a href="#自定义接口">自定义接口</a></li>
<li><a href="#关键点">关键点</a></li>
</ul>
</li>
<li><a href="#2-替换-getminmax3d">2. 替换 getMinMax3D</a><ul>
<li><a href="#自定义接口代码">自定义接口代码</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h3 id="1-替换-compute3DCentroid"><a href="#1-替换-compute3DCentroid" class="headerlink" title="1. 替换 compute3DCentroid"></a>1. 替换 compute3DCentroid</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Eigen::Vector4f pcaCentroid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写的 get_center()</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = get_center(*cloud, pcaCentroid);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ret: "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pcaCentroid[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; pcaCentroid[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; pcaCentroid[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span></span><br><span class="line">    &lt;&lt; pcaCentroid[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="keyword">auto</span> elapsed_seconds = <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(end - start);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"get_center elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pcl::compute3DCentroid()</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">ret = pcl::compute3DCentroid(*cloud, pcaCentroid);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ret: "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pcaCentroid[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; pcaCentroid[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; pcaCentroid[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span></span><br><span class="line">    &lt;&lt; pcaCentroid[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">elapsed_seconds = <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(end - start);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pcl::compute3DCentroid elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n\n"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="pcl-speed-up-notes/1.png" alt="1"></p>
<p>可以发现我自己写的接口结果与pcl自带的接口结果是一致的，但是耗时明显更短。</p>
<h5 id="pcl-里的源码"><a href="#pcl-里的源码" class="headerlink" title="pcl 里的源码"></a>pcl 里的源码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt; <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">compute3DCentroid (<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud,</span><br><span class="line">                   Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (cloud.empty ())</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize to 0</span></span><br><span class="line">  centroid.setZero ();</span><br><span class="line">  <span class="comment">// For each point in the cloud</span></span><br><span class="line">  <span class="comment">// If the data is dense, we don't need to check for NaN</span></span><br><span class="line">  <span class="keyword">if</span> (cloud.is_dense)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">    &#123;</span><br><span class="line">      centroid[<span class="number">0</span>] += point.x;</span><br><span class="line">      centroid[<span class="number">1</span>] += point.y;</span><br><span class="line">      centroid[<span class="number">2</span>] += point.z;</span><br><span class="line">    &#125;</span><br><span class="line">    centroid /= <span class="keyword">static_cast</span>&lt;Scalar&gt; (cloud.size ());</span><br><span class="line">    centroid[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; (cloud.size ()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// NaN or Inf values could exist =&gt; check for them</span></span><br><span class="line">  <span class="keyword">unsigned</span> cp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point: cloud)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Check if the point is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (!isFinite (point))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    centroid[<span class="number">0</span>] += point.x;</span><br><span class="line">    centroid[<span class="number">1</span>] += point.y;</span><br><span class="line">    centroid[<span class="number">2</span>] += point.z;</span><br><span class="line">    ++cp;</span><br><span class="line">  &#125;</span><br><span class="line">  centroid /= <span class="keyword">static_cast</span>&lt;Scalar&gt; (cp);</span><br><span class="line">  centroid[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (cp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义接口"><a href="#自定义接口" class="headerlink" title="自定义接口"></a>自定义接口</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT, <span class="keyword">typename</span> Scalar&gt;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_center</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt; &amp;cloud, Eigen::Matrix&lt;Scalar, <span class="number">4</span>, <span class="number">1</span>&gt; &amp;centroid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  centroid.setZero();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cloud.points.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> sz = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">float</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">float</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">float</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cloud.points.size(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pt = cloud.points[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::isnan(pt.x) || <span class="built_in">std</span>::isnan(pt.y) || <span class="built_in">std</span>::isnan(pt.z)) <span class="keyword">continue</span>;</span><br><span class="line">    x += pt.x;</span><br><span class="line">    y += pt.y;</span><br><span class="line">    z += pt.z;</span><br><span class="line">    ++sz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sz != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    centroid[<span class="number">0</span>] = x / sz;</span><br><span class="line">    centroid[<span class="number">1</span>] = y / sz;</span><br><span class="line">    centroid[<span class="number">2</span>] = z / sz;</span><br><span class="line">    centroid[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h5><p>两者代码其实非常相似，只有少数几处区别。多次对比后发现问题出在累加的地方：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----pcl----慢-----</span></span><br><span class="line">centroid[<span class="number">0</span>] += point.x;</span><br><span class="line">centroid[<span class="number">1</span>] += point.y;</span><br><span class="line">centroid[<span class="number">2</span>] += point.z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----自定义---快-----</span></span><br><span class="line">x += pt.x;</span><br><span class="line">y += pt.y;</span><br><span class="line">z += pt.z;</span><br></pre></td></tr></table></figure>

<p>只要将这几行代码替换，就可以复现pcl现成接口的耗时。猜测是因为，每次累加的时候，都需要进行矩阵的读写，导致效率低下。</p>
<h3 id="2-替换-getMinMax3D"><a href="#2-替换-getMinMax3D" class="headerlink" title="2. 替换 getMinMax3D"></a>2. 替换 getMinMax3D</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointT min_pt, max_pt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写的 compute_points_min_max()</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">pcl_utils::compute_points_min_max(*cloud, min_pt, max_pt);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; min_pt.x &lt;&lt; <span class="string">" "</span> &lt;&lt; min_pt.y &lt;&lt; <span class="string">" "</span> &lt;&lt; min_pt.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_pt.x &lt;&lt; <span class="string">" "</span> &lt;&lt; max_pt.y &lt;&lt; <span class="string">" "</span> &lt;&lt; max_pt.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">elapsed_seconds = <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(end - start);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"compute_points_min_max elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pcl::getMinMax3D()</span></span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">pcl::getMinMax3D(*cloud, min_pt, max_pt);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; min_pt.x &lt;&lt; <span class="string">" "</span> &lt;&lt; min_pt.y &lt;&lt; <span class="string">" "</span> &lt;&lt; min_pt.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_pt.x &lt;&lt; <span class="string">" "</span> &lt;&lt; max_pt.y &lt;&lt; <span class="string">" "</span> &lt;&lt; max_pt.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">elapsed_seconds = <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;(end - start);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pcl::getMinMax3D elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n\n"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="pcl-speed-up-notes/2.png" alt="2"></p>
<p>结果与pcl自带的接口结果是一致的，但是耗时更短。</p>
<h5 id="自定义接口代码"><a href="#自定义接口代码" class="headerlink" title="自定义接口代码"></a>自定义接口代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compute_points_min_max</span><span class="params">(<span class="keyword">const</span> Container&amp; pts_in, T&amp; min_pt_out,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   T&amp; max_pt_out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pts_in.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> first_ind = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!pcl::isFinite(pts_in[first_ind])) first_ind++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_ind &gt;= pts_in.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  min_pt_out = max_pt_out = pts_in[first_ind];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pts_in.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; pt = pts_in[i];</span><br><span class="line">    <span class="keyword">if</span> (!pcl::isFinite(pt)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pt.x &gt; max_pt_out.x)</span><br><span class="line">      max_pt_out.x = pt.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pt.x &lt; min_pt_out.x)</span><br><span class="line">      min_pt_out.x = pt.x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pt.y &gt; max_pt_out.y)</span><br><span class="line">      max_pt_out.y = pt.y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pt.y &lt; min_pt_out.y)</span><br><span class="line">      min_pt_out.y = pt.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pt.z &gt; max_pt_out.z)</span><br><span class="line">      max_pt_out.z = pt.z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pt.z &lt; min_pt_out.z)</span><br><span class="line">      min_pt_out.z = pt.z;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointT&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compute_points_min_max</span><span class="params">(<span class="keyword">const</span> pcl::PointCloud&lt;PointT&gt;&amp; cloud,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   PointT&amp; min_pt_out, PointT&amp; max_pt_out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> compute_points_min_max(cloud.points, min_pt_out, max_pt_out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pcl</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>cv</tag>
        <tag>pcl</tag>
        <tag>点云处理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ push_back和emplace_back的区别</title>
    <url>/push_back-emplace_back.html</url>
    <content><![CDATA[<blockquote>
<p><code>push_back()</code>向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中(如果是拷贝的话，事后会自行销毁先前创建的这个元素)。</p>
<p>而 <code>emplace_back()</code> 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p>
</blockquote><p>事实上，大多数情况下二者没有区别，只有在少数情况下 <code>emplace_back()</code> 效率更高。主要是 <code>emplace_back()</code> 支持 <code>in-place construction</code> 。</p><a id="more"></a>

<p>直接看下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestClass(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;b) : a_(a), b_(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  TestClass(<span class="keyword">const</span> TestClass &amp;other) : a_(other.a_), b_(other.b_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TestClass(TestClass &amp;&amp;other) : a_(other.a_), b_(<span class="built_in">std</span>::move(other.b_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~TestClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TestClass&gt; vec;</span><br><span class="line">  vec.reserve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">TestClass <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="string">"1"</span>)</span></span>;</span><br><span class="line">  <span class="function">TestClass <span class="title">t2</span><span class="params">(<span class="number">2</span>, <span class="string">"2"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n-----------------0---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(t1);</span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(t1);</span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------1---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t1));</span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t2));</span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------2----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------3----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>); <span class="comment">// in-place construction</span></span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------4----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">default constructor</span><br><span class="line"></span><br><span class="line">-----------------0---------------</span><br><span class="line">copy constructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line">destructor</span><br><span class="line">-----------------1---------------</span><br><span class="line">move constructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">move constructor</span><br><span class="line">destructor</span><br><span class="line">----------------2----------------</span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line">----------------3----------------</span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">destructor</span><br><span class="line">----------------4----------------</span><br><span class="line"></span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>

<p>从结果来看，只有直接调用构造有区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>push_back()</code> 会调用默认构造和移动构造，对应两次析构；而 <code>emplace_back()</code> 只调用一次默认构造一次析构， 效率更高。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：std::future的使用</title>
    <url>/std-future.html</url>
    <content><![CDATA[<p><code>std::future</code> 是C++11 的一个模板类，<strong>提供了一种用于访问异步操作结果的机制</strong>。可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。</p>
<p>设想这样的情况，你希望一个线程进行工作A，同时你在做一些其他的工作，你希望在某个特定的时间获取那个工作A的结果。在c++11，这个可以轻松被 <code>std::future</code> 实现。而由于它是一个模板类，可以返回任何类型的结果。</p>
<a id="more"></a>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;Result&gt; fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 进行别的工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取A的结果 </span></span><br><span class="line">Result result = fut.get();</span><br></pre></td></tr></table></figure>

<h4 id="用法说明"><a href="#用法说明" class="headerlink" title="用法说明"></a>用法说明</h4><p><code>std::future</code> 对象通常由某个 <code>Provider</code> 创建，你可以把 <code>Provider</code> 想象成一个异步任务的提供者，<code>Provider</code> 在某个线程中设置共享状态的值，与该共享状态相关联的 <code>std::future</code> 对象（通常在另外一个线程中）调用 <code>std::future::get()</code> 获取该值。如果共享状态的标志不为 <code>std::future_status::ready</code>，则调用 <code>get()</code> 会<strong>阻塞</strong>当前的调用者，直到 <code>Provider</code> 设置了共享状态的值，<code>get()</code> 返回异步任务的返回值或发生的异常。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>std::future</code> 的拷贝构造函数和普通赋值操作是被禁用的，只提供了默认的构造函数和 <code>move</code> 构造函数。默认构造函数构造的对象没有共享状态，因此它是无效的，但是可以通过移动赋值的方式将一个有效的<code>future</code> 值赋值给它。</p>
<p>一个有效的 <code>std::future</code> 对象通常由以下三种 <code>Provider</code> 创建，并和某个共享状态相关联。</p>
<ul>
<li><code>std::async()</code> 函数</li>
<li><code>std::promise::get_future()</code>，为 <code>promise</code> 类的成员函数</li>
<li><code>std::packaged_task::get_future()</code>，为 <code>packaged_task</code> 的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut;           <span class="comment">// 默认构造函数</span></span><br><span class="line">fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::async(test, <span class="number">1</span>));   <span class="comment">// move-赋值操作。</span></span><br></pre></td></tr></table></figure>

<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><p><code>bool valid()</code></p>
<p>检查共享状态的有效性，返回当前的 <code>future</code> 对象是否与共享状态关联。一旦调用了 <code>std::future::get()</code> 函数，再调用此函数将返回 <code>false</code> 。</p>
</li>
<li><p><code>void wait()</code></p>
<ul>
<li>等待共享状态就绪</li>
<li>如果共享状态尚未就绪(即未返回或发生异常)，则该函数将阻塞调用的线程直到就绪</li>
<li>当共享状态就绪后，则该函数将取消阻塞并void返回</li>
</ul>
</li>
<li><p><code>std::future_status wait_for(std::chrono::duration span)</code></p>
<ul>
<li>在指定的时间内等待共享状态就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到设置的时间</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="keyword">auto</span> future_status = fut.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; elapsed_seconds = end - start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waited for : "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result = fut.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waited for : 1.00856s</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>std::future_status wait_until(std::chrono::time_point point)</code></p>
<ul>
<li>在指定的时间点前等待共享状态准备就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到指定的时间点</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
</li>
<li><p><code>_Res get()</code></p>
<ul>
<li>当共享状态就绪时，返回存储在共享状态中的值(或抛出异常)</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪，相当于 <code>wait()</code> 再 <code>get()</code></li>
<li>当共享状态就绪后，则该函数将取消阻塞并返回释放其共享状态，这使得 <code>future</code> 对象不再有效，因此对于每一个 <code>future</code> 共享状态，<code>get()</code>函数最多应被调用一次</li>
<li><code>std::future&lt;void&gt;::get()</code> 不返回任何值，但仍等待共享状态就绪并释放它</li>
</ul>
</li>
<li><p><code>std::shared_future&lt;_Res&gt; share()</code></p>
<ul>
<li>返回一个 <code>std::shared_future</code> 对象，该对象获取 <code>future</code> 对象的共享状态。<code>future</code> 对象将不再有效。</li>
</ul>
</li>
</ul>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test()\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 sec later..\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting..\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -1-</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = <span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::future_status future_status = fut.wait_for(timeout);</span><br><span class="line">  <span class="keyword">if</span> (future_status != <span class="built_in">std</span>::future_status::ready)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 sec timeout!\n"</span>;</span><br><span class="line">    <span class="comment">// return -1;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -2-</span></span><br><span class="line">  fut.wait();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> result = fut.get();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nresult : "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="std-shared-future"><a href="#std-shared-future" class="headerlink" title="std::shared_future"></a><code>std::shared_future</code></h4><p><code>shared_future</code> 与 <code>future</code> 类似，但是允许多个线程等待同一个共享状态。 <code>shared_future</code> 既支持移动操作也支持拷贝操作，而且多个 <code>shared_future</code> 对象可以引用相同的共享状态，还允许多次检索共享状态下的值（多次调用 <code>get()</code> ）。</p>
<p><code>shared_future</code> 可以通过某个 <code>future</code> 对象隐式转换，或者通过 <code>std::future::share()</code> 显示转换，无论哪种转换，被转换的那个 <code>std::future</code> 对象都会变为 <code>not-valid</code>.</p>
<h4 id="std-launch"><a href="#std-launch" class="headerlink" title="std::launch"></a><strong>std::launch</strong></h4><p>该枚举类型主要是在调用<code>std::async</code> 设置异步任务的启动策略的。</p>
<p><code>std::async</code>的原型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async | <span class="built_in">std</span>::launch::deferred, f, args...)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>std::launch::async</code></p>
<p> 表示在调用<code>async</code>函数的时候就开始创建新线程。</p>
</li>
<li><p><code>std::launch::deferred</code></p>
<p>表示延迟调用，在调用 <code>future</code> 中的 <code>wait()</code> 或者 <code>get()</code> 函数时，才执行入口函数。（实际上，并没有创建新线程，只是在主线程中调用的入口函数）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async([]() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// deferred</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::vector的内存分配机制</title>
    <url>/std-vector_memory.html</url>
    <content><![CDATA[<blockquote>
<p><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector;</code></p>
</blockquote><h3 id="std-vector-简介"><a href="#std-vector-简介" class="headerlink" title="std::vector 简介"></a>std::vector 简介</h3><p><code>std::vector</code> 是C++标准库里封装好的<strong>动态大小数组</strong>的顺序容器，能够存放各种类型的对象。</p><p>与数组 <code>array</code> 一样， <code>vector</code> 的<strong>内存空间的地址是连续的</strong>。这意味着可以通过下标索引的方式获取到对应的元素，所以访问其元素的效率非常高，从其末端添加或删除元素的效率也相对较高。而对于涉及在非结束位置插入或删除元素的操作，它们的性能比其他操作差，效率较低。</p><a id="more"></a>


<p>但与<code>array</code>不同的是，它们的大小可以动态变化，它们的存储由容器自动处理。在插入新元素时，若当前容量不能够容纳新的元素，将自动重新申请一块更大的内存空间，将原有数据拷贝到新的内存空间，且释放原来的空间。这一过程非常耗时，为了避免频繁的内容分配， <code>vector</code> 不会在每次添加元素时都重新分配空间，而是分配一些额外的存储空间来容纳可能的增长。因此， <code>vector</code> 的实际容量 (<strong>capacity</strong>) 永远大于等于它容纳的元素大小 (<strong>size</strong>)。</p>
<h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><h4 id="1-自动增长策略"><a href="#1-自动增长策略" class="headerlink" title="1. 自动增长策略"></a>1. 自动增长策略</h4><p>假设元素是连续存储的，并且容器的大小是可变的，如果此时向 vector 中添加新的元素，容器不可能简单地将它添加到内存的其它位置，因为元素必须是连续存储的。</p>
<p>容器必须分配新的空间，来保存已有元素和新的元素，将已有的元素从旧位置移动到新空间。然后添加新元素，释放旧的存储空间。如果每添加一个元素，容器就执行一次内存分配和释放，性能会变得超级慢。</p>
<p>为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配的策略。当不得不获取新的空间的时候，<code>vector</code> 的实现，通常会分配比需求空间更大的内存空间。这种分配策略，比每次添加新元素后都重新分配容器内存空间的策略要高效的多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 0  size: 0</span><br><span class="line">2 vec capacity: 1  size: 1</span><br><span class="line">3 vec capacity: 2  size: 2</span><br><span class="line">4 vec capacity: 4  size: 3</span><br><span class="line">5 vec capacity: 4  size: 4</span><br><span class="line">6 vec capacity: 8  size: 5</span><br></pre></td></tr></table></figure>

<p>可以看出，每当 <code>size</code> 和 <code>capacity</code> 相等时，也就是无法容纳新的元素时，<code>vector</code> 自动申请了新的 (成倍增长的) 容量。</p>
<h4 id="2-手动分配内存-reserve-和-resize"><a href="#2-手动分配内存-reserve-和-resize" class="headerlink" title="2. 手动分配内存: reserve 和 resize"></a>2. 手动分配内存: reserve 和 resize</h4><p><code>std::vector</code> 有自动分配内存的机制，但我们也可以通过<code>reserve()</code> 和 <code>resize()</code> 来手动分配内存，使其效率更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ele</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ele: "</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : vec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 0</span><br><span class="line">2 vec capacity: 4  size: 4</span><br><span class="line">3 vec capacity: 4  size: 4</span><br><span class="line">ele: 1 2 3 4 </span><br><span class="line">4 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 4 0 </span><br><span class="line">5 vec capacity: 8  size: 3</span><br><span class="line">ele: 1 2 3 </span><br><span class="line">6 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 0 0</span><br></pre></td></tr></table></figure>

<p>可以看出：</p>
<ol>
<li><code>reserve()</code> 只增加不减少数组的 <code>capacity</code>，不对 <code>size()</code> 造成任何改变</li>
<li><code>resize()</code> 只增加不减少数组的 <code>capacity</code>，但可以增加和减少 <code>size</code>。减少时会直接移除多余的元素，增加时会填入默认值 (0)。</li>
</ol>
<h4 id="3-手动回收内存"><a href="#3-手动回收内存" class="headerlink" title="3. 手动回收内存"></a>3. 手动回收内存</h4><h5 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h5><p><code>erase()</code> 可以从 <code>vector</code> 中移除单个或一段元素 [begin, end)，实际上是以后面的元素移动并覆盖前面的位置，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin() + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin(), vec.begin() + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 5  size: 5</span><br><span class="line">2 vec capacity: 5  size: 4</span><br><span class="line">ele: 1 3 4 5 </span><br><span class="line">3 vec capacity: 5  size: 2</span><br><span class="line">ele: 4 5</span><br></pre></td></tr></table></figure>

<h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><p><code>clear()</code> 可以移除 <code>vector</code>所有元素，使容器<code>size</code> 为0，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 4</span><br><span class="line">2 vec capacity: 4  size: 0</span><br></pre></td></tr></table></figure>

<h5 id="shrink-to-fit-c-11"><a href="#shrink-to-fit-c-11" class="headerlink" title="shrink_to_fit (c++11)"></a>shrink_to_fit (c++11)</h5><p><code>shrink_to_fit()</code> 可以请求将内存减少到等于当前元素实际所使用的大小，也就是使 <code>capacity = size</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 10  size: 10</span><br><span class="line">2 vec capacity: 10  size: 1</span><br><span class="line">3 vec capacity: 1  size: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复git stash误删的内容</title>
    <url>/git-stash-dropped-by-coincidence.html</url>
    <content><![CDATA[<h2 id="恢复git-stash误删的内容"><a href="#恢复git-stash误删的内容" class="headerlink" title="恢复git stash误删的内容"></a>恢复git stash误删的内容</h2><p>不小心使用 <code>git drop stash</code> 误删了暂存的内容，怎么恢复？</p><p>其实drop后并没有真正删除暂存的内容，而是移除了对它的引用，所以通过一些操作是可以找回的。</p><h3 id="模拟误删场景"><a href="#模拟误删场景" class="headerlink" title="模拟误删场景"></a>模拟误删场景</h3><ul>
<li><p><code>git st</code> 查看当前修改</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    deleted:    calibration/adjust_result.json</span><br><span class="line">    modified:   calibration/config.json</span><br><span class="line">    modified:   calibration/src/rd_test.cc</span><br><span class="line">    modified:   pose_estimation/CMakeLists.txt</span><br><span class="line">    modified:   <span class="built_in">test</span>/CMakeLists.txt</span><br><span class="line">    modified:   <span class="built_in">test</span>/multiple_sensors.json</span><br><span class="line">    modified:   <span class="built_in">test</span>/src/test_multiple_sensors.cc</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash</code> 暂存修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Saved working directory and index state WIP on master: 4d74f8a fix spell</span><br><span class="line">HEAD is now at 4d74f8a fix spell</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash list</code> 查看暂存内容列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stash@&#123;0&#125;: WIP on master: 4d74f8a fix spell</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git stash drop stash@{0}</code> 移除暂存内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Dropped refs/stash@&#123;0&#125; (0b45536f1ce7e859a85f1459d6ae34fc6cdc4039)</span><br></pre></td></tr></table></figure>

</li>
</ul><a id="more"></a>


<p>至此已经把暂存的修改内容移除了</p>
<h3 id="恢复步骤"><a href="#恢复步骤" class="headerlink" title="恢复步骤"></a>恢复步骤</h3><h4 id="1-查找unreachable的记录"><a href="#1-查找unreachable的记录" class="headerlink" title="1. 查找unreachable的记录"></a>1. 查找unreachable的记录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fsck --unreachable</span><br><span class="line"><span class="comment"># git fsck --lost-found</span></span><br></pre></td></tr></table></figure>

<p><img src="git-stash-dropped-by-coincidence/1.png" alt="1"></p>
<p>可能会查找到几百条记录，截图了部分。这些记录有三种类型：blob、tree和commit。</p>
<blockquote>
<p>blob：每个blob代表一个版本的文件，blob只包含文件的数据，而忽略文件的其他元数据，如名字、路径、格式等。tags tag用于给某个上述类型的对象指配一个便于开发者记忆的名字, 通常用于某次commit。</p>
</blockquote>
<blockquote>
<p>tree：每个tree代表了一个目录的信息，包含了此目录下的blobs，子目录，文件名、路径等元数据。因此，对于有子目录的目录，git相当于存储了嵌套的trees。</p>
</blockquote>
<blockquote>
<p>commit：每个commit记录了提交一个更新的所有元数据，如指向的tree，父commit，作者、提交者、提交日期、提交日志等。每次提交都指向一个tree对象，记录了当次提交时的目录信息。一个commit可以有多个父commits。</p>
</blockquote>
<p>一般来说能用得上的是commit后跟的id，所以可以用 <code>grep</code> 过滤一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fsck --unreachable | grep commit</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (167/167), done.</span><br><span class="line">unreachable commit 32b865ecc5f2a0a924fac70bed3183d04e843c80</span><br><span class="line">unreachable commit e6c8f569f6a0b1614822bf57d5ed0a068fcba55d</span><br><span class="line">unreachable commit 692968cca20bcc1635dc18eaf91fd473cb8eaa25</span><br><span class="line">unreachable commit de39efe5ef0b54956fd747637ad9f2d879937ffc</span><br><span class="line">unreachable commit 437a84f0a8278b1e06bc6ddc580210a02752c757</span><br><span class="line">unreachable commit d372ccc53fb83ad5fd817fa438ba89c45269728d</span><br><span class="line">unreachable commit 69c3f6c907d8560359811939be1988a9599d5331</span><br><span class="line">unreachable commit 77bb1398679c8885d37999d19596fa67d5d1c33a</span><br><span class="line">unreachable commit 7d4b2ea272b62f656136207bd4ada0727308a416</span><br><span class="line">unreachable commit a8ebeb6316f84f2ff4593405fd9e6171c4e3fa06</span><br><span class="line">unreachable commit 9e24d0c4bfda86b4b0728f524b8e4e73bbde207b</span><br><span class="line">unreachable commit 150d9ae6ffa0273a8b500327e802a28d69450077</span><br><span class="line">unreachable commit 0b45536f1ce7e859a85f1459d6ae34fc6cdc4039</span><br><span class="line">unreachable commit a25da65d9a4167cee02357cb947c9900311fcf8b</span><br><span class="line">unreachable commit 14c66d8c765dd705ffdc8e229cb68abfd4bb579a</span><br><span class="line">unreachable commit 224e616a67dab617d481c90133ee3f9060db0893</span><br><span class="line">unreachable commit 5ede90fa7c81d74be1c2b5f180e875a968f47355</span><br><span class="line">unreachable commit 7dee291774f4b96c3a73f92de6bf8765e629b567</span><br></pre></td></tr></table></figure>

<h4 id="2-查看修改内容"><a href="#2-查看修改内容" class="headerlink" title="2. 查看修改内容"></a>2. 查看修改内容</h4><ul>
<li><p>查看完整修改内容</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show 32b865ecc5f2a0a924fac70bed3183d04e843c80</span><br></pre></td></tr></table></figure>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 32b865ecc5f2a0a924fac70bed3183d04e843c80</span><br><span class="line">Author: Tiffany Zhou &lt;xueying.zhou@dorabot.com&gt;</span><br><span class="line">Date:   Wed Nov 3 17:33:13 2021 +0800</span><br><span class="line"></span><br><span class="line">    index on feature/depalletizing: aa9d706 update <span class="keyword">for</span> dr_vision_lib</span><br><span class="line"></span><br><span class="line">diff --git a/include/pcl_utils/tree.hh b/include/pcl_utils/tree.hh</span><br><span class="line">index 11e46c1..ceb56be 100644</span><br><span class="line">--- a/include/pcl_utils/tree.hh</span><br><span class="line">+++ b/include/pcl_utils/tree.hh</span><br><span class="line">@@ -11,7 +11,7 @@ template &lt;typename PointT&gt;</span><br><span class="line"> inline void detect_change(const typename pcl::PointCloud&lt;PointT&gt;::Ptr &amp;based_cloud_ptr,</span><br><span class="line">                           const typename pcl::PointCloud&lt;PointT&gt;::Ptr &amp;scene_cloud_ptr,</span><br><span class="line">                           typename pcl::PointCloud&lt;PointT&gt;::Ptr &amp;cloud_diff_ptr,</span><br><span class="line">-                          <span class="built_in">float</span> resolution = 0.01f)</span><br><span class="line">+                          double resolution = 0.01)</span><br><span class="line"> &#123;</span><br><span class="line">   typename pcl::octree::OctreePointCloudChangeDetector&lt;PointT&gt; octree(resolution);</span><br><span class="line">   octree.setInputCloud(based_cloud_ptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看修改文件</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show 32b865ecc5f2a0a924fac70bed3183d04e843c80 --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Author: Tiffany Zhou &lt;xueying.zhou@dorabot.com&gt;</span><br><span class="line">Date:   Wed Nov 3 17:33:13 2021 +0800</span><br><span class="line"></span><br><span class="line">index on feature/depalletizing: aa9d706 update <span class="keyword">for</span> dr_vision_lib</span><br><span class="line"></span><br><span class="line">include/pcl_utils/tree.hh | 2 +-</span><br><span class="line">1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></code></pre><h4 id="3-找到误删的内容"><a href="#3-找到误删的内容" class="headerlink" title="3. 找到误删的内容"></a>3. 找到误删的内容</h4><p>那么很清晰了，查看每个unreachable commit的修改内容就能找到误删的stash。但是用得越久的repo，找出来的记录就越多，而且记录并不是按照时间来排序的，手动查看每个修改内容也太费时了。</p>
<p>我的方法是把所有记录复制到编辑器，将 “unreachable commit” 删除，只留下所有的id，存成文件，然后用简单脚本读取循环。</p>
<p><img src="git-stash-dropped-by-coincidence/2.png" alt="2"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cat unreachable.txt | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    git show <span class="variable">$line</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"------------------"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>如果能大概记得修改了哪些文件，可以用 <code>--stat | grep</code> ，比如这份暂存内容修改了 <code>test/src/test_multiple_sensors.cc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cat unreachable.txt | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line">    git show <span class="variable">$line</span> | grep <span class="built_in">test</span>/src/test_multiple_sensors.cc</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"------------------"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>运行时也可以输出到文件里，更方便查找：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh xxx.sh &gt; xxx.log</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">437a84f0a8278b1e06bc6ddc580210a02752c757</span><br><span class="line">------------------</span><br><span class="line">150d9ae6ffa0273a8b500327e802a28d69450077</span><br><span class="line">------------------</span><br><span class="line">0b45536f1ce7e859a85f1459d6ae34fc6cdc4039</span><br><span class="line">diff --cc <span class="built_in">test</span>/src/test_multiple_sensors.cc</span><br><span class="line">--- a/<span class="built_in">test</span>/src/test_multiple_sensors.cc</span><br><span class="line">+++ b/<span class="built_in">test</span>/src/test_multiple_sensors.cc</span><br><span class="line">------------------</span><br></pre></td></tr></table></figure>

<h4 id="4-恢复找到的记录"><a href="#4-恢复找到的记录" class="headerlink" title="4. 恢复找到的记录"></a>4. 恢复找到的记录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stach apply 0b45536f1ce7e859a85f1459d6ae34fc6cdc4039</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 强制类型转换</title>
    <url>/type-cast.html</url>
    <content><![CDATA[<p>相比于C风格的强制类型转换，C++新增了关键字 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code> ，用于强制类型转换。</p><p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。</p><h2 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. static_cast</h2><p>用于非多态类型转换 (静态转换)，任何标准转换都可以用它，但是不能用于两个不相关的类型转换。与C旧式转型基本相同。</p><a id="more"></a>


<p>常用于：</p>
<ul>
<li>基本数据类型之间的转换，如<code>int -&gt; char</code>，这种转换的安全也要开发人员来保证。</li>
<li>任何类型的表达式转换成 <code>void</code> 类型。</li>
</ul>
<p>注意：</p>
<ul>
<li>不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">65</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int a: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char a: "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> c = a / b;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: 65</span><br><span class="line">char a: A</span><br><span class="line">c: 6</span><br><span class="line">d: 6.5</span><br></pre></td></tr></table></figure>

<p><strong>没有运行时类型检查来保证转换的安全性</strong></p>
<ul>
<li>上行转型 (子类对象指针–&gt;父类对象指针/引用)： 安全</li>
<li>下行转型(父类对象指针–&gt;子类对象指针/引用)：没有动态类型检查，所以是不安全的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeinfo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">class_name</span><span class="params">()</span> final </span>&#123; <span class="keyword">return</span> <span class="keyword">typeid</span>(*<span class="keyword">this</span>).name(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt_1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt_2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt_3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1A 32686</span><br><span class="line">1B 3</span><br><span class="line">1C 5</span><br></pre></td></tr></table></figure>

<h2 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. dynamic_cast</h2><p>动态转换，常用于将一个父类对象的指针转换为子类对象的指针或引用。其他三种都是编译时完成的，<code>dynamic_cast</code> 是运行时处理的，运行时要进行类型检查。</p>
<ul>
<li><p>使用 <code>dynamic_cast</code> 进行转换的，基类中<strong>一定要有虚函数</strong>，否则编译不通过。</p>
</li>
<li><p>在进行下行转换时，会进行类型检查 (这个信息存储在类的虚函数表)，比 <code>static_cast</code> 安全。</p>
</li>
<li><p>转换后必须是类的指针、引用或 <code>void*</code>。</p>
</li>
<li><p>对于指针，转换失败会返回<code>nullptr</code>；对于引用，转换失败会 (在运行时) 抛出异常。</p>
</li>
</ul>
<p><strong>返回指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b3)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b3 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b1 null</span><br><span class="line">1B 3</span><br><span class="line">b3 null</span><br></pre></td></tr></table></figure>

<p><strong>返回引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  C c;</span><br><span class="line">  A &amp;a1 = b;</span><br><span class="line">  A &amp;a2 = c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a2);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B</span><br><span class="line">terminate called after throwing an instance of <span class="string">'std::bad_cast'</span></span><br><span class="line">  what():  std::bad_cast</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>

<h2 id="std-dynamic-pointer-cast"><a href="#std-dynamic-pointer-cast" class="headerlink" title="std::dynamic_pointer_cast"></a>std::dynamic_pointer_cast</h2><p>使用 <code>std::dynamic_pointer_cast</code> 可以返回 <code>std::shared_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt1 = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt2 = <span class="built_in">std</span>::make_shared&lt;C&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B 3</span><br><span class="line">b2 null</span><br></pre></td></tr></table></figure>

<h2 id="3-reinterpret-cast"><a href="#3-reinterpret-cast" class="headerlink" title="3. reinterpret_cast"></a>3. reinterpret_cast</h2><p>主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。</p>
<p><code>reinterpret_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li><code>type_id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。</li>
<li>在使用 <code>reinterpret_cast</code> 强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎。</li>
<li>转换结果与编译平台息息相关，<strong>不具有移植性</strong>，应该尽量避免使用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<p>最常用用途是转化 “函数指针” 类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FuncPtr)</span><span class="params">()</span></span>;  <span class="comment">// Funcptr是个指针，指向一个无输入参数且返回值为void的函数</span></span><br><span class="line">FuncPtr func_ptr_array[<span class="number">10</span>]; <span class="comment">// 包含10个函数指针的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_something</span><span class="params">()</span></span>;         <span class="comment">// 无输入参数且返回值为int的函数</span></span><br><span class="line"></span><br><span class="line">func_ptr_array[<span class="number">0</span>] = &amp;dosomething(); <span class="comment">// 错误，类型不符</span></span><br><span class="line">func_ptr_array[<span class="number">0</span>] = <span class="keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;dosomething()); <span class="comment">// 可以通过编译</span></span><br></pre></td></tr></table></figure>

<h2 id="4-const-cast"><a href="#4-const-cast" class="headerlink" title="4. const_cast"></a>4. const_cast</h2><p><code>const</code> 限定符通常被用来限定变量，用于表示该变量的值不能被修改。而 <code>const_cast</code> 则正是用于强制去掉这种不能被修改的常数特性。但需要特别注意的是 <code>const_cast</code> 不是用于<strong>去除变量的常量性</strong>，而是<strong>去除指向常数对象的指针或引用的常量性</strong>，其去除常量性的<strong>对象必须为指针或引用</strong>。</p>
<p><code>const_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li>该运算符用来修改表达式的常量性或易变性，也就是 <code>const</code> 或 <code>volatile</code> 属性。</li>
<li><code>type_id</code>和 <code>expression</code> 的类型必须是一样的。</li>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象。</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Widget&amp; w)</span></span>;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">cosnt Widget&amp; cw = w;  <span class="comment">// 常量引用</span></span><br><span class="line"></span><br><span class="line">update(cw);                      <span class="comment">// 错误，无法将常量引用传给一个非常量</span></span><br><span class="line">update(<span class="keyword">const_cast</span>&lt;Widget&amp;&gt; cw);  <span class="comment">// 可以，cw的常量性被去除，且cw在此函数中可被更改</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Udacity自动驾驶入门课笔记</title>
    <url>/udacity-self-driving-apollo.html</url>
    <content><![CDATA[<h1 id="无人驾驶第一课：从-Apollo-起步"><a href="#无人驾驶第一课：从-Apollo-起步" class="headerlink" title="无人驾驶第一课：从 Apollo 起步"></a>无人驾驶第一课：从 Apollo 起步</h1><p><a href="https://www.udacity.com/course/self-driving-car-fundamentals-featuring-apollo--ud0419" target="_blank" rel="noopener">udacity课程链接</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul>
<li>线控驾驶车辆：可通过电子控制的基础车辆，而不仅仅用过实体方向盘、油门踏板、刹车踏板来控制。</li>
<li>控制器区域网络 (CAN) : 车辆的内部通信网络。计算机系统通过CAN卡连接汽车内部网络，发送加速、制动和转向信号。</li>
<li>全球定位系统 (GPS) : 通过绕地卫星接收信号，帮助我们确定所处位置信息。</li>
<li>惯性测量装置 (IMU, Inertial Measurement Unit) : 通过跟踪位置、速度、加速度和其他因素，测量车辆的运动和位置。</li>
<li>激光雷达 (LiDAR) : 由一组脉冲激光器组成，可360度扫描车辆周围，这些激光束的反射形成了可用于了解环境的点云。可用于检测障碍物和检测其他车辆的速度，分辨率低，但成本低且不受天气和照明条件影响。</li>
<li>摄像头捕获图像数据，可使用计算机视觉来了解周围环境，例如检测交通灯。</li>
</ul><a id="more"></a>

<p><img src="./udacity-self-driving-apollo/introduction-devices.png" alt="image-intro-devices"></p>
<h3 id="开源软件栈"><a href="#开源软件栈" class="headerlink" title="开源软件栈"></a>开源软件栈</h3><ul>
<li>实时操作系统 (RTOS) : 可确保在给定时间内完成特定任务，Ubuntu + Apollo</li>
<li>运行时框架 : ROS的定制版，改进了共享内存的功能和性能、去中心化和数据兼容性 (protobuf)</li>
<li>应用程序模块 : 包括MAP引擎、定位、感知、规划、控制、端到端驾驶以及人机接口 (HMI) </li>
</ul>
<h3 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h3><ul>
<li>Apollo 云服务包含高精度地图、仿真环境、数据平台、信息安全、空中软件升级 (OTA)、智能语音系统 (DuerOS) 等</li>
</ul>
<h2 id="高精度地图-HD-Map"><a href="#高精度地图-HD-Map" class="headerlink" title="高精度地图 HD Map"></a>高精度地图 HD Map</h2><ul>
<li><p>高精度地图包含大量的驾驶辅助信息。最重要的信息是道路网的精确三维表征，例如交叉路口布局和路标位置。还包含很多语义信息，比如交通管制信息 (交通灯、道路限速等)，和城市的三维模型 (道路、建筑物、隧道等)</p>
</li>
<li><p>能到达<strong>厘米级</strong>的精度</p>
</li>
<li><p>高精地图用于定位（寻找地标）：</p>
<p>从各类传感器收集的数据查找地标，与地图上的已知地标进行比较。这一过程需要经过预处理 (消除不准确或质量差的数据)、坐标变换 (将来自不同视角的数据转换为统一的坐标系)、数据融合 (将来自各种车辆和传感器的数据合并)。</p>
</li>
<li><p>高精地图用于感知：</p>
<ul>
<li>传感器受到距离和环境的限制</li>
<li>传感器的视野容易被障碍物遮挡，高精地图可以补充信息</li>
<li>可以帮助传感器缩小检测范围 (ROI)，提高检测精度和速度</li>
</ul>
</li>
<li><p>高精地图用于规划：</p>
<ul>
<li>可帮助车辆找到合适的行车空间</li>
<li>帮助规划器确定不同的路线选择，以便选择最佳方案</li>
<li>帮助预测器预测道路上其他车辆在将来的位置</li>
<li>预知道路限速和障碍物等，使车辆提前减速或变道</li>
</ul>
</li>
<li><p>使用OpenDRIVE格式</p>
</li>
<li><p>高精度地图的构建由5个过程组成：数据采集、数据处理、对象检测、手动验证、地图发布</p>
<p><img src="./udacity-self-driving-apollo/hdmap-process.png" alt="image-hdmap-process"></p>
</li>
</ul>
<h2 id="定位-Localization"><a href="#定位-Localization" class="headerlink" title="定位 Localization"></a>定位 Localization</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>车辆将其传感器识别的地标与高精度地图上存在的地标进行比对</li>
<li>在这过程中，需要在它自身坐标系和地图坐标系之间转换数据</li>
<li>目标：在地图上以10cm的精度确定车辆的精确位置</li>
<li>常见的定位方法：GNSS RTK、惯性导航、LiDAR定位、视觉定位</li>
</ul>
<h3 id="GNSS-RTK"><a href="#GNSS-RTK" class="headerlink" title="GNSS RTK"></a>GNSS RTK</h3><ul>
<li><p>GNSS : 全球导航卫星系统</p>
</li>
<li><p>GPS是使用最广泛的GNSS系统</p>
</li>
<li><p>GPS共3个部分</p>
<ul>
<li>卫星：配备了高精确度的原子钟。在任何特定时间，大约有30颗GPS卫星在外层空间运行</li>
<li>世界各地的控制站：用于监视和控制卫星，使系统保持运行且验证GPS广播信号的精确度</li>
<li>GPS接收器：存在于手机等设备中，正常情况下每次应该至少检测到4颗GPS卫星。 通过测量信号的飞行时间来计算距离卫星的距离。3颗卫星可以定位，再加1颗可以确定海拔。</li>
</ul>
</li>
<li><p>实时运动定位 (RTK) : 在地面上建立几个基站，每个基站都知道自己精确的 ”地面实况“ 位置，每个基站也通过GPS来测量自己的位置，两者之间的偏差则为GPS测量结果中的误差。将这个误差发送到GPS接收器，以供其调整自身的位置计算。</p>
</li>
<li><p>使用 RTK 可以使 GPS <strong>精度达到10cm</strong>，但高障碍物或天气等仍然可能阻挡GPS信号。</p>
</li>
<li><p><strong>GPS更新频率为10Hz</strong>，也就是每0.1s更新一次。在0.1s的间隔内，速度为60km/h的车大概会行驶1.67m，差不多是一个车位的距离，这个更新频率对于自动驾驶来说太低了。</p>
</li>
</ul>
<h3 id="惯性导航"><a href="#惯性导航" class="headerlink" title="惯性导航"></a>惯性导航</h3><ul>
<li><p>使用加速度、初始速度和初始位置来计算汽车在任何时间点的车速和位置</p>
</li>
<li><p>惯性测量单元 (IMU) 是测量物体三轴姿态角以及加速度的装置</p>
</li>
<li><p>IMU的主要组件</p>
<ul>
<li>三轴加速度计：精确测量加速度</li>
<li>三轴陀螺仪：三个外部平衡环一直在旋转，但spin axis始终固定在世界坐标系中，通过测量旋转轴和三个外部平衡环的相对位置，可以计算出车辆在坐标系中的位置</li>
</ul>
</li>
<li><p>IMU的优点是<strong>更新频率高</strong>，可达1kHz，可提供接近实时的位置信息。缺点是误差会随时间的推进而增加，<strong>只能用于很短时间范围内的定位</strong>。</p>
</li>
<li><p>可以与GPS配合一起使用，称为组合惯导。一方面，IMU弥补了GPS更新频率较低的缺陷；另一方面，GPS纠正了IMU的运动误差。但山间/城市峡谷/地下隧道中行驶，有可能长时间获取不到GPS的更新，也会导致整个定位面临失败风险。</p>
</li>
</ul>
<h3 id="LiDAR定位"><a href="#LiDAR定位" class="headerlink" title="LiDAR定位"></a>LiDAR定位</h3><ul>
<li>利用<strong>激光雷达</strong>，我们可以通过<strong>点云匹配</strong>来对汽车进行定位。该方法将来自激光雷达传感器的检测数据与预先存在的高精度地图连续匹配，从而获知汽车在高精地图上的全球位置和行驶方向。</li>
<li>点云定位方法<ul>
<li>迭代最近点 (ICP) : 对于一个点云中的每个点，我们需要找到另一点云中最接近的匹配点，最终收集到许多匹配点对，然后计算出这些点对的平均距离误差，通过点云的平移和旋转来最大限度地降低这一平均距离误差，从而完成传感器扫描和地图之间的匹配。最后将通过传感器扫描到的车辆位置转换为全球地图上的位置，并计算出在地图上的精确位置。</li>
<li>滤波算法：消除冗余信息，并在地图上找到最可能的车辆位置。</li>
<li>Apollo使用了直方图滤波算法，也叫做误差平方和算法 (SSD)。将通过传感器扫描的点云滑过地图上的每个位置，在每个点上计算扫描的点与高精度地图上的对应点之间的误差或距离，对其平方求和。平方和越小，则扫描结果与地图之间的匹配越准确。</li>
<li>卡尔曼滤波：用于根据我们在过去的状态和新的传感器测量结果来预测当前的状态。具体来说是使用了预测更新周期，首先根据之前的状态以及对移动距离和方向的估计，来估计或预测新的位置，然后使用传感器测量新的位置并加以纠正，利用概率规则将不完美的传感器测量结果和现有的位置预测结合起来，永远遵循这个预测更新周期。</li>
</ul>
</li>
<li>LiDAR定位的优点在于<strong>稳健性</strong>，缺点在于<strong>难以构建高精地图并使其保持更新</strong> (包含很多瞬态元素)。</li>
</ul>
<h3 id="视觉定位"><a href="#视觉定位" class="headerlink" title="视觉定位"></a>视觉定位</h3><ul>
<li>通过观察结果、概率和地图来确定车辆最可能的位置</li>
<li>因为使用粒子或点来估计最可能的位置，所以称为<strong>粒子滤波</strong>。</li>
<li>比如对车道线进行拍摄，然后将道路摄像头图像与地图进行比较，通过匹配度来计算车辆在不同位置的概率，以连续的概率计算来确定车辆在道路中的位置。</li>
<li>视觉定位的优点在于图像数据很容易获得，而<strong>缺点在于缺乏三维信息和对三维地图的依赖</strong>。</li>
</ul>
<h3 id="Apollo定位"><a href="#Apollo定位" class="headerlink" title="Apollo定位"></a>Apollo定位</h3><ul>
<li>Apollo使用基于GPS、IMU和激光雷达的<strong>多传感器融合定位系统</strong>。</li>
<li>GNSS定位输出位置和速度信息，LiDAR定位输出位置和行进方向信息，融合框架通过卡尔曼滤波将这些输出结合在一起。卡尔曼滤波建立在两步预测测量周期之上，惯性导航解决方案用于卡尔曼滤波的预测步骤，GNSS和LiDAR定位用于卡尔曼滤波的测量结果更新步骤。</li>
</ul>
<p><img src="./udacity-self-driving-apollo/localization-kalman-filter.png" alt="image-20220410121939839"></p>
<h2 id="感知-Perception"><a href="#感知-Perception" class="headerlink" title="感知 Perception"></a>感知 Perception</h2><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><ul>
<li><p>无人驾驶车有4个感知世界的核心任务</p>
<ul>
<li>检测：找出物体在环境中的位置</li>
<li>分类：明确对象是什么</li>
<li>追踪：随时间的推移观察移动物体</li>
<li>分割：将图像中的每个像素与语义类别进行匹配</li>
</ul>
</li>
<li><p>计算机视觉pipeline例子</p>
<ul>
<li>输入图像</li>
<li>预处理 (对图像进行标准化 / 旋转 / 色彩空间转换等预处理，帮助模型更快地学习和处理图像)</li>
<li>特征提取</li>
<li>分类模型</li>
</ul>
<p><img src="./udacity-self-driving-apollo/classification_pipeline.png" alt="image-classification-pipeline"></p>
</li>
</ul>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul>
<li>对于计算机而言，图片只是一个二维网格 / 矩阵，矩阵中的每个单元格都包含一个值。</li>
<li>数字图像由像素组成，其中包含非常小的颜色或强度单位，图像中的每个像素都是一个数值，这些值构成了整个图像矩阵。</li>
<li>图像处理实际上就是在对这些值进行处理，大多数的颜色和形状转换都是通过对图像进行数学运算以及逐一像素进行更改来完成的。</li>
</ul>
<h3 id="LiDAR图像-点云"><a href="#LiDAR图像-点云" class="headerlink" title="LiDAR图像 (点云)"></a>LiDAR图像 (点云)</h3><ul>
<li>激光雷达传感器可以创建环境的点云表征。</li>
<li>激光雷达发射<strong>激光脉冲</strong>，通过测量该激光反射回传感器的时间，来计算环境中反射该光线的物体的距离。</li>
<li>它收集的数据形成<strong>点云</strong>，点云中的每个点代表反射回传感器的激光束。</li>
<li>点云能表现物体的形状和表面纹理。</li>
<li>通过对点云进行聚类和分析，可以获得足够的信息对对象进行检测、跟踪或分类。</li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li>机器学习是使用特殊算法来训练计算机从数据中学习的计算机科学领域。一般来说，学习结果会存放在一种被称为 “模型” 的数据结构中。</li>
<li>模型是一种可用于理解和预测世界的数据结构。</li>
<li>监督学习 : 使用数据和相关的真值标记来训练模型</li>
<li>非监督学习 : 不提供真值标记，而是通过分析输入的数据，计算机凭借自行学习找到区别</li>
<li>半监督学习 : 使用少量的标记数据和大量的未标记数据来训练模型</li>
<li>强化学习 : 允许模型通过尝试许多不同的方法来解决问题，然后衡量哪种方法最为成功</li>
</ul>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><ul>
<li><p>人工神经网络由大量的人工神经元组成。人工神经元负责传递和处理信息，这些神经元也可以被训练。</p>
</li>
<li><p>神经网络会对图像提取多种特征 (可能是人类无法描述或无法理解的特征)，计算机将调整这些特征的权重，以完成最终任务。</p>
</li>
<li><p>训练由三步循环组成</p>
<ul>
<li>前馈 : 首先随机分配初始权重 (也就是每个神经元的值)，然后给神经网络提供图像，使其产生输出值</li>
<li>误差测定 : 计算真值标记与前馈过程所产生的输出值之间的偏差</li>
<li>反向传播 : 通过神经网络反向发送误差，每个人工神经元都对其值进行微调，从而生成更准确的网络</li>
</ul>
</li>
</ul>
<h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><ul>
<li><p>卷积神经网络 (CNN) 接受多维输入，包括二维和三维的大多数传感器数据。</p>
</li>
<li><p>相对于标准神经网络，CNN可以维持输入像素之间的空间关系。</p>
</li>
<li><p>CNN 通过将滤波连续划过图像来收集信息，每次收集信息时，只对整个图像的一小部分区域进行分析，这被称为 “卷积”。</p>
<p><img src="./udacity-self-driving-apollo/percetion-convolution.png" alt="image-20220409222316478"></p>
</li>
<li><p>当我们用滤波对整个输入图像进行 “卷积” 时，我们将该信息与下一个卷积层相关联。例如，第一个卷积层可能会识别出图像中的基本边缘和颜色信息；然后在第一层的基础上连接一个新的滤波，使用图像的边缘和颜色信息来检测更复杂的结构，比如轮子/车窗等；而另一个卷积可以使用这些轮子/车门来识别整个车辆；最终CNN可以使用这一高阶信息对车辆进行分类。</p>
<p><img src="./udacity-self-driving-apollo/percetion-cnn.png" alt="image-20220409223621043"></p>
</li>
</ul>
<h3 id="检测和分类"><a href="#检测和分类" class="headerlink" title="检测和分类"></a>检测和分类</h3><ul>
<li><p>障碍物</p>
<ul>
<li>静态障碍物：墙壁、树木、杆子、建筑物等</li>
<li>动态障碍物：行人、车辆等</li>
</ul>
</li>
<li><p>计算机需要知道障碍物的位置，然后对其进行分类。</p>
</li>
<li><p>可以使用单一CNN体系结构对对象进行检测和分类，通过在单个网络体系结构的末端附加几个不同的“头”，可以执行不同的任务。</p>
<p><img src="./udacity-self-driving-apollo/percetion-detection-and-classification.png" alt="image-20220410000129529"></p>
</li>
<li><p>一种经典的体系结构为RCNN，以及其变体 Fast RCNN 和 Faster RCNN。</p>
</li>
<li><p>YOLO 和 SSD 是具有类似形式的不同体系结构。</p>
</li>
</ul>
<h3 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h3><ul>
<li>追踪的好处<ul>
<li>解决遮挡问题（预测之前检测到但在当前帧中被遮挡的物体的位置）</li>
<li>保留物体的身份信息</li>
</ul>
</li>
<li>追踪的第一步为<strong>确认身份</strong>：通过查找特征相似度最高的对象，可以将在前帧中检测到的所有对象与在当前帧中检测到的对象进行匹配；物体的位置和速度信息也有助于快速匹配对象。</li>
<li>确认身份后，使用对象的位置结合<strong>预测算法</strong>，可以预估在下一个时间段中物体的速度和位置，这个预测结果又可以帮助识别下一帧中的相应对象。</li>
</ul>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><ul>
<li><p>语义分割实际上是对图像的每个像素进行分类。</p>
</li>
<li><p>分割可帮助我们尽可能详细地了解环境和确定车辆可驾驶区域。</p>
</li>
<li><p>图像分割依赖于一种特殊类型的CNN——全卷积网络 (FCN)。</p>
</li>
<li><p>FCN 使用卷积层来替代传统CNN体系结构末端的连接层，则整个网络中的每一层都为卷积层。</p>
</li>
<li><p>FCN 可在原始输入图像之上提供逐像素的输出（通过对中间输出进行上采样的方式，使输出尺寸与原始输入图像的尺寸相等）。</p>
<p><img src="./udacity-self-driving-apollo/percetion-fcn.png" alt="image-20220409231158846"></p>
</li>
<li><p>网络的前半部分对输入图像的特征进行了提取和编码，通常称为编码器；后半部分对提取到的特征进行解码，并将其应用于输出，通常称为解码器。</p>
</li>
</ul>
<h3 id="Apollo-感知"><a href="#Apollo-感知" class="headerlink" title="Apollo 感知"></a>Apollo 感知</h3><ul>
<li>Apollo感知模块可以检测障碍物、交通信号灯和车道。</li>
<li>对于<strong>三维物体检测</strong>，Apollo在高精度地图上使用ROI来重点关注相关对象，将ROI应用于图像和点云数据，以缩小搜索范围并加快感知。然后将过滤后的数据输入到检测网络，产生用于构建围绕对象的三维边界框输出。最后使用 Detection to Track Association 算法来跨时间识别单个对象。</li>
<li>Detection to Track Association : 先保留在每个时间步要追踪的对象列表，然后在下一个时间步中找到每个对象的最佳匹配。</li>
<li>对于<strong>交通灯分类</strong>，Apollo先使用高精地图来确定前方是否存在交通信号灯；如果前方存在交通灯，高精地图会返回灯的位置，这可以缩小摄像头的搜索范围；在摄像头捕获到交通信号灯的图像后，Apollo使用检测网络对图像中的灯进行定位；将裁剪后的交通灯图像提供给分类网络，以确定交通灯的颜色。</li>
<li>对于<strong>车道线和动态物体的检测</strong>，Apollo使用YOLO网络完成。在经过YOLO网络检测后，在线检测模块会并入来自其他传感器的数据，对车道线预测或是动态物体的检测结果进行调整，最终传递到规划和控制模块。</li>
</ul>
<h3 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h3><p><img src="./udacity-self-driving-apollo/percetion-sensors.png" alt="image-20220409233936508"></p>
<ul>
<li><strong>摄像头</strong>的优势在于图像分类，主要用于交通信号灯分类和车道检测。</li>
<li><strong>激光雷达</strong> (激光探测与测量) 的优势在于障碍物检测，且不受环境光影响，可在夜间使用，分辨率较高。缺点是不能直接测量对象的速度，必须使用两次或多次扫描之间的位置差来确定；受天气和传感器清洁程度影响很大，需要保持清洁；块头比其他传感器更大，难以安装，目前一般安装在车顶。</li>
<li><strong>雷达</strong> (无线电探测与测量) 的优势在于探测范围和应对恶劣天气。雷达通过多普勒效应来直接测量速度，可以把速度作为独立的测量参数，从而提升了融合算法的收敛速度。因为雷达波在坚硬表面会回弹，它可以直接测量对象距离，无需在视线范围内也可以，可以发现可能会被阻挡的建筑物和对象。缺点在于分辨率较低 (尤其是在垂直方向)，对金属敏感，来自静态物体的反射可能产生问题。</li>
<li>Apollo使用激光雷达和雷达来检测障碍物，用于融合输出的主要算法为卡尔曼滤波。<ul>
<li>第一步为预测</li>
<li>第二步为更新测量结果<ul>
<li>同步更新：同时更新来自不同传感器的测量结果</li>
<li>异步更新：逐个更新所收到的传感器测量结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="预测-Predition"><a href="#预测-Predition" class="headerlink" title="预测 Predition"></a>预测 Predition</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>预测模块对感知模块检测到的障碍物进行行为研究和预测。预测模块接收障碍物的数据和基本的感知信息 (包括位置、朝向、速度、加速度) ，根据这些信息生成障碍物的预测轨迹。</p>
<ul>
<li><p>预测需要</p>
<ul>
<li>实时性</li>
<li>准确性</li>
<li>具备学习能力：车辆越多情况会越复杂，不可能开发出每种场景的静态模型；需要使用多源的数据对其进行训练，使算法能随着时间的推移而提升预测能力。</li>
</ul>
</li>
<li><p>两种预测方法</p>
<ul>
<li><strong>基于模型预测</strong>：为障碍物生成不同行为的模型，通过观察障碍物的行为来更新不同模型的概率，从而预测障碍物的行为路径。优点在于直观，且结合了物理知识、交通法规、人类行为等多方面的知识，比如可以结合物理知识 (摩擦力等) 来准确地确定车辆何时会在潮湿的路面上滑行。</li>
<li><strong>数据驱动预测</strong>：使用机器学习算法，通过观察结果来训练模型；一旦模型训练好，就可以在现实世界中使用此模型去做出预测。优点在于，使用的数据越多，预测效果就会越好</li>
</ul>
</li>
<li><p>除了障碍物的位置、朝向、速度、加速度外，预测模块还会考虑车道段内障碍物的位置 (比如从物体到车道线段边界的纵向和横向距离)，以及之前时间间隔里障碍物的状态信息，以提高预测的准确度。</p>
</li>
</ul>
<h3 id="车道序列"><a href="#车道序列" class="headerlink" title="车道序列"></a>车道序列</h3><ul>
<li><p>用车道序列描述障碍物行为：将道路分成多个部分，每个部分都覆盖了一个易于描述车辆运动的区域，将车辆的行为划分为一组有限的模式组合，并将这些模式组合描述成车道序列。</p>
</li>
<li><p>使用车道序列框架的目标是为道路上的物体生成轨迹。</p>
</li>
<li><p>预测车道线段之间的过渡：假设在车道段0中检测到一辆车，我们会预测在接下来的几个时间段中它将如何行驶。很明显有两个选择：0 -&gt; 4 -&gt; 5 或者 0 -&gt; 1 -&gt; 3 -&gt; 7。通过这样的分析，可以将预测问题简化为选择问题，那么只需要选择车辆最有可能采取的车道顺序 (通过计算每个车道序列的概率)。</p>
<img src="./udacity-self-driving-apollo/predition_choose_road.png" alt="image-predition-road-sequence" style="zoom:60%;">
</li>
<li><p>计算概率：我们需要一个模型，将车辆状态和车道段作为输入，而输出车辆可能采用每个车道序列的概率。</p>
</li>
<li><p>使用观测数据对模型进行经验性训练：将真实的车辆行为提供给模型，不仅包括车道段和对象的状态，还包括对象最终选择哪条车道序列。每个记录将由观察对象跟随的车道段序列和对象的相关状态组成；在每个时间点，对象占用一个车道段并具有特定的状态；整个记录由一系列车道段和对象的相关状态组成。</p>
</li>
</ul>
<h3 id="递归神经网络（RNN）"><a href="#递归神经网络（RNN）" class="headerlink" title="递归神经网络（RNN）"></a>递归神经网络（RNN）</h3><ul>
<li><p>RNN 是一种利用时间序列数据特征的预测方法</p>
</li>
<li><p>神经网络是可训练的多层模型，从输入提取高级特征，并利用这些特征来计算得到输出。</p>
</li>
<li><p>神经网络有很多种结构。一个基本的神经网络首先得到输入，然后将数据通过隐藏层，经过处理，最后得到输出。这种结构也被称作<strong>多层感知网络</strong> (MLP)。</p>
</li>
<li><p>每一个输入数据由原始的数据和对应的标签组成。</p>
</li>
<li><p>神经网络通过<strong>反向传播 (back propagation)</strong> 学习数据。首先，神经网络得到输入并产生输出，然后比较输出和真值 (ground truth) 之间的误差，误差通过反向传回整个网络，中间的隐藏层根据观察到的误差调整权重，以提高神经网络的准确率。</p>
<p><img src="./udacity-self-driving-apollo/predition-back_propagation.png" alt="image-predition-bp"></p>
</li>
<li><p>我们可以建立这样的多重结构的递归神经网络，称为<strong>MLP单元</strong>，从数据序列中提取出高级特征。每个MLP单元将序列的一个元素作为输入，并预测序列的下一个元素作为输出；为了对元素之间的顺序关系建立模型，在每个单元之间建立一个额外的连接；于是<strong>每个单元根据原始输入和前一个单元的输出进行预测</strong>。这就是RNN的基本结构。</p>
<p><img src="./udacity-self-driving-apollo/predition-rnn.png" alt="image-predition-rnn"></p>
</li>
</ul>
<h3 id="Apollo-RNN预测"><a href="#Apollo-RNN预测" class="headerlink" title="Apollo RNN预测"></a>Apollo RNN预测</h3><ul>
<li><p>Apollo 使用RNN建立一个模型来预测车辆的目标车道：为车道序列提供一个RNN模型，为相关对象状态提供另一个RNN模型，连接这两个RNN模型的输出并将它们输出到另一个神经网络，来估计每个车道序列的概率，具有最高概率的车道序列就是目标车辆的预测车道序列。</p>
</li>
<li><p>训练数据：每条记录都包含一个车道序列、相关的对象状态和一个标签，标签指示了对象是否遵循此特定车道序列。</p>
</li>
<li><p>通过网络输出和标签真值的误差，使用反向传播来训练网络。</p>
<img src="./udacity-self-driving-apollo/predition-apollo-network.png" alt="image-predition-apollo" style="zoom: 60%;">

</li>
</ul>
<h3 id="生成轨迹"><a href="#生成轨迹" class="headerlink" title="生成轨迹"></a>生成轨迹</h3><ul>
<li><p>生成轨迹是预测的最后一步。</p>
</li>
<li><p>一旦我们预测到物体的车道序列，我们就可以预测物体的轨迹。</p>
</li>
<li><p>在任意两点A和B之间，物体的行进轨迹有无限的可能。我们可以先通过设置约束条件，来去除大部分候选轨迹。</p>
<ul>
<li>假设车辆将与目标车道的中心对齐</li>
<li>去除车辆无法实际执行的轨迹</li>
<li>考虑车辆当前的速度和加速度</li>
</ul>
<p><img src="./udacity-self-driving-apollo/predition-trajetory1.png" alt="image-prediction-trajectory1"></p>
<p><img src="./udacity-self-driving-apollo/prediction-trajectory2.png" alt="image-prediction-trajectory2"></p>
</li>
<li><p>实际上并不会列出所有可能的轨迹再逐一去除它们，而是在数学理论上来应用这一想法。首先获得车辆在两点的位置和方向，这两点的姿态代表着运动模型的起始状态和最终状态，使用这两个条件来拟合一个<strong>多项式模型</strong>。大多数情况下，这种多项式足以进行轨迹预测。</p>
</li>
</ul>
<h2 id="规划-Planning-未完成"><a href="#规划-Planning-未完成" class="headerlink" title="规划 Planning [未完成]"></a>规划 Planning [未完成]</h2><h2 id="控制-Control-未完成"><a href="#控制-Control-未完成" class="headerlink" title="控制 Control [未完成]"></a>控制 Control [未完成]</h2><h3 id="PID-控制"><a href="#PID-控制" class="headerlink" title="PID 控制"></a>PID 控制</h3><ul>
<li>PID控制：<ul>
<li>P：比例控制</li>
<li>D：微分，致力于使运动处于稳定状态</li>
<li>I：积分</li>
</ul>
</li>
<li>优点：简单，只需要知道车辆与目标轨迹有多大的偏离</li>
<li>缺点：是一种线性算法，需要应用不同的PID控制器来控制转向和加速，很难将横向和纵向控制结合起来；依赖于实时误差测量，受到测量延迟限制时可能会失效。</li>
</ul>
<h3 id="线性二次调节器"><a href="#线性二次调节器" class="headerlink" title="线性二次调节器"></a>线性二次调节器</h3><ul>
<li>线性二次调节器 (LQR) : 是基于模型的控制权，通过使用车辆的状态来使误差最小化，可用于横向控制。</li>
<li>横向控制包含4个组件<ul>
<li>横向误差</li>
<li>横向误差的变化率</li>
<li>朝向误差</li>
<li>朝向误差的变化率</li>
</ul>
</li>
<li>车辆的3个控制输入 : 转向、加速、制动</li>
<li>状态空间方程 : </li>
</ul>
<p>$$<br>\dot{x} = Ax + Bu<br>$$</p>
<p><img src="./udacity-self-driving-apollo/control-LQR.png" alt="image-20220410144646315"></p>
<p><img src="./udacity-self-driving-apollo/control-LQR2.png" alt="image-20220410145023779"></p>
<h3 id="模型预测控制"><a href="#模型预测控制" class="headerlink" title="模型预测控制"></a>模型预测控制</h3><ul>
<li><p>模型预测控制 (MPC) 是一种更复杂的控制器，非常依赖于数学优化</p>
</li>
<li><p>基本上可以归结为3个步骤：</p>
<ul>
<li>建立车辆模型</li>
<li>使用优化引擎计算有限时间范围内的控制输入</li>
<li>执行第一组控制输入</li>
</ul>
</li>
<li><p>只执行第一组控制输入，可以在每个时间步里不断地重新评估控制输入的最有序列，使实际产生的车辆状态与模型更接近。</p>
</li>
<li><p>第一步中建立的车辆模型近似于汽车的物理特性，它可以估计将一组控制输入应用到车辆时具体会发生什么。</p>
</li>
<li><p>优化引擎的工作原理是通过搜索密集数学空间来寻求最佳解决方案，车辆模型的约束条件 (比如车辆能实际实现的转向范围等) 可以缩小搜索范围。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>self-driving</category>
      </categories>
      <tags>
        <tag>self-driving</tag>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
