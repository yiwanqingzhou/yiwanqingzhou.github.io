<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 使用boost::program_options解析命令行选项</title>
    <url>/boost-options-description.html</url>
    <content><![CDATA[<p>Boost.ProgramOptions是Boost中一个专门用来解析命令行的库，其目标是轻松的解析命令行选项。</p>
<a id="more"></a>



<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/program_options.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_notifier</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"On notifier: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> po = boost::program_options;</span><br><span class="line">    po::<span class="function">options_description <span class="title">desc</span><span class="params">(<span class="string">"Options"</span>)</span></span>;</span><br><span class="line">    desc.add_options()</span><br><span class="line">        (<span class="string">"enable_something,e"</span>, <span class="string">"Enable Something"</span>)</span><br><span class="line">        (<span class="string">"test_string,s"</span>, po::value&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(), <span class="string">"Test String"</span>)</span><br><span class="line">        (<span class="string">"test_int,p"</span>, po::value&lt;<span class="keyword">int</span>&gt;(), <span class="string">"Test Int"</span>)</span><br><span class="line">        (<span class="string">"test_default_value,d"</span>,po::value&lt;<span class="keyword">int</span>&gt;()-&gt;default_value(<span class="number">1</span>), <span class="string">"Test Default Value"</span>)</span><br><span class="line">        (<span class="string">"test_notifier"</span>, value&lt;<span class="keyword">int</span>&gt;()-&gt;notifier(on_notifier), <span class="string">"Test Notifier"</span>);</span><br><span class="line">    po::variables_map vm;</span><br><span class="line">  	po::store(po::parse_command_line(argc, argv, desc), vm);</span><br><span class="line">  	po::notify(vm);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// no options set</span></span><br><span class="line">    <span class="comment">// print all options</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span> || !vm.count(<span class="string">"sensor_id"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; desc &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> enable_something = vm.count(<span class="string">"enable_something"</span>);</span><br><span class="line">    <span class="keyword">int</span> value = vm[<span class="string">"test_default_value"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_string"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ss = vm[<span class="string">"test_string"</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_string was set to: "</span>  &lt;&lt; ss &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.count(<span class="string">"test_int"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dd = vm[<span class="string">"test_int"</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test_int was set to: "</span>  &lt;&lt; dd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CMake里引入依赖"><a href="#CMake里引入依赖" class="headerlink" title="CMake里引入依赖"></a>CMake里引入依赖</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost COMPONENTS program_options REQUIRED)</span><br><span class="line"><span class="keyword">target_include_directories</span>(myTarget PRIVATE <span class="variable">$&#123;Boost_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(myTarget <span class="variable">$&#123;Boost_LIBRARIES&#125;</span> )</span><br></pre></td></tr></table></figure>

<p><a href="https://www.boost.org/doc/libs/1_63_0/doc/html/program_options/tutorial.html#idp523371328" target="_blank" rel="noopener">官方Tutorial参考</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 使用clang格式化代码</title>
    <url>/clang_format.html</url>
    <content><![CDATA[<p>.clang-format文件存档</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Language:        Cpp</span><br><span class="line"># BasedOnStyle:  LLVM</span><br><span class="line">AccessModifierOffset: -2</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveAssignments: false</span><br><span class="line">AlignConsecutiveDeclarations: false</span><br><span class="line">AlignEscapedNewlinesLeft: false</span><br><span class="line">AlignOperands:   true</span><br><span class="line">AlignTrailingComments: true</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: true</span><br><span class="line">AllowShortBlocksOnASingleLine: false</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: false</span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: false</span><br><span class="line">AllowShortLoopsOnASingleLine: false</span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: false</span><br><span class="line">BinPackArguments: true</span><br><span class="line">BinPackParameters: false</span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterClass:      false</span><br><span class="line">  AfterControlStatement: false</span><br><span class="line">  AfterEnum:       false</span><br><span class="line">  AfterFunction:   true</span><br><span class="line">  AfterNamespace:  false</span><br><span class="line">  AfterObjCDeclaration: false</span><br><span class="line">  AfterStruct:     true</span><br><span class="line">  AfterUnion:      true</span><br><span class="line">  BeforeCatch:     true</span><br><span class="line">  BeforeElse:      true</span><br><span class="line">  IndentBraces:    false</span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeBraces: Allman</span><br><span class="line">BreakBeforeTernaryOperators: false</span><br><span class="line">BreakConstructorInitializersBeforeComma: false</span><br><span class="line">ColumnLimit:     0</span><br><span class="line">CommentPragmas:  &apos;^ IWYU pragma:&apos;</span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: false</span><br><span class="line">ConstructorInitializerIndentWidth: 4</span><br><span class="line">ContinuationIndentWidth: 4</span><br><span class="line">Cpp11BracedListStyle: true</span><br><span class="line">DerivePointerAlignment: false</span><br><span class="line">DisableFormat:   false</span><br><span class="line">ExperimentalAutoDetectBinPacking: false</span><br><span class="line">ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH ]</span><br><span class="line">IncludeCategories: </span><br><span class="line">  - Regex:           &apos;^&quot;(llvm|llvm-c|clang|clang-c)/&apos;</span><br><span class="line">    Priority:        2</span><br><span class="line">  - Regex:           &apos;^(&lt;|&quot;(gtest|isl|json)/)&apos;</span><br><span class="line">    Priority:        3</span><br><span class="line">  - Regex:           &apos;.*&apos;</span><br><span class="line">    Priority:        1</span><br><span class="line">IndentCaseLabels: false</span><br><span class="line">IndentWidth:     2</span><br><span class="line">IndentWrappedFunctionNames: false</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: true</span><br><span class="line">MacroBlockBegin: &apos;&apos;</span><br><span class="line">MacroBlockEnd:   &apos;&apos;</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: All</span><br><span class="line">ObjCBlockIndentWidth: 2</span><br><span class="line">ObjCSpaceAfterProperty: false</span><br><span class="line">ObjCSpaceBeforeProtocolList: true</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 19</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 60</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">ReflowComments:  true</span><br><span class="line">SortIncludes:    true</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">SpacesBeforeTrailingComments: 1</span><br><span class="line">SpacesInAngles:  false</span><br><span class="line">SpacesInContainerLiterals: true</span><br><span class="line">SpacesInCStyleCastParentheses: false</span><br><span class="line">SpacesInParentheses: false</span><br><span class="line">SpacesInSquareBrackets: false</span><br><span class="line">Standard:        Cpp11</span><br><span class="line">TabWidth:        8</span><br><span class="line">UseTab:          Never</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake设置编译选项</title>
    <url>/cmake-set-flag.html</url>
    <content><![CDATA[<h4 id="CMake中设置编译选项"><a href="#CMake中设置编译选项" class="headerlink" title="CMake中设置编译选项"></a>CMake中设置编译选项</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_VISUALIZATIONS <span class="string">"Build visualization, default OFF"</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">"BUILD_VISUALIZATIONS is $&#123;BUILD_VISUALIZATIONS&#125;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以跟build type关联</span></span><br><span class="line"><span class="comment"># if(CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES DEBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_VISUALIZATIONS)</span><br><span class="line"><span class="keyword">add_definitions</span>(-DBUILD_VISUALIZATIONS)</span><br><span class="line"><span class="comment"># target_compile_definitions($&#123;project_name&#125; PRIVATE BUILD_VISUALIZATIONS)</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="代码中作为宏"><a href="#代码中作为宏" class="headerlink" title="代码中作为宏"></a>代码中作为宏</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BUILD_VISUALIZATIONS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(<span class="keyword">const</span> <span class="keyword">cloud_ptr_t</span>&amp; cloud_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"visualizations on"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// visualize cloud</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visualize_cloud</span><span class="params">(Args...)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pass visualizations"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="编译时传入参数"><a href="#编译时传入参数" class="headerlink" title="编译时传入参数"></a>编译时传入参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--cmake-args -DBUILD_VISUALIZATIONS=ON</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：条件变量std::condition_variable的使用</title>
    <url>/condition-variable.html</url>
    <content><![CDATA[<p><code>std::condition_variable</code> 是 C++11 多线程编程中的条件变量。</p>
<p>一般用法: 线程 A <strong>等待</strong>某个条件并挂起，直到线程 B 设置了这个条件，并<strong>通知</strong>条件变量，然后线程 A 被唤醒。</p>
<a id="more"></a>



<h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>仅支持默认构造函数，拷贝、赋值和移动(move)均是被禁用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br></pre></td></tr></table></figure>

<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><h5 id="无条件等待"><a href="#无条件等待" class="headerlink" title="无条件等待"></a>无条件等待</h5><p>阻塞当前线程直到被其他线程通知唤醒。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="有条件等待"><a href="#有条件等待" class="headerlink" title="有条件等待"></a>有条件等待</h5><p>只有当 <code>pred</code> 条件为 <code>false</code> 时才会阻塞当前线程，并且在收到其他线程的通知后只有当 <code>pred</code> 为 <code>true</code> 时才会被解除阻塞。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span> (<span class="title">unique_lock</span>&lt;mutex&gt;&amp; <span class="title">lck</span>, <span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pred())</span><br><span class="line">&#123;</span><br><span class="line">	wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>通知线程可以使用 <code>notify_one()</code> 通知一个线程，或一次使用 <code>notify_all()</code> 通知所有线程。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; ready;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" start.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">  cv.wait(lck, [] &#123; <span class="keyword">return</span> ready.load(); &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">" id: "</span> &lt;&lt; id &lt;&lt; <span class="string">" done.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ready</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set_ready(): "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  ready.store(<span class="literal">true</span>);</span><br><span class="line">  cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ready.store(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> t_1 = <span class="built_in">std</span>::thread(wait, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">auto</span> t_2 = <span class="built_in">std</span>::thread(wait, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  set_ready();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"join...."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  t_1.join();</span><br><span class="line">  t_2.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"all done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread: 139827702187776 id: 1 start.</span><br><span class="line">thread: 139827693795072 id: 2 start.</span><br><span class="line">set_ready(): 1</span><br><span class="line">thread: 139827702187776 id: 1 done.</span><br><span class="line">set_ready(): 1</span><br><span class="line">join....</span><br><span class="line">thread: 139827693795072 id: 2 done.</span><br><span class="line">all done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian添加最小化按钮</title>
    <url>/debian_minimize_botton.html</url>
    <content><![CDATA[<p>安装tweak和dconf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweak-tool</span><br><span class="line">sudo apt install dconf-editor </span><br><span class="line">dconf-editor</span><br></pre></td></tr></table></figure><p>进入路径: <code>org/gnome/desktop/wm/preferences/button-layout</code></p><img src="/debian_minimize_botton/test.png" title="debian_minimize_botton"><p>取消选项 Use default value</p><a id="more"></a>








<p>在 Custom value 填入 <code>appmemu:close,minimize,maximize,close</code></p>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 解压缩rar包</title>
    <url>/extract_from_rar.html</url>
    <content><![CDATA[<h4 id="下载rar软件安装包"><a href="#下载rar软件安装包" class="headerlink" title="下载rar软件安装包"></a>下载rar软件安装包</h4><ol>
<li><p>直接从 <a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">rarlab</a> 下载安装包</p>
</li>
<li><p>通过命令行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://www.rarlab.com/rar/rarlinux-x64-6.0.1.tar.gz  <span class="comment"># 64位</span></span><br><span class="line">wget https://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz	   <span class="comment"># 32位</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf rarlinux-x64-6.0.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> rar</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h4 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar x xxx.rar  <span class="comment"># Extract files with full path</span></span><br><span class="line">rar e xxx.rar  <span class="comment"># Extract files without archived paths</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>



<h4 id="将xxx目录压缩为xxx-rar"><a href="#将xxx目录压缩为xxx-rar" class="headerlink" title="将xxx目录压缩为xxx.rar"></a>将xxx目录压缩为xxx.rar</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rar a xxx.rar xxx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uncompress</tag>
        <tag>rar</tag>
      </tags>
  </entry>
  <entry>
    <title>使用clang和black 对C++、Python代码自动格式化</title>
    <url>/format_code.html</url>
    <content><![CDATA[<h4 id="使用clang对C-进行格式化"><a href="#使用clang对C-进行格式化" class="headerlink" title="使用clang对C++进行格式化"></a>使用<code>clang</code>对C++进行格式化</h4><ul>
<li><p>安装<code>clang-format-7</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y clang-format-7</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写脚本 <code>clang_format.bash</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -regextype egrep -regex <span class="string">".*\.(c|cc|h|hh)$"</span> -not -path <span class="string">'*/install/*'</span> \</span><br><span class="line">  -not -path <span class="string">'*/build/*'</span> -not -path <span class="string">'*/log/*'</span> -not -path <span class="string">'*/deps/*'</span>| xargs clang-format-7 -i</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./clang_format.bash</span><br></pre></td></tr></table></figure>





</li>
</ul><a id="more"></a>
<h4 id="使用black对python进行格式化"><a href="#使用black对python进行格式化" class="headerlink" title="使用black对python进行格式化"></a>使用<code>black</code>对python进行格式化</h4><ul>
<li><p>安装<code>black</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install black==20.8b1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要格式化的路径下运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">black .</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>clang</tag>
        <tag>linux</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 搭建FTP服务器</title>
    <url>/ftp_server.html</url>
    <content><![CDATA[<h4 id="安装ftp和vsftpd"><a href="#安装ftp和vsftpd" class="headerlink" title="安装ftp和vsftpd"></a>安装ftp和vsftpd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ftp</span><br><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用vsftpd软件，主要包括如下几个命令：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动ftp</span></span><br><span class="line">service vsftpd start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止ftp</span></span><br><span class="line">service vsftpd stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启ftp</span></span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure><a id="more"></a>



<h4 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h4><p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/vsftpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># vi /etc/vsftpd/vsftpd.conf</span></span><br></pre></td></tr></table></figure>

<p>按照需求修改为以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line"></span><br><span class="line"># local root</span><br><span class="line">local_root=/home/bot/dev/moma_app/scanner_images</span><br></pre></td></tr></table></figure>

<h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>

<h4 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录本地ftp</span></span><br><span class="line">ftp 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入用户名和密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前路径是否设置的local root</span></span><br><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>pcl类型转换</title>
    <url>/pcl_type_transform.html</url>
    <content><![CDATA[<h4 id="PCL相关类型-对象与指针互换"><a href="#PCL相关类型-对象与指针互换" class="headerlink" title="PCL相关类型 对象与指针互换"></a>PCL相关类型 对象与指针互换</h4><ol>
<li>pcl::PointIndices -&gt; pcl::PointIndices::Ptr</li>
</ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::<span class="function">Ptr <span class="title">inliers_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointIndices(inliers))</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a>


<ol start="2">
<li>pcl::PointIndices::Ptr -&gt; pcl::PointIndices</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointIndices inliers;</span><br><span class="line">pcl::PointIndices::Ptr inliers_ptr;</span><br><span class="line">inliers=*inliers_ptr;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>std::vector<int> -&gt; pcl::IndicesPtr</int></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_indices;</span><br><span class="line">pcl::IndicesPtr indices_ptr = boost::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(vec_indices);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>pcl::PointCloud<pointt> -&gt; pcl::PointCloud<pointt>::Ptr</pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud=*cloud_ptr;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>pcl::PointCloud<pointt>::Ptr -&gt; pcl::PointCloud<pointt></pointt></pointt></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PointCloud&lt;PointT&gt;::<span class="function">Ptr <span class="title">cloud_ptr</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;PointT&gt;)</span></span>;</span><br><span class="line">PointCloud&lt;PointT&gt; cloud;</span><br><span class="line">cloud_ptr=cloud.makeShared();</span><br></pre></td></tr></table></figure>

<h4 id="不同数据类型的点云转换"><a href="#不同数据类型的点云转换" class="headerlink" title="不同数据类型的点云转换"></a>不同数据类型的点云转换</h4><ol>
<li>pcl::PointCloud<a href="pcl::PointXYZRGB" target="_blank" rel="noopener">pcl::PointXYZRGB</a> -&gt; pcl::PointCloud<a href="pcl::PointXYZ" target="_blank" rel="noopener">pcl::PointXYZ</a>::Ptr</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="function">Ptr <span class="title">cloud_ori</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">pcl::PointCloud&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;)</span></span>;</span><br><span class="line">pcl::copyPointCloud(*cloud_ori, *cloud);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pcl</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>pcl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ push_back和emplace_back的区别</title>
    <url>/push_back-emplace_back.html</url>
    <content><![CDATA[<p><code>push_back()</code>向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中(如果是拷贝的话，事后会自行销毁先前创建的这个元素)。</p><p>而 <code>emplace_back()</code> 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><p>事实上，大多数情况下二者没有区别，少数情况下 <code>emplace_back()</code> 效率更高，直接看下代码：</p><a id="more"></a>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestClass(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;b) : a_(a), b_(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  TestClass(<span class="keyword">const</span> TestClass &amp;other) : a_(other.a_), b_(other.b_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TestClass(TestClass &amp;&amp;other) : a_(other.a_), b_(<span class="built_in">std</span>::move(other.b_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TestClass&gt; vec;</span><br><span class="line">  vec.reserve(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">TestClass <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="string">"1"</span>)</span></span>;</span><br><span class="line">  <span class="function">TestClass <span class="title">t2</span><span class="params">(<span class="number">2</span>, <span class="string">"2"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n-----------------0---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(t1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(t1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------------1---------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t1));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.push_back(<span class="built_in">std</span>::move(t2));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------2----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(TestClass(<span class="number">3</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------3----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------4----------------\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">default constructor</span><br><span class="line"></span><br><span class="line">-----------------0---------------</span><br><span class="line">copy constructor</span><br><span class="line"></span><br><span class="line">copy constructor</span><br><span class="line">-----------------1---------------</span><br><span class="line">move constructor</span><br><span class="line"></span><br><span class="line">move constructor</span><br><span class="line">----------------2----------------</span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line">----------------3----------------</span><br><span class="line">default constructor</span><br><span class="line">move constructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">----------------4----------------</span><br></pre></td></tr></table></figure>

<p>从结果来看，只有直接调用构造有区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec.push_back(&#123;<span class="number">4</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">vec.emplace_back(<span class="number">4</span>, <span class="string">"4"</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>push_back()</code> 会调用默认构造和移动构造，而 <code>emplace_back()</code> 只调用一次默认构造， 效率更高。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 使用SCP远程拷贝文件</title>
    <url>/scp.html</url>
    <content><![CDATA[<p> 使用scp(secure copy)命令可以实现本地服务器和远程服务器之间的文件传输复制</p>
<a id="more"></a>



<h4 id="从本地复制到远程"><a href="#从本地复制到远程" class="headerlink" title="从本地复制到远程"></a>从本地复制到远程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt bot@10.0.9.211:/home/bot/test_folder/test.txt</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder</span><br><span class="line">scp test.txt 10.0.9.211:/home/bot/test_folder/test.txt</span><br></pre></td></tr></table></figure>

<h4 id="从远程复制到本地"><a href="#从远程复制到本地" class="headerlink" title="从远程复制到本地"></a>从远程复制到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp bot@10.0.9.211:/home/bot/test_folder text.txt</span><br><span class="line">scp bot@10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder test.txt</span><br><span class="line">scp 10.0.9.211:/home/bot/test_folder/test.txt test.txt</span><br></pre></td></tr></table></figure>

<h4 id="传输整个目录"><a href="#传输整个目录" class="headerlink" title="传输整个目录"></a>传输整个目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r /test_folder bot@10.0.9.211:/home/bot/test_folder</span><br></pre></td></tr></table></figure>

<h4 id="其他参数用法"><a href="#其他参数用法" class="headerlink" title="其他参数用法"></a>其他参数用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">usage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]</span><br><span class="line">           [-l <span class="built_in">limit</span>] [-o ssh_option] [-P port] [-S program]</span><br><span class="line">           [[user@]host1:]file1 ... [[user@]host2:]file2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>memo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++并发编程：std::future的使用</title>
    <url>/std-future.html</url>
    <content><![CDATA[<p><code>std::future</code> 是C++11 的一个模板类，<strong>提供了一种用于访问异步操作结果的机制</strong>。可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。</p>
<p>设想这样的情况，你希望一个线程进行工作A，同时你在做一些其他的工作，你希望在某个特定的时间获取那个工作A的结果。在c++11，这个可以轻松被 <code>std::future</code> 实现。而由于它是一个模板类，可以返回任何类型的结果。</p>
<a id="more"></a>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;Result&gt; fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 进行别的工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取A的结果 </span></span><br><span class="line">Result result = fut.get();</span><br></pre></td></tr></table></figure>

<h4 id="用法说明"><a href="#用法说明" class="headerlink" title="用法说明"></a>用法说明</h4><p><code>std::future</code> 对象通常由某个 <code>Provider</code> 创建，你可以把 <code>Provider</code> 想象成一个异步任务的提供者，<code>Provider</code> 在某个线程中设置共享状态的值，与该共享状态相关联的 <code>std::future</code> 对象（通常在另外一个线程中）调用 <code>std::future::get()</code> 获取该值。如果共享状态的标志不为 <code>std::future_status::ready</code>，则调用 <code>get()</code> 会<strong>阻塞</strong>当前的调用者，直到 <code>Provider</code> 设置了共享状态的值，<code>get()</code> 返回异步任务的返回值或发生的异常。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>std::future</code> 的拷贝构造函数和普通赋值操作是被禁用的，只提供了默认的构造函数和 <code>move</code> 构造函数。默认构造函数构造的对象没有共享状态，因此它是无效的，但是可以通过移动赋值的方式将一个有效的<code>future</code> 值赋值给它。</p>
<p>一个有效的 <code>std::future</code> 对象通常由以下三种 <code>Provider</code> 创建，并和某个共享状态相关联。</p>
<ul>
<li><code>std::async()</code> 函数</li>
<li><code>std::promise::get_future()</code>，为 <code>promise</code> 类的成员函数</li>
<li><code>std::packaged_task::get_future()</code>，为 <code>packaged_task</code> 的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut;           <span class="comment">// 默认构造函数</span></span><br><span class="line">fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::async(test, <span class="number">1</span>));   <span class="comment">// move-赋值操作。</span></span><br></pre></td></tr></table></figure>

<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul>
<li><p><code>bool valid()</code></p>
<p>检查共享状态的有效性，返回当前的 <code>future</code> 对象是否与共享状态关联。一旦调用了 <code>std::future::get()</code> 函数，再调用此函数将返回 <code>false</code> 。</p>
</li>
<li><p><code>void wait()</code></p>
<ul>
<li>等待共享状态就绪</li>
<li>如果共享状态尚未就绪(即未返回或发生异常)，则该函数将阻塞调用的线程直到就绪</li>
<li>当共享状态就绪后，则该函数将取消阻塞并void返回</li>
</ul>
</li>
<li><p><code>std::future_status wait_for(std::chrono::duration span)</code></p>
<ul>
<li>在指定的时间内等待共享状态就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到设置的时间</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="keyword">auto</span> future_status = fut.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; elapsed_seconds = end - start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waited for : "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result = fut.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">waited for : 1.00856s</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>std::future_status wait_until(std::chrono::time_point point)</code></p>
<ul>
<li>在指定的时间点前等待共享状态准备就绪</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪或已达到指定的时间点</li>
<li>返回<code>std::future_status</code>：<code>ready</code> / <code>timeout</code> / <code>deferred</code></li>
</ul>
</li>
<li><p><code>_Res get()</code></p>
<ul>
<li>当共享状态就绪时，返回存储在共享状态中的值(或抛出异常)</li>
<li>如果共享状态尚未就绪，则该函数将阻塞调用的线程直到就绪，相当于 <code>wait()</code> 再 <code>get()</code></li>
<li>当共享状态就绪后，则该函数将取消阻塞并返回释放其共享状态，这使得 <code>future</code> 对象不再有效，因此对于每一个 <code>future</code> 共享状态，<code>get()</code>函数最多应被调用一次</li>
<li><code>std::future&lt;void&gt;::get()</code> 不返回任何值，但仍等待共享状态就绪并释放它</li>
</ul>
</li>
<li><p><code>std::shared_future&lt;_Res&gt; share()</code></p>
<ul>
<li>返回一个 <code>std::shared_future</code> 对象，该对象获取 <code>future</code> 对象的共享状态。<code>future</code> 对象将不再有效。</li>
</ul>
</li>
</ul>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test()\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 sec later..\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::future&lt;<span class="keyword">bool</span>&gt; fut = <span class="built_in">std</span>::move(<span class="built_in">std</span>::async(test, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting..\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -1-</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = <span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::future_status future_status = fut.wait_for(timeout);</span><br><span class="line">  <span class="keyword">if</span> (future_status != <span class="built_in">std</span>::future_status::ready)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 sec timeout!\n"</span>;</span><br><span class="line">    <span class="comment">// return -1;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// -2-</span></span><br><span class="line">  fut.wait();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> result = fut.get();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nresult : "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="std-shared-future"><a href="#std-shared-future" class="headerlink" title="std::shared_future"></a><code>std::shared_future</code></h4><p><code>shared_future</code> 与 <code>future</code> 类似，但是允许多个线程等待同一个共享状态。 <code>shared_future</code> 既支持移动操作也支持拷贝操作，而且多个 <code>shared_future</code> 对象可以引用相同的共享状态，还允许多次检索共享状态下的值（多次调用 <code>get()</code> ）。</p>
<p><code>shared_future</code> 可以通过某个 <code>future</code> 对象隐式转换，或者通过 <code>std::future::share()</code> 显示转换，无论哪种转换，被转换的那个 <code>std::future</code> 对象都会变为 <code>not-valid</code>.</p>
<h4 id="std-launch"><a href="#std-launch" class="headerlink" title="std::launch"></a><strong>std::launch</strong></h4><p>该枚举类型主要是在调用<code>std::async</code> 设置异步任务的启动策略的。</p>
<p><code>std::async</code>的原型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async | <span class="built_in">std</span>::launch::deferred, f, args...)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>std::launch::async</code></p>
<p> 表示在调用<code>async</code>函数的时候就开始创建新线程。</p>
</li>
<li><p><code>std::launch::deferred</code></p>
<p>表示延迟调用，在调用 <code>future</code> 中的 <code>wait()</code> 或者 <code>get()</code> 函数时，才执行入口函数。（实际上，并没有创建新线程，只是在主线程中调用的入口函数）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async([]() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// deferred</span></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, []() &#123;<span class="keyword">return</span> A();&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>async</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 强制类型转换</title>
    <url>/type-cast.html</url>
    <content><![CDATA[<p>相比于C风格的强制类型转换，C++新增了关键字 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code> ，用于强制类型转换。</p><p>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。</p><h2 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. static_cast</h2><p>用于非多态类型转换 (静态转换)，任何标准转换都可以用它，但是不能用于两个不相关的类型转换。</p><a id="more"></a>


<p>常用于：</p>
<ul>
<li>基本数据类型之间的转换，如<code>int -&gt; char</code>，这种转换的安全也要开发人员来保证</li>
<li>任何类型的表达式转换成 <code>void</code> 类型</li>
<li>不能转换掉 <code>expression</code> 的 <code>const</code> 、<code>volitale</code> 或者 <code>__unaligned</code> 属性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">65</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"int a: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"char a: "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(a) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> c = a / b;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a: 65</span><br><span class="line">char a: A</span><br><span class="line">c: 6</span><br><span class="line">d: 6.5</span><br></pre></td></tr></table></figure>

<p><strong>没有运行时类型检查来保证转换的安全性</strong></p>
<ul>
<li>上行转型 (子类对象指针–&gt;父类对象指针/引用)： 安全</li>
<li>下行转型(父类对象指针–&gt;子类对象指针/引用)：没有动态类型检查，所以是不安全的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"typeinfo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">class_name</span><span class="params">()</span> final </span>&#123; <span class="keyword">return</span> <span class="keyword">typeid</span>(*<span class="keyword">this</span>).name(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt_1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt_2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt_3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">static_cast</span>&lt;B *&gt;(pt_3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1A 32686</span><br><span class="line">1B 3</span><br><span class="line">1C 5</span><br></pre></td></tr></table></figure>

<h2 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. dynamic_cast</h2><p>动态转换，常用于将一个父类对象的指针转换为子类对象的指针或引用。其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。</p>
<ul>
<li><p>使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过</p>
</li>
<li><p>在进行下行转换时，会进行类型检查 (这个信息存储在类的虚函数表)，比 <code>static_cast</code> 安全</p>
</li>
<li><p>转换后必须是类的指针、引用或 <code>void*</code></p>
</li>
<li><p>对于指针，转换失败会返回<code>nullptr</code>；对于引用，转换失败会 (在运行时) 抛出异常</p>
</li>
</ul>
<p><strong>返回指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A *pt1 = <span class="keyword">new</span> A;</span><br><span class="line">  A *pt2 = <span class="keyword">new</span> B;</span><br><span class="line">  A *pt3 = <span class="keyword">new</span> C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt2);</span><br><span class="line">  <span class="keyword">auto</span> b3 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pt3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b3)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b3-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b3-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b3 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b1 null</span><br><span class="line">1B 3</span><br><span class="line">b3 null</span><br></pre></td></tr></table></figure>

<p><strong>返回引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  C c;</span><br><span class="line">  A &amp;a1 = b;</span><br><span class="line">  A &amp;a2 = c;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a1);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="keyword">dynamic_cast</span>&lt;B &amp;&gt;(a2);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2.class_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B</span><br><span class="line">terminate called after throwing an instance of <span class="string">'std::bad_cast'</span></span><br><span class="line">  what():  std::bad_cast</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>

<h2 id="std-dynamic-pointer-cast"><a href="#std-dynamic-pointer-cast" class="headerlink" title="std::dynamic_pointer_cast"></a>std::dynamic_pointer_cast</h2><p>使用 <code>std::dynamic_pointer_cast</code> 可以返回 <code>std::shared_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt1 = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; pt2 = <span class="built_in">std</span>::make_shared&lt;C&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b1 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt1);</span><br><span class="line">  <span class="keyword">auto</span> b2 = <span class="built_in">std</span>::dynamic_pointer_cast&lt;B&gt;(pt2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b1)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b1-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b1-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b1 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b2)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b2-&gt;class_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; b2-&gt;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b2 null"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1B 3</span><br><span class="line">b2 null</span><br></pre></td></tr></table></figure>

<h2 id="3-reinterpret-cast"><a href="#3-reinterpret-cast" class="headerlink" title="3. reinterpret_cast"></a>3. reinterpret_cast</h2><p>主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。</p>
<p><code>reinterpret_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li><p><code>type-id</code> 必须是一个指针、引用、算术类型、函数指针或者成员指针。</p>
</li>
<li><p>在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<h2 id="4-const-cast"><a href="#4-const-cast" class="headerlink" title="4. const_cast"></a>4. const_cast</h2><p><code>const</code> 限定符通常被用来限定变量，用于表示该变量的值不能被修改。而 <code>const_cast</code> 则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是 <code>const_cast</code> 不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</p>
<p><code>const_cast&lt;type_id&gt; (expression)</code></p>
<ul>
<li>该运算符用来修改类型的 <code>const</code> 或 <code>volatile</code> 属性，<code>type_id</code>和 <code>expression</code> 的类型是一样的</li>
<li>常量指针被转化成非常量指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::vector的内存分配机制</title>
    <url>/std-vector_memory.html</url>
    <content><![CDATA[<blockquote>
<p><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector;</code></p>
</blockquote><h3 id="std-vector-简介"><a href="#std-vector-简介" class="headerlink" title="std::vector 简介"></a>std::vector 简介</h3><p><code>std::vector</code> 是C++标准库里封装好的<strong>动态大小数组</strong>的顺序容器，能够存放各种类型的对象。</p><p>与数组 <code>array</code> 一样， <code>vector</code> 的<strong>内存空间的地址是连续的</strong>。这意味着可以通过下标索引的方式获取到对应的元素，所以访问其元素的效率非常高，从其末端添加或删除元素的效率也相对较高。而对于涉及在非结束位置插入或删除元素的操作，它们的性能比其他操作差，效率较低。</p><a id="more"></a>


<p>但与<code>array</code>不同的是，它们的大小可以动态变化，它们的存储由容器自动处理。在插入新元素时，若当前容量不能够容纳新的元素，将自动重新申请一块更大的内存空间，将原有数据拷贝到新的内存空间，且释放原来的空间。这一过程非常耗时，为了避免频繁的内容分配， <code>vector</code> 不会在每次添加元素时都重新分配空间，而是分配一些额外的存储空间来容纳可能的增长。因此， <code>vector</code> 的实际容量 (<strong>capacity</strong>) 永远大于等于它容纳的元素大小 (<strong>size</strong>)。</p>
<h3 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h3><h4 id="1-自动增长策略"><a href="#1-自动增长策略" class="headerlink" title="1. 自动增长策略"></a>1. 自动增长策略</h4><p>假设元素是连续存储的，并且容器的大小是可变的，如果此时向 vector 中添加新的元素，容器不可能简单地将它添加到内存的其它位置，因为元素必须是连续存储的。</p>
<p>容器必须分配新的空间，来保存已有元素和新的元素，将已有的元素从旧位置移动到新空间。然后添加新元素，释放旧的存储空间。如果每添加一个元素，容器就执行一次内存分配和释放，性能会变得超级慢。</p>
<p>为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配的策略。当不得不获取新的空间的时候，<code>vector</code> 的实现，通常会分配比需求空间更大的内存空间。这种分配策略，比每次添加新元素后都重新分配容器内存空间的策略要高效的多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 0  size: 0</span><br><span class="line">2 vec capacity: 1  size: 1</span><br><span class="line">3 vec capacity: 2  size: 2</span><br><span class="line">4 vec capacity: 4  size: 3</span><br><span class="line">5 vec capacity: 4  size: 4</span><br><span class="line">6 vec capacity: 8  size: 5</span><br></pre></td></tr></table></figure>

<p>可以看出，每当 <code>size</code> 和 <code>capacity</code> 相等时，也就是无法容纳新的元素时，<code>vector</code> 自动申请了新的 (成倍增长的) 容量。</p>
<h4 id="2-手动分配内存-reserve-和-resize"><a href="#2-手动分配内存-reserve-和-resize" class="headerlink" title="2. 手动分配内存: reserve 和 resize"></a>2. 手动分配内存: reserve 和 resize</h4><p><code>std::vector</code> 有自动分配内存的机制，但我们也可以通过<code>reserve()</code> 和 <code>resize()</code> 来手动分配内存，使其效率更高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ele</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ele: "</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : vec)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line">  vec.push_back(<span class="number">3</span>);</span><br><span class="line">  vec.push_back(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.reserve(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 0</span><br><span class="line">2 vec capacity: 4  size: 4</span><br><span class="line">3 vec capacity: 4  size: 4</span><br><span class="line">ele: 1 2 3 4 </span><br><span class="line">4 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 4 0 </span><br><span class="line">5 vec capacity: 8  size: 3</span><br><span class="line">ele: 1 2 3 </span><br><span class="line">6 vec capacity: 8  size: 5</span><br><span class="line">ele: 1 2 3 0 0</span><br></pre></td></tr></table></figure>

<p>可以看出：</p>
<ol>
<li><code>reserve()</code> 只增加不减少数组的 <code>capacity</code>，不对 <code>size()</code> 造成任何改变</li>
<li><code>resize()</code> 只增加不减少数组的 <code>capacity</code>，但可以增加和减少 <code>size</code>。减少时会直接移除多余的元素，增加时会填入默认值 (0)。</li>
</ol>
<h4 id="3-手动回收内存"><a href="#3-手动回收内存" class="headerlink" title="3. 手动回收内存"></a>3. 手动回收内存</h4><h5 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h5><p><code>erase()</code> 可以从 <code>vector</code> 中移除单个或一段元素 [begin, end)，实际上是以后面的元素移动并覆盖前面的位置，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin() + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  vec.erase(vec.begin(), vec.begin() + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  print_ele(vec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 5  size: 5</span><br><span class="line">2 vec capacity: 5  size: 4</span><br><span class="line">ele: 1 3 4 5 </span><br><span class="line">3 vec capacity: 5  size: 2</span><br><span class="line">ele: 4 5</span><br></pre></td></tr></table></figure>

<h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><p><code>clear()</code> 可以移除 <code>vector</code>所有元素，使容器<code>size</code> 为0，不对<code>capacity</code> 造成改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.clear();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 4  size: 4</span><br><span class="line">2 vec capacity: 4  size: 0</span><br></pre></td></tr></table></figure>

<h5 id="shrink-to-fit-c-11"><a href="#shrink-to-fit-c-11" class="headerlink" title="shrink_to_fit (c++11)"></a>shrink_to_fit (c++11)</h5><p><code>shrink_to_fit()</code> 可以请求将内存减少到等于当前元素实际所使用的大小，也就是使 <code>capacity = size</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.resize(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  vec.shrink_to_fit();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3 vec capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="string">"  size: "</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 vec capacity: 10  size: 10</span><br><span class="line">2 vec capacity: 10  size: 1</span><br><span class="line">3 vec capacity: 1  size: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类构造函数</title>
    <url>/constructor.html</url>
    <content><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，用于创建类的新对象和初始化自定义类成员。</p><ul>
<li>构造函数具有与类相同的名称，没有返回值，也不返回 <code>void</code>。</li>
<li>可以根据需要定义多个重载构造函数，以各种方式自定义初始化。</li>
<li>构造函数可用于为某些成员变量设置初始值。</li>
<li>通常构造函数具有<strong>公共</strong>可访问性，因此外部代码可以调用其创建类的对象，但也可以将构造函数声明为 <strong>protected</strong> 或 <strong>private</strong> 。</li>
<li>构造函数可以声明为 <strong><code>inline</code>, <code>explicit</code>, <code>friend</code> 或 <code>constexpr</code></strong></li>
<li>构造函数可以初始化已声明为 <code>const</code>, <code>volatile</code> 或者<code>const volatile</code> 的对象，该对象在构造完成后变为 <code>const</code></li>
<li>如果没有自己声明，编译器将为一个类声明 (编译器版本的) <strong>默认构造函数、复制构造函数、复制赋值操作符和析构函数</strong>。所有这些函数都是 <code>public</code> 且 <code>inline</code> 的。</li>
</ul><a id="more"></a>

<h2 id="成员初始化列表-Member-Initializer-List"><a href="#成员初始化列表-Member-Initializer-List" class="headerlink" title="成员初始化列表 Member Initializer List"></a>成员初始化列表 Member Initializer List</h2><p>构造函数可以有一个成员初始化列表，用于在执行构造函数体之前初始化类成员。</p>
<p>使用成员初始化列表比在构造函数体中赋值的效率更高，因为它直接初始化成员变量，而不需要调用赋值构造。</p>
<p><strong>对基类构造函数的调用应在初始化器列表中进行，以确保基类在执行派生构造函数之前已完全初始化。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base(<span class="keyword">int</span> b) : b_(b) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Derived(<span class="keyword">int</span> b, <span class="keyword">int</span> d) : Base(b), d_(d) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以指定无物 (nothing) 作为初始化实参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived() : Base(), d_(<span class="number">0</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="默认构造-Default-Constructor"><a href="#默认构造-Default-Constructor" class="headerlink" title="默认构造 Default Constructor"></a>默认构造 Default Constructor</h2><p>默认构造函数通常没有参数，但它们可以具有具有默认值的参数。调用默认构造函数时，不应使用括号 (会被视为函数声明) :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 没有参数</span></span><br><span class="line">    Box() &#123; <span class="comment">/*perform any required default initialization steps*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有参数都具有默认值</span></span><br><span class="line">    Box (<span class="keyword">int</span> w = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> h = <span class="number">1</span>): m_width(w), m_height(h), m_length(l)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box1;</span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">box3</span><span class="params">()</span></span>; <span class="comment">// warning C4930: prototyped function not called (was a variable definition intended?)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认构造函数是 <strong>特殊成员函数</strong> 之一，如果未在类中声明任何构造函数，编译器将提供隐式默认的 <strong>inline</strong> 构造函数。如果依赖于隐式默认构造函数，需要确保初始化所有成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Volume</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_width * m_height * m_length;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width&#123;<span class="number">0</span>&#125;; <span class="comment">// 初始化成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_height&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_length&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box box1; <span class="comment">// 调用编译器自动生成的默认构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"box1.Volume: "</span> &lt;&lt; box1.Volume() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Outputs 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果声明了任何非默认构造函数，则编译器不提供默认构造函数。没有默认构造函数时，该类的对象数组不能只使用方括号语法构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> width, <span class="keyword">int</span> length, <span class="keyword">int</span> height)</span><br><span class="line">        : m_width(width), m_length(length), m_height(height)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Box box; <span class="comment">// C2512: no appropriate default constructor available</span></span><br><span class="line">    Box boxes[<span class="number">3</span>]; <span class="comment">// C2512: no appropriate default constructor available</span></span><br><span class="line">    Box boxes1[<span class="number">3</span>]&#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制构造-Copy-Constructor"><a href="#复制构造-Copy-Constructor" class="headerlink" title="复制构造 Copy Constructor"></a>复制构造 Copy Constructor</h2><p>复制构造函数通过从相同类型的对象中复制成员值来初始化对象。</p>
<p>如果类成员都是标准简单类型，编译器自动生成的复制构造函数就足够了。但如果成员变量存在指针等复杂类型，那么需要自定义复制构造函数，用于分配新的内存等操作。</p>
<p><strong>Pass-by-value 将自动调用复制构造函数。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box(Box&amp; other); <span class="comment">// Avoid if possible--allows modification of other.</span></span><br><span class="line">Box(<span class="keyword">const</span> Box&amp; other);</span><br><span class="line">Box(<span class="keyword">volatile</span> Box&amp; other);</span><br><span class="line">Box(<span class="keyword">volatile</span> <span class="keyword">const</span> Box&amp; other);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Additional parameters OK if they have default values</span></span><br><span class="line">Box(Box&amp; other, <span class="keyword">int</span> i = <span class="number">42</span>, <span class="built_in">string</span> label = <span class="string">"Box"</span>);</span><br></pre></td></tr></table></figure>

<p>通过将复制构造函数定义为已删除，可以防止对象被复制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box (<span class="keyword">const</span> Box&amp; other) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果定义了复制构造函数，还应定义复制赋值运算符 (=)。</strong></p>
<h2 id="赋值运算符-Copy-Assignment"><a href="#赋值运算符-Copy-Assignment" class="headerlink" title="赋值运算符 Copy Assignment"></a>赋值运算符 Copy Assignment</h2><p>赋值运算符 (<strong>=</strong>) 严格地说是二元运算符，但比较特殊：</p>
<ul>
<li>必须是<strong>非静态</strong> <strong>成员函数</strong>。 </li>
<li>不会被派生类继承。</li>
<li>如果不手动定义，编译器会自动生成一个默认的赋值运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Right side of copy assignment is the argument.</span></span><br><span class="line">    Box&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Box&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_width, m_length, m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define copy assignment operator.</span></span><br><span class="line">Box&amp; Box::<span class="keyword">operator</span>=(<span class="keyword">const</span> Box&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        m_width = other.m_width;</span><br><span class="line">        m_length = other.m_length;</span><br><span class="line">        m_height = other.m_height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment operator returns left side of assignment.</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复制构造函数和赋值运算符的区别</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box box1;</span><br><span class="line">Box box2 = box1; <span class="comment">// Copy constructor is called</span></span><br><span class="line"><span class="function">Box <span class="title">box3</span><span class="params">(box1)</span></span>; <span class="comment">// Copy constructor call.</span></span><br></pre></td></tr></table></figure>

<h2 id="移动构造-Move-Constructor"><a href="#移动构造-Move-Constructor" class="headerlink" title="移动构造 Move Constructor"></a>移动构造 Move Constructor</h2><p>移动构造函数是一种特殊成员函数，它无需复制原始数据即可将现有对象数据的所有权移动到新对象。它采用左值引用作为第一个参数，任何其他参数都必须具有默认值。移动构造函数可以在传递大型对象时显著提高程序的效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box(Box&amp;&amp; other);</span><br></pre></td></tr></table></figure>

<p>如果对象由即将销毁且不再需要其资源的另一个相同类型的对象初始化，编译器会选择使用移动构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestClass(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;b) : a_(a), b_(b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  TestClass(<span class="keyword">const</span> TestClass &amp;other) : a_(other.a_), b_(other.b_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TestClass(TestClass &amp;&amp;other) : a_(other.a_), b_(<span class="built_in">std</span>::move(other.b_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TestClass&gt; vec;</span><br><span class="line">  vec.reserve(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(TestClass(<span class="number">1</span>, <span class="string">"3"</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">move</span><br></pre></td></tr></table></figure>

<p>如果<strong>没有定义移动构造函数</strong>，则输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default</span><br><span class="line">copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果没有定义移动构造函数，且没有用户声明的复制构造函数、复制赋值运算符、移动赋值运算符或析构函数，编译器将生成隐式构造函数。</p>
</li>
<li><p>如果未定义显式或隐式移动构造函数，则使用移动构造函数的操作将被改为使用复制构造函数。</p>
</li>
<li><p>如果定义了移动构造函数或移动赋值运算符，则隐式声明的复制构造函数将被定义为 <code>deleted</code>。</p>
</li>
<li><p>如果作为类类型的任何成员缺少析构函数或编译器无法确定要用于移动操作哪个构造函数，则隐式声明移动构造函数定义为 <code>deleted</code>。</p>
</li>
</ul>
<h2 id="委托构造函数-Delegating-Constructor"><a href="#委托构造函数-Delegating-Constructor" class="headerlink" title="委托构造函数 Delegating Constructor"></a>委托构造函数 Delegating Constructor</h2><p>委托构造函数调用同一类中的不同构造函数来执行某些初始化工作。</p>
<p>可以在一个构造函数中编写主逻辑，并从其他构造函数调用它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> i) :  Box(i, i, i) &#123;&#125;  <span class="comment">// 委托构造</span></span><br><span class="line">    Box(<span class="keyword">int</span> width, <span class="keyword">int</span> length, <span class="keyword">int</span> height)</span><br><span class="line">        : m_width(width), m_length(length), m_height(height) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="explicit-显式构造"><a href="#explicit-显式构造" class="headerlink" title="explicit 显式构造"></a>explicit 显式构造</h2><p>将构造函数声明为 <code>explicit</code> 可以防止隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    explicit Test(int i) : num(i) &#123; cout &lt;&lt; "Test(int)" &lt;&lt; endl; &#125;</span><br><span class="line">    explicit Test(char c) : letter(c) &#123; cout &lt;&lt; "Test(char)" &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> letter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="string">'2'</span>)</span></span>;</span><br><span class="line">    Test t = <span class="number">3</span>; <span class="comment">// 编译器错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显式默认和删除"><a href="#显式默认和删除" class="headerlink" title="显式默认和删除"></a>显式默认和删除</h2><ul>
<li>可以显式默认复制构造函数、默认构造函数、move构造函数、复制赋值操作符、move赋值操作符和析构函数。</li>
<li>可以显式地删除所有特殊成员函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">    Noncopyable(<span class="keyword">const</span> Noncopyable&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Noncopyable&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable(Noncopyable&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Noncopyable&amp; <span class="keyword">operator</span>=(Noncopyable&amp;&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleOnly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> d_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DoubleOnly(<span class="keyword">float</span>) = <span class="keyword">delete</span>;</span><br><span class="line">  DoubleOnly(<span class="keyword">double</span> d) : d_(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些规则：</p>
<ul>
<li>如果显式声明了任何构造函数，则不会自动生成默认构造函数。</li>
<li>如果显式声明了虚拟析构函数，则不会自动生成默认析构函数。</li>
<li>如果显式声明了移动构造函数或移动赋值运算符，则：<ul>
<li>不自动生成复制构造函数。</li>
<li>不自动生成复制赋值运算符。</li>
</ul>
</li>
<li>如果显式声明了复制构造函数、复制赋值运算符、移动构造函数、移动赋值运算符或析构函数，则：<ul>
<li>不自动生成移动构造函数。</li>
<li>不自动生成移动赋值运算符。</li>
</ul>
</li>
</ul>
<h2 id="构造顺序"><a href="#构造顺序" class="headerlink" title="构造顺序"></a>构造顺序</h2><p>构造函数按此顺序执行工作：</p>
<ul>
<li><p>按声明顺序调用基类和成员构造函数。</p>
</li>
<li><p>如果类继承自一个虚拟基类，将对象的虚拟基指针初始化。</p>
</li>
<li><p>如果类具有或继承了虚函数，将对象的虚函数指针初始化。虚函数指针指向类中的虚函数表，确保虚函数正确地调用绑定代码。</p>
</li>
<li><p>执行构造函数体中的代码。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained1 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained2() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained2 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contained3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Contained3() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Contained3 ctor\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseContainer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  BaseContainer() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"BaseContainer ctor\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Contained1 c1;</span><br><span class="line">  Contained2 c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedContainer</span> :</span> <span class="keyword">public</span> BaseContainer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  DerivedContainer() : BaseContainer() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DerivedContainer ctor\n"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Contained3 c3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DerivedContainer dc;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Contained1 ctor</span><br><span class="line">Contained2 ctor</span><br><span class="line">BaseContainer ctor</span><br><span class="line">Contained3 ctor</span><br><span class="line">DerivedContainer ctor</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/cpp/cpp/constructors-cpp?view=msvc-170</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>构造</tag>
      </tags>
  </entry>
</search>
